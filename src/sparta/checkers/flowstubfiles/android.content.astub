package android.content;

class AsyncTaskLoader {
    
    
void cancelLoadInBackground();
//Called on the main thread to abort a load in progress.

void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

boolean isLoadInBackgroundCanceled();
//Returns true if the current invocation of loadInBackground(); is being canceled.

abstract D loadInBackground();
//Called on a worker thread to perform the actual load and to return the result of the load operation.

void onCanceled(D data);
//Called if the task was canceled before it was completed.

void setUpdateThrottle(long delayMS);
//Set amount to throttle updates by.

//Protected Methods
boolean onCancelLoad();
//Subclasses must implement this to take care of requests to cancelLoad();.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

D onLoadInBackground();
//Calls loadInBackground();.



}
class BroadcastReceiver {
    
//CSH:  Not sure how to do this class.  It's probably ANY/ANY, since you sometimes need permissions to use this...  

BroadcastReceiver();
//New BraodcastReceiver

final void abortBroadcast();
//Sets the flag indicating that this receiver should abort the current broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void clearAbortBroadcast();
//Clears the flag indicating that this receiver should abort the current broadcast.

final boolean getAbortBroadcast();
//Returns the flag indicating whether or not this receiver should abort the current broadcast.

final boolean getDebugUnregister();
//Return the last value given to setDebugUnregister(boolean);.

final int getResultCode();
//Retrieve the current result code, as set by the previous receiver.

final String getResultData();
//Retrieve the current result data, as set by the previous receiver.

final Bundle getResultExtras(boolean makeMap);
//Retrieve the current result extra data, as set by the previous receiver.

final BroadcastReceiver.PendingResult goAsync();
//This can be called by an application in onReceive(Context, Intent); to allow it to keep the broadcast active after returning from that function.

final boolean isInitialStickyBroadcast();
//Returns true if the receiver is currently processing the initial value of a sticky broadcast -- that is, the value that was last broadcast and is currently held in the sticky cache, so this is not directly the result of a broadcast right now.

final boolean isOrderedBroadcast();
//Returns true if the receiver is currently processing an ordered broadcast.

abstract void onReceive(Context context, Intent intent);
//This method is called when the BroadcastReceiver is receiving an Intent broadcast.

IBinder peekService(Context myContext, Intent service);
//Provide a binder to an already-running service.

final void setDebugUnregister(boolean debug);
//Control inclusion of debugging help for mismatched calls to Context.registerReceiver();.

final void setOrderedHint(boolean isOrdered);
//For internal use, sets the hint about whether this BroadcastReceiver is running in ordered mode.

final void setResult(int code, String data, Bundle extras);
//Change all of the result data returned from this broadcasts; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultCode(int code);
//Change the current result code of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultData(String data);
//Change the current result data of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultExtras(Bundle extras);
//Change the current result extras of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.



}
class ClipData{
        static ClipData newPlainText(CharSequence label, CharSequence text);
}

class ClipboardManager extends ClipboardManager {
//ClipData objects not annotated, because the class itself is annoated
//SOM
    void setPrimaryClip(ClipData arg0);
    ClipData getPrimaryClip();
    ClipDescription getPrimaryClipDescription();
    boolean hasPrimaryClip();
    void addPrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    void removePrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    @Source(READ_CLIPBOARD) CharSequence getText();
    void setText(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    boolean hasText();
}
class ClipData implements Parcelable {
    ClipData(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) String @Sink(WRITE_CLIPBOARD) [] arg1, @Sink(WRITE_CLIPBOARD) Item arg2);
    ClipData(ClipDescription arg0, @Sink(WRITE_CLIPBOARD)  Item arg1);
    static ClipData newPlainText(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1);
    static ClipData newIntent(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1);
    static ClipData newUri(@Sink(WRITE_CLIPBOARD) ContentResolver arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    static ClipData newRawUri(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Uri arg1);
    @Source(READ_CLIPBOARD) ClipDescription getDescription();
    void addItem(@Sink(WRITE_CLIPBOARD) Item arg0);
    int getItemCount();
    @Source(READ_CLIPBOARD) Item getItemAt(@Sink(WRITE_CLIPBOARD) int arg0);
    int describeContents();
    void writeToParcel(@Source(READ_CLIPBOARD) Parcel arg0, int arg1);
}
class ClipData$Item {
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    Item(@Sink(WRITE_CLIPBOARD) Intent arg0);
    Item(@Sink(WRITE_CLIPBOARD) Uri arg0);
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    @Source(READ_CLIPBOARD) CharSequence getText();
    @Source(READ_CLIPBOARD) Intent getIntent();
    @Source(READ_CLIPBOARD) Uri getUri();
    @Source(READ_CLIPBOARD) CharSequence coerceToText(@Sink(WRITE_CLIPBOARD) Context arg0);
}

class ComponentName {
    
ComponentName clone();
//Creates and returns a copy of this Object.

int compareTo(ComponentName that);

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object obj);
//Compares this instance with the specified object and indicates if they are equal.

String flattenToShortString();
//The same as flattenToString();, but abbreviates the class name if it is a suffix of the package.

String flattenToString();
//Return a String that unambiguously describes both the package and class names contained in the ComponentName.

String getClassName();
//Return the class name of this component.

String getPackageName();
//Return the package name of this component.

String getShortClassName();
//Return the class name, either fully qualified or in a shortened form (with a leading '.'); if it is a suffix of the package.

int hashCode();
//Returns an integer hash code for this object.

static @Source(PARCEL) ComponentName readFromParcel(Parcel in);
//Read a ComponentName from a Parcel that was previously written with writeToParcel(ComponentName, Parcel);, returning either a null or new object as appropriate.

String toShortString();
//Return string representation of this class without the class's name as a prefix.

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ComponentName unflattenFromString(String str);
//Recover a ComponentName from a String that was previously created with flattenToString();.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

static void writeToParcel(@Sink(PARCEL) ComponentName c, Parcel out);
//Write a ComponentName to a Parcel, handling null pointers.

    
}

class ComponentCallbacks{
            void onLowMemory();
            void onConfigurationChanged(Configuration arg0);
}
class ComponentName{
            ComponentName(Context pkg, String cls);
            String getPackageName();
}

class ContentProvider {

//CSH: content providers are tricky because they look like SQL queries, but can be implemented with anything, files, in-memory objects, databases, etc... not quite sure what to do here
    
ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations);
//Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call apply(ContentProvider, ContentProviderResult[], int); on each of them.

void attachInfo(Context context, ProviderInfo info);
//After being instantiated, this is called to tell the content provider about itself.

int bulkInsert(Uri uri, ContentValues[] values);
//Override this to handle requests to insert a set of new rows, or the default implementation will iterate over the values and call insert(Uri, ContentValues); on each of them.

Bundle call(String method, String arg, Bundle extras);
//Call a provider-defined method.

abstract int delete(Uri uri, String selection, String[] selectionArgs);
//Implement this to handle requests to delete one or more rows.

final Context getContext();
//Retrieves the Context this provider is running in.

final PathPermission[] getPathPermissions();
//Return the path-based permissions required for read and/or write access to this content provider.

final String getReadPermission();
//Return the name of the permission required for read-only access to this content provider.

String[] getStreamTypes(Uri uri, String mimeTypeFilter);
//Called by a client to determine the types of data streams that this content provider supports for the given URI.

abstract String getType(Uri uri);
//Implement this to handle requests for the MIME type of the data at the given URI.

final String getWritePermission();
//Return the name of the permission required for read/write access to this content provider.

abstract Uri insert(Uri uri, ContentValues values);
//Implement this to handle requests to insert a new row.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running. This method is always called on the application main thread, and must not perform lengthy operations.

abstract boolean onCreate();
//Implement this to initialize your content provider on startup.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt. This method is always called on the application main thread, and must not perform lengthy operations.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

AssetFileDescriptor openAssetFile(Uri uri, String mode);
//This is like openFile(Uri, String);, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk.

ParcelFileDescriptor openFile(Uri uri, String mode);
//Override this to handle requests to open a file blob.

<T> ParcelFileDescriptor openPipeHelper(Uri uri, String mimeType, Bundle opts, T args, PipeDataWriter<T> func);
//A helper function for implementing openTypedAssetFile(Uri, String, Bundle);, for creating a data pipe and background thread allowing you to stream generated data back to the client.

AssetFileDescriptor openTypedAssetFile(Uri uri, String mimeTypeFilter, Bundle opts);
//Called by a client to open a read-only stream containing data of a particular MIME type.

@PolyFlowReceiver
abstract Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Implement this to handle query requests from clients.

@PolyFlowReceiver
Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Implement this to handle query requests from clients with support for cancellation.

void shutdown();
//Implement this to shut down the ContentProvider instance.

abstract int update(@PolySink @PolySource Uri uri, @PolySink @PolySource ContentValues values, String selection, String[] selectionArgs);
//Implement this to handle requests to update one or more rows.

//Protected Methods
boolean isTemporary();
//Returns true if this instance is a temporary content provider.

final ParcelFileDescriptor openFileHelper(Uri uri, String mode);
//Convenience for subclasses that wish to implement openFile(Uri, String); by looking up a column named "_data" at the given URI.

final void setPathPermissions(PathPermission[] permissions);
//Change the path-based permission required to read and/or write data in the content provider.

final void setReadPermission(String permission);
//Change the permission required to read data from the content provider.

final void setWritePermission(String permission);
//Change the permission required to read and write data in the content provider.

}

class ContentResolver {
    
final ContentProviderClient acquireContentProviderClient(Uri uri);
//Returns a ContentProviderClient that is associated with the ContentProvider that services the content at uri, starting the provider if necessary.

final ContentProviderClient acquireContentProviderClient(String name);
//Returns a ContentProviderClient that is associated with the ContentProvider with the authority of name, starting the provider if necessary.

final ContentProviderClient acquireUnstableContentProviderClient(Uri uri);
//Like acquireContentProviderClient(Uri);, but for use when you do not trust the stability of the target content provider.

final ContentProviderClient acquireUnstableContentProviderClient(String name);
//Like acquireContentProviderClient(String);, but for use when you do not trust the stability of the target content provider.

static void addPeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras, @Sink(WRITE_SYNC_SETTINGS) long pollFrequency);
//Specifies that a sync should be requested with the specified the account, authority, and extras at the given frequency.

static Object addStatusChangeListener(int mask, SyncStatusObserver callback);
//Request notifications when the different aspects of the SyncManager change.

ContentProviderResult[] applyBatch(String authority, ArrayList<ContentProviderOperation> operations);
//Applies each of the ContentProviderOperation objects and returns an array of their results.

final int bulkInsert(Uri url, ContentValues[] values);
//Inserts multiple rows into a table at the given URL.

final Bundle call(Uri uri, String method, String arg, Bundle extras);
//Call a provider-defined method.

static void cancelSync(Account account, String authority);
//Cancel any active or pending syncs that match account and authority.

void cancelSync(Uri uri);
//This method was deprecated in API level 5. instead use cancelSync(android.accounts.Account, String);

final int delete(Uri url, String where, String[] selectionArgs);
//Deletes row(s); specified by a content URI.

static @Source(READ_SYNC_STATS) SyncInfo getCurrentSync();
//This method was deprecated in API level 11. Since multiple concurrent syncs are now supported you should use getCurrentSyncs(); to get the accurate list of current syncs. This method returns the first item from the list of current syncs or null if there are none.

static @Source(READ_SYNC_STATS) List<SyncInfo> getCurrentSyncs();
//Returns a list with information about all the active syncs.

static @Source(READ_SYNC_SETTINGS) int getIsSyncable(Account account, String authority);
//Check if this account/provider is syncable.

static  @Source(READ_SYNC_SETTINGS) boolean getMasterSyncAutomatically();
//Gets the master auto-sync setting that applies to all the providers and accounts.

static  @Source(READ_SYNC_SETTINGS) List<PeriodicSync> getPeriodicSyncs(Account account, String authority);
//Get the list of information about the periodic syncs for the given account and authority.

String[] getStreamTypes(Uri url, String mimeTypeFilter);
//Query for the possible MIME types for the representations the given content URL can be returned when opened as as stream with openTypedAssetFileDescriptor(Uri, String, Bundle);.

static SyncAdapterType[] getSyncAdapterTypes();
//Get information about the SyncAdapters that are known to the system.

static @Source(READ_SYNC_SETTINGS) boolean getSyncAutomatically(Account account, String authority);
//Check if the provider should be synced when a network tickle is received
//This method requires the caller to hold the permission READ_SYNC_SETTINGS.

final String getType(Uri url);
//Return the MIME type of the given content URL.

final Uri insert(Uri url, ContentValues values);
//Inserts a row into a table at the given URL.

static @Source(READ_SYNC_STATS) boolean isSyncActive(Account account, String authority);
//Returns true if there is currently a sync operation for the given account or authority in the pending list, or actively being processed.

static @Source(READ_SYNC_STATS) boolean isSyncPending(Account account, String authority);
//Return true if the pending status is true of any matching authorities.

void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork);
//Notify registered observers that a row was updated.

void notifyChange(Uri uri, ContentObserver observer);
//Notify registered observers that a row was updated and attempt to sync changes to the network.

final AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final ParcelFileDescriptor openFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final InputStream openInputStream(Uri uri);
//Open a stream on to the content associated with a content URI.

final OutputStream openOutputStream(Uri uri);
//Synonym for openOutputStream(uri, "w");.

final OutputStream openOutputStream(Uri uri, String mode);
//Open a stream on to the content associated with a content URI.

final AssetFileDescriptor openTypedAssetFileDescriptor(Uri uri, String mimeType, Bundle opts);
//Open a raw file descriptor to access (potentially type transformed); data from a "content:" URI.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Query the given URI, returning a Cursor over the result set.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Query the given URI, returning a Cursor over the result set.

final void registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer);
//Register an observer class that gets callbacks when data identified by a given content URI changes.

static void removePeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras);
//Remove a periodic sync.

static void removeStatusChangeListener(Object handle);
//Remove a previously registered status change listener.

static void requestSync(Account account, String authority, Bundle extras);
//Start an asynchronous sync operation.

static void setIsSyncable(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) int syncable);
//Set whether this account/provider is syncable.

static void setMasterSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Sets the master auto-sync setting that applies to all the providers and accounts.

static void setSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Set whether or not the provider is synced when it receives a network tickle.

void startSync(Uri uri, Bundle extras);
//This method was deprecated in API level 5. instead use requestSync(android.accounts.Account, String, android.os.Bundle);

final void unregisterContentObserver(ContentObserver observer);
//Unregisters a change observer.

final int update(@PolySource @PolySink Uri uri, @PolySource @PolySink ContentValues values, String where, String[] selectionArgs);
//Update row(s); in a content URI.

static void validateSyncExtrasBundle(Bundle extras);
//Check that only values of the following types are in the Bundle:
//Integer
//Long
//Boolean
//Float
//Double
//String
//Account
//null


}

class ContentUris {
    
static Uri.Builder appendId(Uri.Builder builder, long id);
//Appends the given ID to the end of the path.

static long parseId(Uri contentUri);
//Converts the last path segment to a long.

static Uri withAppendedId(Uri contentUri, long id);
//Appends the given ID to the end of the path.



}

@PolyFlowReceiver
class ContentValues {

ContentValues();
    
void clear();
//Removes all values.

boolean containsKey(String key);
//Returns true if this object has the named value.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object object);
//Compares this instance with the specified object and indicates if they are equal.

Object get(String key);
//Gets a value.

Boolean getAsBoolean(String key);
//Gets a value and converts it to a Boolean.

Byte getAsByte(String key);
//Gets a value and converts it to a Byte.

byte[] getAsByteArray(String key);
//Gets a value that is a byte array.

Double getAsDouble(String key);
//Gets a value and converts it to a Double.

Float getAsFloat(String key);
//Gets a value and converts it to a Float.

Integer getAsInteger(String key);
//Gets a value and converts it to an Integer.

Long getAsLong(String key);
//Gets a value and converts it to a Long.

Short getAsShort(String key);
//Gets a value and converts it to a Short.

String getAsString(String key);
//Gets a value and converts it to a String.

int hashCode();
//Returns an integer hash code for this object.

Set<String> keySet();
//Returns a set of all of the keys
void put(String key, Byte value);
//Adds a value to the set.

void put(String key, Integer value);
//Adds a value to the set.

void put(String key, Float value);
//Adds a value to the set.

void put(String key, Short value);
//Adds a value to the set.

void put(String key, byte[] value);
//Adds a value to the set.

void put(String key, String value);
//Adds a value to the set.

void put(String key, Double value);
//Adds a value to the set.

void put(String key, Long value);
//Adds a value to the set.

void put(String key, Boolean value);
//Adds a value to the set.

void putAll(ContentValues other);
//Adds all values from the passed in ContentValues.

void putNull(String key);
//Adds a null value to the set.

void remove(String key);
//Remove a single value.

int size();
//Returns the number of values.

String toString();
//Returns a string containing a concise, human-readable description of this object.

Set<Entry<String, Object>> valueSet();
//Returns a set of all of the keys and values

void writeToParcel(Parcel parcel, int flags);
//Flatten this object in to a Parcel.

}


class ContentProviderOperation {
    
ContentProviderResult apply(ContentProvider provider, ContentProviderResult[] backRefs, int numBackRefs);
//Applies this operation using the given provider.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

Uri getUri();

boolean isReadOperation();

boolean isWriteOperation();

boolean isYieldAllowed();

static ContentProviderOperation.Builder newAssertQuery(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a ContentProviderOperation to assert a set of values as provided through withValues(ContentValues);.

static ContentProviderOperation.Builder newDelete(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a delete ContentProviderOperation.

static ContentProviderOperation.Builder newInsert(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an insert ContentProviderOperation.

static ContentProviderOperation.Builder newUpdate(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an update ContentProviderOperation.

String[] resolveSelectionArgsBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The Selection Arguments back references are represented as a Map of Integer->Integer where the key is an index into the selection argument array (see withSelection(String, String[]);); and the value is the index of the previous result that should be used for that selection argument array slot.

ContentValues resolveValueBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The ContentValues back references are represented as a ContentValues object where the key refers to a column and the 
//value is an index of the back reference whose valued should be associated with the column.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.



    
    
}

class ContentProviderOperation$Builder {
    
    
ContentProviderOperation build();
//Create a ContentProviderOperation from this ContentProviderOperation.Builder.

ContentProviderOperation.Builder withExpectedCount(int count);
//If set then if the number of rows affected by this operation do not match this count OperationApplicationException will be throw.

ContentProviderOperation.Builder withSelection(String selection, String[] selectionArgs);
//The selection and arguments to use.

ContentProviderOperation.Builder withSelectionBackReference(int selectionArgIndex, int previousResult);
//Add a back references as a selection arg.

ContentProviderOperation.Builder withValue(String key, @Sink(CONTENT_PROVIDER) Object value);
//A value to insert or update.

ContentProviderOperation.Builder withValueBackReference(String key, int previousResult);
//Add a ContentValues back reference.

ContentProviderOperation.Builder withValueBackReferences(@Sink(CONTENT_PROVIDER) ContentValues backReferences);
//Add a ContentValues of back references.

ContentProviderOperation.Builder withValues(@Sink(CONTENT_PROVIDER) ContentValues values);
//The ContentValues to use.

ContentProviderOperation.Builder withYieldAllowed(boolean yieldAllowed);
//


}


class Context {
abstract boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

abstract int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

abstract int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

abstract int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

abstract int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

abstract int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

abstract int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

abstract int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

abstract void clearWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

abstract Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

abstract Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

abstract @Source(DATABASE) String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

abstract boolean deleteDatabase(@Sink(DATABASE) String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

abstract boolean deleteFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Delete the given private file associated with this Context's application package.

abstract void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

abstract void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

abstract void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

abstract void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

abstract Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

abstract ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

abstract AssetManager getAssets();
//Return an AssetManager instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE})File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

abstract ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

abstract ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getDatabasePath(@Sink(DATABASE) String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

abstract @Source({FILESYSTEM}) File getDir(@Sink({FILESYSTEM}) String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

abstract @Source({READ_EXTERNAL_STORAGE}) File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

abstract @Source({READ_EXTERNAL_STORAGE}) File getExternalFilesDir(@Sink(WRITE_EXTERNAL_STORAGE) String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getFileStreamPath(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

abstract Looper getMainLooper();
//Return the Looper for the main thread of the current process.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

abstract String getPackageCodePath();
//Return the full path to this context's primary Android package.

abstract PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

abstract @Source(LITERAL) String getPackageName();
//Return the name of this application's package.

abstract @Source(LITERAL)String getPackageResourcePath();
//Return the full path to this context's primary Android package.

abstract Resources getResources();
//Return a Resources instance for your application's package.

abstract @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(@Sink(SHARED_PREFERENCES) String name, @Sink(SHARED_PREFERENCES) int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

final @Source(LITERAL) String getString(int resId);
//Return a localized string from the application's package's default string table.

final @Source(LITERAL) String getString(int resId, @PolyFlow Object... formatArgs);
//Return a localized formatted string from the application's package's default string table, substituting the format arguments as defined in Formatter and format(String, Object...);.

abstract Object getSystemService(String name);
//Return the handle to a system-level service by name.

final @Source(LITERAL) CharSequence getText(int resId);
//Return a localized, styled CharSequence from the application's package's default string table.

abstract Resources.Theme getTheme();
//Return the Theme object associated with this Context.

abstract Drawable getWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.get(); instead.

abstract int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumHeight(); instead.

abstract int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumWidth(); instead.

abstract void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

boolean isRestricted();
//Indicates whether this Context is restricted.

final TypedArray obtainStyledAttributes(int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(int resid, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes);
//Retrieve styled attribute information in this Context's theme.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) FileInputStream openFileInput(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Open a private file associated with this Context's application package for reading.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) FileOutputStream openFileOutput(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name, int mode);
//Open a private file associated with this Context's application package for writing.

abstract @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(SQLITE_DATABASE) String name, @Sink(SQLITE_DATABASE) int mode, @Sink(SQLITE_DATABASE) SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(SQLITE_DATABASE) String name, @Sink(SQLITE_DATABASE) int mode, @Sink(SQLITE_DATABASE) SQLiteDatabase.CursorFactory factory, @Sink(SQLITE_DATABASE) DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract Drawable peekWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.peek(); instead.

void registerComponentCallbacks(ComponentCallbacks callback);
//Add a new ComponentCallbacks to the base application of the Context, which will be called at the same times as the ComponentCallbacks methods of activities and other components are called.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

abstract void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

abstract void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

abstract void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

abstract void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

abstract void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

abstract void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

abstract void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

abstract void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

abstract void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

abstract void setTheme(int resid);
//Set the base theme for this context.

abstract void setWallpaper(@Sink(SET_WALLPAPER) Bitmap bitmap);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void setWallpaper(@Sink(SET_WALLPAPER) InputStream data);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

abstract void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

abstract void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

abstract void startActivity(Intent intent, Bundle options);
//Launch a new activity.

abstract boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

abstract ComponentName startService(Intent service);
//Request that a given application service be started.

abstract boolean stopService(Intent service);
//Request that a given application service be stopped.

abstract void unbindService(ServiceConnection conn);
//Disconnect from an application service.

void unregisterComponentCallbacks(ComponentCallbacks callback);
//Remove a ComponentCallbacks objec that was previously registered with registerComponentCallbacks(ComponentCallbacks);.

abstract void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

}

class ComponentName{
            String getClassName();
      ComponentName(Context pkg, Class<?> cls);

}

class ContextWrapper {
			ApplicationInfo getApplicationInfo();
            File getDir(String name, int mode);
            ContextWrapper(Context base);
             Context createPackageContext(String packageName, int flags) throws NameNotFoundException;            
                        String getPackageName();
            ComponentName startService(Intent service);
            PackageManager getPackageManager();
            @Source(FILESYSTEM) File getFilesDir();
            AssetManager getAssets();
            Context getApplicationContext();
            Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
            Context getBaseContext();
            void sendBroadcast(Intent intent);
            @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(String name, int mode);
                        ContentResolver getContentResolver();

void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

boolean stopService(Intent name);
//Request that a given application service be stopped.

boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

//int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

//int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

//int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

//int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

//int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

//int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

//int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

//void clearWallpaper();
//This method was deprecated in API level . Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

//Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

//Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

//String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

//boolean deleteDatabase(String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

//boolean deleteFile(String name);
//Delete the given private file associated with this Context's application package.

//void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

//void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

//void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

//void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

//void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

//String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

//ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

AssetManager getAssets();
//Return an AssetManager instance for your application's package.

Context getBaseContext();

//File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

//ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

//File getDatabasePath(String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

//File getDir(String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

//File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

//File getExternalFilesDir(String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

//File getFileStreamPath(String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

//File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

//Looper getMainLooper();
//Return the Looper for the main thread of the current process.

//File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

//String getPackageCodePath();
//Return the full path to this context's primary Android package.

//PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

//String getPackageName();
//Return the name of this application's package.

//String getPackageResourcePath();
//Return the full path to this context's primary Android package.

Resources getResources();
//Return a Resources instance for your application's package.

//SharedPreferences getSharedPreferences(String name, int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//Drawable getWallpaper();
//This method was deprecated in API level . Use WallpaperManager.get(); instead.

//int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumHeight(); instead.

//int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumWidth(); instead.

//void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

//boolean isRestricted();
//Indicates whether this Context is restricted.

//FileInputStream openFileInput(String name);
//Open a private file associated with this Context's application package for reading.

//FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

//Drawable peekWallpaper();
//This method was deprecated in API level . Use WallpaperManager.peek(); instead.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

//void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

//void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

//void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

//void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

//void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

//void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

//void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void setTheme(int resid);
//Set the base theme for this context.

//void setWallpaper(Bitmap bitmap);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void setWallpaper(InputStream data);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

//void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

//void startActivity(Intent intent, Bundle options);
//Launch a new activity.

//boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

ComponentName startService(Intent service);
//Request that a given application service be started.

//boolean stopService(Intent name);
//Request that a given application service be stopped.

//void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

//Protected Methods
//void attachBaseContext(Context base);
//Set the base context for this ContextWrapper.

}


class CursorLoader {
    
//CSH: found in spreadsheet, not in API:
//registerContentObserver


void deliverResult(Cursor cursor);
//Sends the result of the load to the registered listener.

//void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

//String[] getProjection();

//String getSelection();

//String[] getSelectionArgs();

//String getSortOrder();

//Uri getUri();

Cursor loadInBackground();

void onCanceled(Cursor cursor);
//Called if the task was canceled before it was completed.

//void setProjection(String[] projection);

//void setSelection(String selection);

//void setSelectionArgs(String[] selectionArgs);

//void setSortOrder(String sortOrder);

//void setUri(Uri uri);

//Protected Methods
//void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

//void onStartLoading();
//Starts an asynchronous load of the contacts list data.

void onStopLoading();
//Must be called from the UI thread
}

class DialogInterface {
    
abstract void cancel();

abstract void dismiss();




}

class DialogInterface$OnClickListener{
        void onClick(DialogInterface arg0, int arg1);
}
class DialogInterface$OnKeyListener{
        boolean onKey(DialogInterface arg0, int arg1, KeyEvent arg2);
}

class DialogInterface$OnCancelListener{
            void onCancel(DialogInterface arg0);
}
class DialogInterface$OnMultiChoiceClickListener{
            void onClick(DialogInterface arg0, int arg1, boolean arg2);
}
class DialogInterface$OnDismissListener{
            void onDismiss(DialogInterface arg0);
}


class IntentFilter {

IntentFilter(String action);
//New IntentFilter that matches a single action with no data.

final Iterator<String> actionsIterator();
//Return an iterator over the filter's actions.

final void addAction(String action);
//Add a new Intent action to match against.

final void addCategory(String category);
//Add a new Intent category to match against.

final void addDataAuthority(String host, String port);
//Add a new Intent data authority to match against.

final void addDataPath(String path, int type);
//Add a new Intent data path to match against.

final void addDataScheme(String scheme);
//Add a new Intent data scheme to match against.

final void addDataType(String type);
//Add a new Intent data type to match against.

final Iterator<IntentFilter.AuthorityEntry> authoritiesIterator();
//Return an iterator over the filter's data authorities.

final Iterator<String> categoriesIterator();
//Return an iterator over the filter's categories.

final int countActions();
//Return the number of actions in the filter.

final int countCategories();
//Return the number of categories in the filter.

final int countDataAuthorities();
//Return the number of data authorities in the filter.

final int countDataPaths();
//Return the number of data paths in the filter.

final int countDataSchemes();
//Return the number of data schemes in the filter.

final int countDataTypes();
//Return the number of data types in the filter.

static IntentFilter create(String action, String dataType);
//Create a new IntentFilter instance with a specified action and MIME type, where you know the MIME type is correctly formatted.

final int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(Printer du, String prefix);

final String getAction(int index);
//Return an action in the filter.

final String getCategory(int index);
//Return a category in the filter.

final IntentFilter.AuthorityEntry getDataAuthority(int index);
//Return a data authority in the filter.

final PatternMatcher getDataPath(int index);
//Return a data path in the filter.

final String getDataScheme(int index);
//Return a data scheme in the filter.

final String getDataType(int index);
//Return a data type in the filter.

final int getPriority();
//Return the priority of this filter.

final boolean hasAction(String action);
//Is the given action included in the filter? Note that if the filter does not include any actions, false will always be returned.

final boolean hasCategory(String category);
//Is the given category included in the filter?

final boolean hasDataAuthority(Uri data);
//Is the given data authority included in the filter? Note that if the filter does not include any authorities, false will always be returned.

final boolean hasDataPath(String data);
//Is the given data path included in the filter? Note that if the filter does not include any paths, false will always be returned.

final boolean hasDataScheme(String scheme);
//Is the given data scheme included in the filter? Note that if the filter does not include any scheme, false will always be returned.

final boolean hasDataType(String type);
//Is the given data type included in the filter? Note that if the filter does not include any type, false will always be returned.

final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag);
//Test whether this filter matches the given intent.

final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag);
//Test whether this filter matches the given intent data.

final boolean matchAction(String action);
//Match this filter against an Intent's action.

final String matchCategories(Set<String> categories);
//Match this filter against an Intent's categories.

final int matchData(String type, String scheme, Uri data);
//Match this filter against an Intent's data (type, scheme and path);.

final int matchDataAuthority(Uri data);
//Match this intent filter against the given Intent data.

final Iterator<PatternMatcher> pathsIterator();
//Return an iterator over the filter's data paths.

void readFromXml(XmlPullParser parser);

final Iterator<String> schemesIterator();
//Return an iterator over the filter's data schemes.

final void setPriority(int priority);
//Modify priority of this filter.

final Iterator<String> typesIterator();
//Return an iterator over the filter's data types.

final void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.

void writeToXml(XmlSerializer serializer);
//Write the contents of the IntentFilter as an XML stream.

    
}


class Intent implements Parcelable, Cloneable {
//SOM, We have a special FlowPermission for INTENTS
  
    Intent();
    Intent(@Sink(INTENT) Intent arg0);
    Intent(@Sink(INTENT)  String arg0);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT)  Uri arg1);
    Intent(@Source(ANY) @Sink Context arg0, Class<?> arg1);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT) Uri arg1, @Sink(INTENT)  Context arg2,@Sink(INTENT)  Class<?> arg3);
   @Source(INTENT) static Intent createChooser(@Sink(INTENT) Intent arg0, @Sink(INTENT) CharSequence arg1);
    Object clone();
   @Source(INTENT)  Intent cloneFilter();
    static Intent makeMainActivity(@Sink(INTENT) ComponentName arg0);
    static Intent makeMainSelectorActivity(@Sink(INTENT) String arg0,@Sink(INTENT)  String arg1);
    static Intent makeRestartActivityTask(@Sink(INTENT) ComponentName arg0);
    static Intent getIntent(@Sink(INTENT) String arg0) throws URISyntaxException;
    static Intent parseUri(@Sink(INTENT) String arg0, int arg1) throws URISyntaxException;
    static Intent getIntentOld(@Sink(INTENT) String arg0) throws URISyntaxException;
    @Source(INTENT) String getAction();
     @Source(INTENT) Uri getData();
     @Source(INTENT) String getDataString();
    @Source(INTENT) String getScheme();
    @Source(INTENT) String getType();
    @Source(INTENT) String resolveType(@Sink(INTENT) Context arg0);
    @Source(INTENT) String resolveType(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) String resolveTypeIfNeeded(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) boolean hasCategory(@Sink(INTENT) String arg0);
    @Source(INTENT) Set<@Source(INTENT) String> getCategories();
    Intent getSelector();
    void setExtrasClassLoader(@Sink(INTENT) ClassLoader arg0);
    @Source(INTENT) boolean hasExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  boolean hasFileDescriptors();
    @Source(INTENT) boolean getBooleanExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    @Source(INTENT) byte getByteExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    @Source(INTENT) short getShortExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    @Source(INTENT) char getCharExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
   @Source(INTENT)  int getIntExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    @Source(INTENT) long getLongExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    @Source(INTENT) float getFloatExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    @Source(INTENT) double getDoubleExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    @Source(INTENT) String getStringExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) CharSequence getCharSequenceExtra(@Sink(INTENT) String arg0);
    <T> T getParcelableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) Parcelable[] getParcelableArrayExtra(@Sink(INTENT) String arg0);
    <T> ArrayList<T> getParcelableArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) Serializable getSerializableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) Integer> getIntegerArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) String> getStringArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) ArrayList< @Source(INTENT) CharSequence> getCharSequenceArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) boolean @Source(INTENT) [] getBooleanArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) byte @Source(INTENT) [] getByteArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) short @Source(INTENT) [] getShortArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  char @Source(INTENT) [] getCharArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) int @Source(INTENT) [] getIntArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  long @Source(INTENT) [] getLongArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  float @Source(INTENT) [] getFloatArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  double @Source(INTENT) [] getDoubleArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  String @Source(INTENT) [] getStringArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   CharSequence @Source(INTENT) [] getCharSequenceArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  Bundle getBundleExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   Bundle getExtras();
    @Source(INTENT)  int getFlags();
    @Source(INTENT)  String getPackage();
    @Source(INTENT)  ComponentName getComponent();
    @Source(INTENT)  Rect getSourceBounds();
    @Source(INTENT)  ComponentName resolveActivity(@Sink(INTENT) PackageManager arg0);
    @Source(INTENT)  ActivityInfo resolveActivityInfo(@Sink(INTENT) PackageManager arg0, int arg1);
    Intent setAction(@Sink(INTENT) String arg0);
    Intent setData(@Sink(INTENT) Uri arg0);
    Intent setType(@Sink(INTENT) String arg0);
    Intent setDataAndType(@Sink(INTENT) Uri arg0, @Sink(INTENT) String arg1);
    Intent addCategory(@Sink(INTENT) String arg0);
    void removeCategory(@Sink(INTENT) String arg0);
    void setSelector(@Sink(INTENT) Intent arg0);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  CharSequence arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable[] arg1);
    Intent putParcelableArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<? extends Parcelable> arg1);
    Intent putIntegerArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) Integer> arg1);
    Intent putStringArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) String> arg1);
    Intent putCharSequenceArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) CharSequence> arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Serializable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  char @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) CharSequence @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Bundle arg1);
    Intent putExtras(@Sink(INTENT) Intent arg0);
    Intent putExtras( @Sink(INTENT) Bundle arg0);
    Intent replaceExtras( @Sink(INTENT) Intent arg0);
    Intent replaceExtras( @Sink(INTENT) Bundle arg0);
    void removeExtra( @Sink(INTENT) String arg0);
    Intent setFlags( @Sink(INTENT) int arg0);
    Intent addFlags( @Sink(INTENT) int arg0);
    Intent setPackage( @Sink(INTENT) String arg0);
    Intent setComponent( @Sink(INTENT) ComponentName arg0);
    Intent setClassName( @Sink(INTENT) Context arg0,  @Sink(INTENT) String arg1);
    Intent setClassName( @Sink(INTENT) String arg0,  @Sink(INTENT) String arg1);
    Intent setClass( @Sink(INTENT) Context arg0,  @Sink(INTENT) Class<?> arg1);
    void setSourceBounds( @Sink(INTENT) Rect arg0);
    @Source(INTENT)  int fillIn( @Sink(INTENT) Intent arg0,  @Sink(INTENT) int arg1);
    @Source(INTENT)  boolean filterEquals( @Sink(INTENT) Intent arg0);
     @Source(INTENT) int filterHashCode();
    @Source(INTENT)  String toString();
     @Source(INTENT) String toURI();
    @Source(INTENT)  String toUri( @Sink(INTENT) int arg0);
    @Source(INTENT)  int describeContents();
    void writeToParcel( @Sink(INTENT) Parcel arg0,  @Sink(INTENT) int arg1);
    void readFromParcel( @Sink(INTENT) Parcel arg0);
    static Intent parseIntent( @Sink(INTENT) Resources arg0, @Sink(INTENT)  XmlPullParser arg1,  @Sink(INTENT) AttributeSet arg2) throws XmlPullParserException,IOException;
}

class Loader {
    
void abandon();
//Tell the Loader that it is being abandoned.

String dataToString(D data);
//For debugging, converts an instance of the Loader's data class to a string that can be printed.

void deliverResult(D data);
//Sends the result of the load to the registered listener.

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.
//CSH: filedescriptor

void forceLoad();
//Force an asynchronous load.

Context getContext();

//int getId();

boolean isAbandoned();
//Return whether this loader has been abandoned.

boolean isReset();
//Return whether this load has been reset.

boolean isStarted();
//Return whether this load has been started.

void onContentChanged();
//Called when Loader.ForceLoadContentObserver detects a change.

void registerListener(int id, OnLoadCompleteListener<D> listener);
//Registers a class that will receive callbacks when a load is complete.

void reset();
//Resets the state of the Loader.

final void startLoading();
//Starts an asynchronous load of the Loader's data.

void stopLoading();
//Stops delivery of updates until the next time startLoading(); is called.

boolean takeContentChanged();
//Take the current flag indicating whether the loader's content had changed while it was stopped.

//String toString();
//Returns a string containing a concise, human-readable description of this object.

void unregisterListener(OnLoadCompleteListener<D> listener);
//Remove a listener that was previously added with registerListener(int, Loader.OnLoadCompleteListener);.


//Protected Methods
void onAbandon();
//Subclasses implement this to take care of being abandoned.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

void onStartLoading();
//Subclasses must implement this to take care of loading their data, as per startLoading();.

void onStopLoading();
//Subclasses must implement this to take care of stopping their loader, as per stopLoading();.



}

class ServiceConnection {
    void onServiceDisconnected(ComponentName arg0);
    //Called when a connection to the Service has been lost.

    void onServiceConnected(ComponentName arg0, IBinder arg1);
    //Called when a connection to the Service has been established, with the IBinder of the communication channel to the Service.
}

class UriMatcher {
    void addURI(@PolySource @PolySink String authority, @PolySource @PolySink String path, @PolySource @PolySink int code) @PolySource @PolySink;
    @PolyFlow int match(Uri uri);
}


class SharedPreferences {
    
abstract @Source(SHARED_PREFERENCES) boolean contains(@Sink(SHARED_PREFERENCES) String key);
//Checks whether the preferences contains a preference.

abstract @Source(SHARED_PREFERENCES) SharedPreferences.Editor edit();
//Create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.

abstract @Source(SHARED_PREFERENCES) Map<String, ?> getAll();
//Retrieve all values from the preferences.

abstract @Source(SHARED_PREFERENCES) boolean getBoolean(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) boolean defValue);
//Retrieve a boolean value from the preferences.

abstract @Source(SHARED_PREFERENCES) float getFloat(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) float defValue);
//Retrieve a float value from the preferences.

abstract @Source(SHARED_PREFERENCES) int getInt(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) int defValue);
//Retrieve an int value from the preferences.

abstract @Source(SHARED_PREFERENCES) long getLong(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) long defValue);
//Retrieve a long value from the preferences.

abstract @Source(SHARED_PREFERENCES) String getString(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) String defValue);
//Retrieve a String value from the preferences.

abstract @Source(SHARED_PREFERENCES) Set<String> getStringSet(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) Set<String> defValues);
//Retrieve a set of String values from the preferences.

abstract void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Registers a callback to be invoked when a change happens to a preference.

abstract void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Unregisters a previous callback.

}

class SharedPreferences$Editor {
//CSH: I think this is the right way to annotate this.  The put* methods don't actually send the data until commit() or apply() is called, so those are the methods that should be annotated.?

abstract void apply() @Sink(SHARED_PREFERENCES);
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor clear() @Sink(SHARED_PREFERENCES);
//Mark in the editor to remove all values from the preferences.

abstract boolean commit() @Sink(SHARED_PREFERENCES);
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor putBoolean(String key, @Sink(SHARED_PREFERENCES) boolean value);
//Set a boolean value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putFloat(String key, @Sink(SHARED_PREFERENCES) float value);
//Set a float value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putInt(String key, @Sink(SHARED_PREFERENCES) int value);
//Set an int value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putLong(String key, long value);
//Set a long value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putString(String key, String value);
//Set a String value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putStringSet(String key, Set<String> values);
//Set a set of String values in the preferences editor, to be written back once commit(); is called.

abstract SharedPreferences.Editor remove(String key);
//Mark in the editor that a preference value should be removed, which will be done in the actual preferences once commit(); is called.



}

class SharedPreferences$OnSharedPreferenceChangeListener {
	void onSharedPreferenceChanged(SharedPreferences arg0, String arg1);
}

package android.content.pm;

class PackageItemInfo{
        CharSequence loadLabel(PackageManager pm);
}

class PackageManager {
    
abstract void addPackageToPreferred(String packageName);
//This method was deprecated in API level 7. This function no longer does anything; it was an old approach to managing preferred activities, which has been superceeded (and conflicts with); the modern activity-based preferences.

abstract boolean addPermission(PermissionInfo info);
//Add a new dynamic permission to the system.

abstract boolean addPermissionAsync(PermissionInfo info);
//Like addPermission(PermissionInfo); but asynchronously persists the package manager state after returning from the call, allowing it to return quicker and batch a series of adds at the expense of no guarantee the added permission will be retained if the device is rebooted before it is written.

abstract void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity);
//This method was deprecated in API level 8. This is a protected API that should not have been available to third party applications. It is the platform's responsibility for assigning preferred activities and this can not be directly modified. Add a new preferred activity mapping to the system. This will be used to automatically select the given activity component when Context.startActivity(); finds multiple matching activities and also matches the given filter.

abstract String[] canonicalToCurrentPackageNames(String[] names);
//Map from a packages canonical name to the current name in use on the device.

abstract int checkPermission(String permName, String pkgName);
//Check whether a particular package has been granted a particular permission.

abstract int checkSignatures(int uid1, int uid2);
//Like checkSignatures(String, String);, but takes UIDs of the two packages to be checked.

abstract int checkSignatures(String pkg1, String pkg2);
//Compare the signatures of two packages to determine if the same signature appears in both of them.

abstract void clearPackagePreferredActivities(String packageName);
//Remove all preferred activity mappings, previously added with addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName);, from the system whose activities are implemented in the given package name.

abstract String[] currentToCanonicalPackageNames(String[] names);
//Map from the current package names in use on the device to whatever the current canonical name of that package is.

abstract void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay);
//Allows a package listening to the package verification broadcast to extend the default timeout for a response and declare what action to perform after the timeout occurs.

abstract Drawable getActivityIcon(Intent intent);
//Retrieve the icon associated with an Intent.

abstract Drawable getActivityIcon(ComponentName activityName);
//Retrieve the icon associated with an activity.

abstract ActivityInfo getActivityInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular activity class.

abstract Drawable getActivityLogo(Intent intent);
//Retrieve the logo associated with an Intent.

abstract Drawable getActivityLogo(ComponentName activityName);
//Retrieve the logo associated with an activity.

abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);
//Retrieve all of the known permission groups in the system.

abstract int getApplicationEnabledSetting(String packageName);
//Return the the enabled setting for an application.

abstract Drawable getApplicationIcon(String packageName);
//Retrieve the icon associated with an application.

abstract Drawable getApplicationIcon(ApplicationInfo info);
//Retrieve the icon associated with an application.

abstract ApplicationInfo getApplicationInfo(String packageName, int flags);
//Retrieve all of the information we know about a particular package/application.

abstract CharSequence getApplicationLabel(ApplicationInfo info);
//Return the label to use for this application.

abstract Drawable getApplicationLogo(String packageName);
//Retrieve the logo associated with an application.

abstract Drawable getApplicationLogo(ApplicationInfo info);
//Retrieve the logo associated with an application.

abstract int getComponentEnabledSetting(ComponentName componentName);
//Return the the enabled setting for a package component (activity, receiver, service, provider);.

abstract Drawable getDefaultActivityIcon();
//Return the generic icon for an activity that is used when no specific icon is defined.

abstract Drawable getDrawable(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve an image from a package.

abstract List<ApplicationInfo> getInstalledApplications(int flags);
//Return a List of all application packages that are installed on the device.

abstract List<PackageInfo> getInstalledPackages(int flags);
//Return a List of all packages that are installed on the device.

abstract String getInstallerPackageName(String packageName);
//Retrieve the package name of the application that installed a package.

abstract InstrumentationInfo getInstrumentationInfo(ComponentName className, int flags);
//Retrieve all of the information we know about a particular instrumentation class.

abstract Intent getLaunchIntentForPackage(String packageName);
//Return a "good" intent to launch a front-door activity in a package, for use for example to implement an "open" button when browsing through packages.

abstract String getNameForUid(int uid);
//Retrieve the official name associated with a user id.

PackageInfo getPackageArchiveInfo(String archiveFilePath, int flags);
//Retrieve overall information about an application package defined in a package archive file

abstract int[] getPackageGids(String packageName);
//Return an array of all of the secondary group-ids that have been assigned to a package.

abstract PackageInfo getPackageInfo(String packageName, int flags);
//Retrieve overall information about an application package that is installed on the system.

abstract String[] getPackagesForUid(int uid);
//Retrieve the names of all packages that are associated with a particular user id.

abstract PermissionGroupInfo getPermissionGroupInfo(String name, int flags);
//Retrieve all of the information we know about a particular group of permissions.

abstract PermissionInfo getPermissionInfo(String name, int flags);
//Retrieve all of the information we know about a particular permission.

abstract int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName);
//Retrieve all preferred activities, previously added with addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName);, that are currently registered with the system.

abstract List<PackageInfo> getPreferredPackages(int flags);
//Retrieve the list of all currently configured preferred packages.

abstract ProviderInfo getProviderInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular content provider class.

abstract ActivityInfo getReceiverInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular receiver class.

abstract Resources getResourcesForActivity(ComponentName activityName);
//Retrieve the resources associated with an activity.

abstract Resources getResourcesForApplication(String appPackageName);
//Retrieve the resources associated with an application.

abstract Resources getResourcesForApplication(ApplicationInfo app);
//Retrieve the resources for an application.

abstract ServiceInfo getServiceInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular service class.

abstract FeatureInfo[] getSystemAvailableFeatures();
//Get a list of features that are available on the system.

abstract String[] getSystemSharedLibraryNames();
//Get a list of shared libraries that are available on the system.

abstract CharSequence getText(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve text from a package.

abstract XmlResourceParser getXml(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve an XML file from a package.

abstract boolean hasSystemFeature(String name);
//Check whether the given feature name is one of the available features as returned by getSystemAvailableFeatures();.

abstract boolean isSafeMode();
//Return whether the device has been booted into safe mode.

abstract List<ResolveInfo> queryBroadcastReceivers(Intent intent, int flags);
//Retrieve all receivers that can handle a broadcast of the given intent.

abstract List<ProviderInfo> queryContentProviders(String processName, int uid, int flags);
//Retrieve content provider information.

abstract List<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags);
//Retrieve information about available instrumentation code.

abstract List<ResolveInfo> queryIntentActivities(Intent intent, int flags);
//Retrieve all activities that can be performed for the given intent.

abstract List<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, Intent intent, int flags);
//Retrieve a set of activities that should be presented to the user as similar options.

abstract List<ResolveInfo> queryIntentServices(Intent intent, int flags);
//Retrieve all services that can match the given intent.

abstract List<PermissionInfo> queryPermissionsByGroup(String group, int flags);
//Query for all of the permissions associated with a particular group.

abstract void removePackageFromPreferred(String packageName);
//This method was deprecated in API level 7. This function no longer does anything; it was an old approach to managing preferred activities, which has been superceeded (and conflicts with); the modern activity-based preferences.

abstract void removePermission(String name);
//Removes a permission that was previously added with addPermission(PermissionInfo);.

abstract ResolveInfo resolveActivity(Intent intent, int flags);
//Determine the best action to perform for a given Intent.

abstract ProviderInfo resolveContentProvider(String name, int flags);
//Find a single content provider by its base path name.

abstract ResolveInfo resolveService(Intent intent, int flags);
//Determine the best service to handle for a given Intent.

abstract void setApplicationEnabledSetting(String packageName, int newState, int flags);
//Set the enabled setting for an application This setting will override any enabled state which may have been set by the application in its manifest.

abstract void setComponentEnabledSetting(ComponentName componentName, int newState, int flags);
//Set the enabled setting for a package component (activity, receiver, service, provider);.

abstract void setInstallerPackageName(String targetPackage, String installerPackageName);
//Change the installer associated with a given package.

abstract void verifyPendingInstall(int id, int verificationCode);
//Allows a package listening to the package verification broadcast to respond to the package manager.



}

class ResolveInfo {

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(@PolyFlowReceiver Printer pw, String prefix);

final int getIconResource();
//Return the icon resource identifier to use for this match.

Drawable loadIcon(PackageManager pm);
//Retrieve the current graphical icon associated with this resolution.

CharSequence loadLabel(PackageManager pm);
//Retrieve the current textual label associated with this resolution.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int parcelableFlags);
//Flatten this object in to a Parcel.

}

package android.content.res;

class AssetManager {
//CSH: maybe Filesystem permission here...
    
void close();
//Close this asset manager.

final String[] getLocales();
//Get the locales that this asset manager contains data for.

final String[] list(String path);
//Return a String array of all the assets at the given path.

final InputStream open(String fileName);
//Open an asset using ACCESS_STREAMING mode.

final InputStream open(String fileName, int accessMode);
//Open an asset using an explicit access mode, returning an InputStream to read its contents.

final AssetFileDescriptor openFd(String fileName);

final AssetFileDescriptor openNonAssetFd(String fileName);

final AssetFileDescriptor openNonAssetFd(int cookie, String fileName);

final XmlResourceParser openXmlResourceParser(String fileName);
//Retrieve a parser for a compiled XML file.

final XmlResourceParser openXmlResourceParser(int cookie, String fileName);
//Retrieve a parser for a compiled XML file.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.




}

class ColorStateList {
    
    
static ColorStateList createFromXml(Resources r, XmlPullParser parser);
//Create a ColorStateList from an XML document, given a set of Resources.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

int getColorForState(int[] stateSet, int defaultColor);
//Return the color associated with the given set of View states.

int getDefaultColor();
//Return the default color in this ColorStateList.

boolean isStateful();

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ColorStateList valueOf(int color);
//Creates or retrieves a ColorStateList that always returns a single color.

ColorStateList withAlpha(int alpha);
//Creates a new ColorStateList that has the same states and colors as this one but where each color has the specified alpha value (0-255);.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.




}

class Resources {
final void finishPreloading();
//Called by zygote when it is done preloading resources, to change back to normal Resources operation.

final void flushLayoutCache();
//Call this to remove all cached loaded layout resources from the Resources object.

XmlResourceParser getAnimation(int id);
//Return an XmlResourceParser through which you can read an animation description for the given resource ID.

final AssetManager getAssets();
//Retrieve underlying AssetManager storage for these resources.

@Source(LITERAL) boolean getBoolean(int id);
//Return a boolean associated with a particular resource ID.

@Source(LITERAL) int getColor(int id);
//Return a color integer associated with a particular resource ID.

ColorStateList getColorStateList(int id);
//Return a color state list associated with a particular resource ID.

Configuration getConfiguration();
//Return the current configuration that is in effect for this resource object.

@Source(LITERAL) float getDimension(int id);
//Retrieve a dimensional for a particular resource ID.

@Source(LITERAL) int getDimensionPixelOffset(int id);
//Retrieve a dimensional for a particular resource ID for use as an offset in raw pixels.

@Source(LITERAL) int getDimensionPixelSize(int id);
//Retrieve a dimensional for a particular resource ID for use as a size in raw pixels.

DisplayMetrics getDisplayMetrics();
//Return the current display metrics that are in effect for this resource object.

@Source(LITERAL) Drawable getDrawable(int id);
//Return a drawable object associated with a particular resource ID.

@Source(LITERAL) Drawable getDrawableForDensity(int id, int density);
//Return a drawable object associated with a particular resource ID for the given screen density in DPI.

@Source(LITERAL) float getFraction(int id, int base, int pbase);
//Retrieve a fractional unit for a particular resource ID.

@Source(LITERAL) int getIdentifier(String name, String defType, String defPackage);
//Return a resource identifier for the given resource name.

@Source(LITERAL) int[] getIntArray(int id);
//Return the int array associated with a particular resource ID.

@Source(LITERAL) int getInteger(int id);
//Return an integer associated with a particular resource ID.

XmlResourceParser getLayout(int id);
//Return an XmlResourceParser through which you can read a view layout description for the given resource ID.

@Source(LITERAL) Movie getMovie(int id);
//Return a movie object associated with the particular resource ID.

@Source(LITERAL) String getQuantityString(int id, int quantity);
//Return the string value associated with a particular resource ID for a particular numerical quantity.

@Source(LITERAL) String getQuantityString(int id, int quantity, Object... formatArgs);
//Return the string value associated with a particular resource ID for a particular numerical quantity, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

@Source(LITERAL) CharSequence getQuantityText(int id, int quantity);
//Return the character sequence associated with a particular resource ID for a particular numerical quantity.

@Source(LITERAL) String getResourceEntryName(int resid);
//Return the entry name for a given resource identifier.

@Source(LITERAL) String getResourceName(int resid);
//Return the full name for a given resource identifier.

@Source(LITERAL) String getResourcePackageName(int resid);
//Return the package name for a given resource identifier.

@Source(LITERAL) String getResourceTypeName(int resid);
//Return the type name for a given resource identifier.

@Source(LITERAL) String getString(int id);
//Return the string value associated with a particular resource ID. It will be stripped of any styled text information.

@Source(LITERAL) String getString(int id, Object... formatArgs);
//Return the string value associated with a particular resource ID, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

@Source(LITERAL) String[] getStringArray(int id);
//Return the string array associated with a particular resource ID.

static Resources getSystem();
//Return a global shared Resources object that provides access to only system resources (no application resources);, and is not configured for the current screen (can not use dimension units, does not change based on orientation, etc);.

@Source(LITERAL) CharSequence getText(int id, CharSequence def);
//Return the string value associated with a particular resource ID.

@Source(LITERAL) CharSequence getText(int id);
//Return the string value associated with a particular resource ID. The returned object will be a String if this is a plain string; it will be some other type of CharSequence if it is styled.

@Source(LITERAL) CharSequence[] getTextArray(int id);
//Return the styled text array associated with a particular resource ID.

void getValue(String name, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValue(int id, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValueForDensity(int id, int density, TypedValue outValue, boolean resolveRefs);
//Get the raw value associated with a resource with associated density.

XmlResourceParser getXml(int id);
//Return an XmlResourceParser through which you can read a generic XML resource for the given resource ID.

final Resources.Theme newTheme();
//Generate a new Theme object for this set of Resources.

TypedArray obtainAttributes(AttributeSet set, int[] attrs);
//Retrieve a set of basic attribute values from an AttributeSet, not performing styling of them using a theme and/or style resources.

TypedArray obtainTypedArray(int id);
//Return an array of heterogeneous values.

InputStream openRawResource(int id, TypedValue value);
//Open a data stream for reading a raw resource.

InputStream openRawResource(int id);
//Open a data stream for reading a raw resource.

@Source({FILESYSTEM, READ_EXTERNAL_STORAGE})AssetFileDescriptor openRawResourceFd(int id);
//Open a file descriptor for reading a raw resource.

void parseBundleExtra(String tagName, AttributeSet attrs, Bundle outBundle);
//Parse a name/value pair out of an XML tag holding that data.

void parseBundleExtras(XmlResourceParser parser, Bundle outBundle);
//Parse a series of <extra> tags from an XML file.

void updateConfiguration(Configuration config, DisplayMetrics metrics);
//Store the newly updated configuration.
}

class TypedArray {
    
boolean getBoolean(int index, boolean defValue);
//Retrieve the boolean value for the attribute at index.

int getColor(int index, int defValue);
//Retrieve the color value for the attribute at index.

ColorStateList getColorStateList(int index);
//Retrieve the ColorStateList for the attribute at index.

float getDimension(int index, float defValue);
//Retrieve a dimensional unit attribute at index.

int getDimensionPixelOffset(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as an offset in raw pixels.

int getDimensionPixelSize(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as a size in raw pixels.

Drawable getDrawable(int index);
//Retrieve the Drawable for the attribute at index.

float getFloat(int index, float defValue);
//Retrieve the float value for the attribute at index.

float getFraction(int index, int base, int pbase, float defValue);
//Retrieve a fractional unit attribute at index.

int getIndex(int at);
//Return an index in the array that has data.

int getIndexCount();
//Return the number of indices in the array that actually have data.

int getInt(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getInteger(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getLayoutDimension(int index, String name);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

int getLayoutDimension(int index, int defValue);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

String getNonResourceString(int index);
//Retrieve the string value for the attribute at index, but only if that string comes from an immediate value in an XML file.

String getPositionDescription();
//Returns a message about the parser state suitable for printing error messages.

int getResourceId(int index, int defValue);
//Retrieve the resource identifier for the attribute at index.

Resources getResources();
//Return the Resources object this array was loaded from.

String getString(int index);
//Retrieve the string value for the attribute at index.

CharSequence getText(int index);
//Retrieve the styled string value for the attribute at index.

CharSequence[] getTextArray(int index);
//Retrieve the CharSequence[] for the attribute at index.

boolean getValue(int index, TypedValue outValue);
//Retrieve the raw TypedValue for the attribute at index.

boolean hasValue(int index);
//Determines whether there is an attribute at index.

int length();
//Return the number of values in this array.

TypedValue peekValue(int index);
//Retrieve the raw TypedValue for the attribute at index and return a temporary object holding its data.

void recycle();
//Give back a previously retrieved array, for later re-use.

String toString();
//Returns a string containing a concise, human-readable description of this object.



}


package android.content.pm;
class PackageManager{
            CharSequence getApplicationLabel(ApplicationInfo arg0);
            ActivityInfo getActivityInfo(ComponentName arg0, int arg1) throws NameNotFoundException;
            Drawable getApplicationIcon(String arg0) throws NameNotFoundException;
            ApplicationInfo getApplicationInfo(String arg0, int arg1) throws NameNotFoundException;
            Drawable getActivityIcon(ComponentName arg0) throws NameNotFoundException;
            PackageInfo getPackageInfo(String arg0, int arg1) throws NameNotFoundException;
            List<ResolveInfo> queryIntentActivities(Intent arg0, int arg1);
            boolean hasSystemFeature(String arg0);
            ResolveInfo resolveActivity(Intent arg0, int arg1);
}
class Signature{
            String toCharsString();
}


