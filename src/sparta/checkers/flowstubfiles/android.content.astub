package android.content;

class AsyncTaskLoader<D> {
    
    
void cancelLoadInBackground();
//Called on the main thread to abort a load in progress.

void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET}) FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

boolean isLoadInBackgroundCanceled();
//Returns true if the current invocation of loadInBackground(); is being canceled.

abstract D loadInBackground();
//Called on a worker thread to perform the actual load and to return the result of the load operation.

void onCanceled(D data);
//Called if the task was canceled before it was completed.

void setUpdateThrottle(long delayMS);
//Set amount to throttle updates by.

//Protected Methods
boolean onCancelLoad();
//Subclasses must implement this to take care of requests to cancelLoad();.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

D onLoadInBackground();
//Calls loadInBackground();.



}
class BroadcastReceiver {
    
//CSH:  Not sure how to do this class.  It's probably ANY/ANY, since you sometimes need permissions to use this...  

BroadcastReceiver();
//New BraodcastReceiver

final void abortBroadcast();
//Sets the flag indicating that this receiver should abort the current broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void clearAbortBroadcast();
//Clears the flag indicating that this receiver should abort the current broadcast.

final boolean getAbortBroadcast();
//Returns the flag indicating whether or not this receiver should abort the current broadcast.

final boolean getDebugUnregister();
//Return the last value given to setDebugUnregister(boolean);.

final int getResultCode();
//Retrieve the current result code, as set by the previous receiver.

final String getResultData();
//Retrieve the current result data, as set by the previous receiver.

final Bundle getResultExtras(boolean makeMap);
//Retrieve the current result extra data, as set by the previous receiver.

final BroadcastReceiver.PendingResult goAsync();
//This can be called by an application in onReceive(Context, Intent); to allow it to keep the broadcast active after returning from that function.

final boolean isInitialStickyBroadcast();
//Returns true if the receiver is currently processing the initial value of a sticky broadcast -- that is, the value that was last broadcast and is currently held in the sticky cache, so this is not directly the result of a broadcast right now.

final boolean isOrderedBroadcast();
//Returns true if the receiver is currently processing an ordered broadcast.

 abstract void onReceive(Context context, Intent intent);
//This method is called when the BroadcastReceiver is receiving an Intent broadcast.

 IBinder peekService(Context myContext, Intent service);
//Provide a binder to an already-running service.

final void setDebugUnregister(boolean debug);
//Control inclusion of debugging help for mismatched calls to Context.registerReceiver();.

final void setOrderedHint(boolean isOrdered);
//For internal use, sets the hint about whether this BroadcastReceiver is running in ordered mode.

final void setResult(int code, String data, Bundle extras);
//Change all of the result data returned from this broadcasts; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultCode(int code);
//Change the current result code of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultData(String data);
//Change the current result data of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultExtras(Bundle extras);
//Change the current result extras of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.



}

class ClipboardManager extends ClipboardManager {
//ClipData objects not annotated, because the class itself is annoated
//SOM
    void setPrimaryClip(ClipData arg0);
    ClipData getPrimaryClip();
    ClipDescription getPrimaryClipDescription();
    boolean hasPrimaryClip();
    void addPrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    void removePrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    @Source(READ_CLIPBOARD) CharSequence getText();
    void setText(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    boolean hasText();
}
class ClipData implements Parcelable {
    ClipData(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) String @Sink(WRITE_CLIPBOARD) [] arg1, @Sink(WRITE_CLIPBOARD) Item arg2);
    ClipData(ClipDescription arg0, @Sink(WRITE_CLIPBOARD)  Item arg1);
    static ClipData newPlainText(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1);
    static ClipData newIntent(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1);
    static ClipData newUri(@Sink(WRITE_CLIPBOARD) ContentResolver arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    static ClipData newRawUri(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Uri arg1);
    @Source(READ_CLIPBOARD) ClipDescription getDescription();
    void addItem(@Sink(WRITE_CLIPBOARD) Item arg0);
    int getItemCount();
    @Source(READ_CLIPBOARD) Item getItemAt(@Sink(WRITE_CLIPBOARD) int arg0);
    int describeContents();
@AddsSourceData
    void writeToParcel(@Source(READ_CLIPBOARD) Parcel arg0, int arg1);
}
class ClipData$Item {
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    Item(@Sink(WRITE_CLIPBOARD) Intent arg0);
    Item(@Sink(WRITE_CLIPBOARD) Uri arg0);
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    @Source(READ_CLIPBOARD) CharSequence getText();
     @Source(READ_CLIPBOARD) Intent getIntent();
    @Source(READ_CLIPBOARD) Uri getUri();
    @Source(READ_CLIPBOARD) CharSequence coerceToText(@Sink(WRITE_CLIPBOARD) Context arg0);
}
class ClipboardManager$OnPrimaryClipChangedListener{
        void onPrimaryClipChanged();
}

class ComponentName {
ComponentName(String pkg, String cls);    
ComponentName clone();
//Creates and returns a copy of this Object.

int compareTo(ComponentName that);

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object obj);
//Compares this instance with the specified object and indicates if they are equal.

String flattenToShortString();
//The same as flattenToString();, but abbreviates the class name if it is a suffix of the package.

String flattenToString();
//Return a String that unambiguously describes both the package and class names contained in the ComponentName.

String getClassName();
//Return the class name of this component.

String getPackageName();
//Return the package name of this component.

String getShortClassName();
//Return the class name, either fully qualified or in a shortened form (with a leading '.'); if it is a suffix of the package.

int hashCode();
//Returns an integer hash code for this object.

static @Source(PARCEL) ComponentName readFromParcel(Parcel in);
//Read a ComponentName from a Parcel that was previously written with writeToParcel(ComponentName, Parcel);, returning either a null or new object as appropriate.

String toShortString();
//Return string representation of this class without the class's name as a prefix.

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ComponentName unflattenFromString(String str);
//Recover a ComponentName from a String that was previously created with flattenToString();.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

static void writeToParcel(@Sink(PARCEL) ComponentName c, Parcel out);
//Write a ComponentName to a Parcel, handling null pointers.

    
}

class ComponentCallbacks{
            void onLowMemory();
            void onConfigurationChanged(Configuration arg0);
}
class ComponentName{
            ComponentName(Context pkg, String cls);
            String getPackageName();
}

class ContentProvider {

        ContentProvider();

//CSH: content providers are tricky because they look like SQL queries, but can be implemented with anything, files, in-memory objects, databases, etc... not quite sure what to do here
    
ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations);
//Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call apply(ContentProvider, ContentProviderResult[], int); on each of them.

void attachInfo(Context context, ProviderInfo info);
//After being instantiated, this is called to tell the content provider about itself.

int bulkInsert(Uri uri, ContentValues[] values);
//Override this to handle requests to insert a set of new rows, or the default implementation will iterate over the values and call insert(Uri, ContentValues); on each of them.

Bundle call(String method, String arg, Bundle extras);
//Call a provider-defined method.

abstract int delete(Uri uri, String selection, String[] selectionArgs);
//Implement this to handle requests to delete one or more rows.

final Context getContext();
//Retrieves the Context this provider is running in.

final PathPermission[] getPathPermissions();
//Return the path-based permissions required for read and/or write access to this content provider.

final String getReadPermission();
//Return the name of the permission required for read-only access to this content provider.

String[] getStreamTypes(Uri uri, String mimeTypeFilter);
//Called by a client to determine the types of data streams that this content provider supports for the given URI.

abstract String getType(Uri uri);
//Implement this to handle requests for the MIME type of the data at the given URI.

final String getWritePermission();
//Return the name of the permission required for read/write access to this content provider.

abstract Uri insert(Uri uri, ContentValues values);
//Implement this to handle requests to insert a new row.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running. This method is always called on the application main thread, and must not perform lengthy operations.

abstract boolean onCreate();
//Implement this to initialize your content provider on startup.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt. This method is always called on the application main thread, and must not perform lengthy operations.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

AssetFileDescriptor openAssetFile(Uri uri, String mode);
//This is like openFile(Uri, String);, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk.

ParcelFileDescriptor openFile(Uri uri, String mode);
//Override this to handle requests to open a file blob.

<T> ParcelFileDescriptor openPipeHelper(Uri uri, String mimeType, Bundle opts, T args, PipeDataWriter<T> func);
//A helper function for implementing openTypedAssetFile(Uri, String, Bundle);, for creating a data pipe and background thread allowing you to stream generated data back to the client.

AssetFileDescriptor openTypedAssetFile(Uri uri, String mimeTypeFilter, Bundle opts);
//Called by a client to open a read-only stream containing data of a particular MIME type.

@PolyFlowReceiver
abstract Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Implement this to handle query requests from clients.

@PolyFlowReceiver
Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Implement this to handle query requests from clients with support for cancellation.

void shutdown();
//Implement this to shut down the ContentProvider instance.

abstract int update(@PolySink @PolySource Uri uri, @PolySink @PolySource ContentValues values, String selection, String[] selectionArgs);
//Implement this to handle requests to update one or more rows.

//Protected Methods
boolean isTemporary();
//Returns true if this instance is a temporary content provider.

final ParcelFileDescriptor openFileHelper(Uri uri, String mode);
//Convenience for subclasses that wish to implement openFile(Uri, String); by looking up a column named "_data" at the given URI.

final void setPathPermissions(PathPermission[] permissions);
//Change the path-based permission required to read and/or write data in the content provider.

final void setReadPermission(String permission);
//Change the permission required to read data from the content provider.

final void setWritePermission(String permission);
//Change the permission required to read and write data in the content provider.

}

class ContentResolver {
    
        static final String SCHEME_CONTENT;
        static final String SCHEME_FILE;

final ContentProviderClient acquireContentProviderClient(Uri uri);
//Returns a ContentProviderClient that is associated with the ContentProvider that services the content at uri, starting the provider if necessary.

final ContentProviderClient acquireContentProviderClient(String name);
//Returns a ContentProviderClient that is associated with the ContentProvider with the authority of name, starting the provider if necessary.

final ContentProviderClient acquireUnstableContentProviderClient(Uri uri);
//Like acquireContentProviderClient(Uri);, but for use when you do not trust the stability of the target content provider.

final ContentProviderClient acquireUnstableContentProviderClient(String name);
//Like acquireContentProviderClient(String);, but for use when you do not trust the stability of the target content provider.

static void addPeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras, @Sink(WRITE_SYNC_SETTINGS) long pollFrequency);
//Specifies that a sync should be requested with the specified the account, authority, and extras at the given frequency.

static Object addStatusChangeListener(int mask, SyncStatusObserver callback);
//Request notifications when the different aspects of the SyncManager change.

ContentProviderResult[] applyBatch(String authority, ArrayList<ContentProviderOperation> operations);
//Applies each of the ContentProviderOperation objects and returns an array of their results.

final int bulkInsert(Uri url, ContentValues[] values);
//Inserts multiple rows into a table at the given URL.

final Bundle call(Uri uri, String method, String arg, Bundle extras);
//Call a provider-defined method.

static void cancelSync(Account account, String authority);
//Cancel any active or pending syncs that match account and authority.

void cancelSync(Uri uri);
//This method was deprecated in API level 5. instead use cancelSync(android.accounts.Account, String);

final int delete(Uri url, String where, String[] selectionArgs);
//Deletes row(s); specified by a content URI.

static @Source(READ_SYNC_STATS) SyncInfo getCurrentSync();
//This method was deprecated in API level 11. Since multiple concurrent syncs are now supported you should use getCurrentSyncs(); to get the accurate list of current syncs. This method returns the first item from the list of current syncs or null if there are none.

static @Source(READ_SYNC_STATS) List<SyncInfo> getCurrentSyncs();
//Returns a list with information about all the active syncs.

static @Source(READ_SYNC_SETTINGS) int getIsSyncable(Account account, String authority);
//Check if this account/provider is syncable.

static  @Source(READ_SYNC_SETTINGS) boolean getMasterSyncAutomatically();
//Gets the master auto-sync setting that applies to all the providers and accounts.

static  @Source(READ_SYNC_SETTINGS) List<PeriodicSync> getPeriodicSyncs(Account account, String authority);
//Get the list of information about the periodic syncs for the given account and authority.

String[] getStreamTypes(Uri url, String mimeTypeFilter);
//Query for the possible MIME types for the representations the given content URL can be returned when opened as as stream with openTypedAssetFileDescriptor(Uri, String, Bundle);.

static SyncAdapterType[] getSyncAdapterTypes();
//Get information about the SyncAdapters that are known to the system.

static @Source(READ_SYNC_SETTINGS) boolean getSyncAutomatically(Account account, String authority);
//Check if the provider should be synced when a network tickle is received
//This method requires the caller to hold the permission READ_SYNC_SETTINGS.

final String getType(Uri url);
//Return the MIME type of the given content URL.

final Uri insert(Uri url, ContentValues values);
//Inserts a row into a table at the given URL.

static @Source(READ_SYNC_STATS) boolean isSyncActive(Account account, String authority);
//Returns true if there is currently a sync operation for the given account or authority in the pending list, or actively being processed.

static @Source(READ_SYNC_STATS) boolean isSyncPending(Account account, String authority);
//Return true if the pending status is true of any matching authorities.

void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork);
//Notify registered observers that a row was updated.

void notifyChange(Uri uri, ContentObserver observer);
//Notify registered observers that a row was updated and attempt to sync changes to the network.

final AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final ParcelFileDescriptor openFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final InputStream openInputStream(Uri uri);
//Open a stream on to the content associated with a content URI.

final OutputStream openOutputStream(Uri uri);
//Synonym for openOutputStream(uri, "w");.

final OutputStream openOutputStream(Uri uri, String mode);
//Open a stream on to the content associated with a content URI.

final AssetFileDescriptor openTypedAssetFileDescriptor(Uri uri, String mimeType, Bundle opts);
//Open a raw file descriptor to access (potentially type transformed); data from a "content:" URI.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Query the given URI, returning a Cursor over the result set.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Query the given URI, returning a Cursor over the result set.

final void registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer);
//Register an observer class that gets callbacks when data identified by a given content URI changes.

static void removePeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras);
//Remove a periodic sync.

static void removeStatusChangeListener(Object handle);
//Remove a previously registered status change listener.

static void requestSync(Account account, String authority, Bundle extras);
//Start an asynchronous sync operation.

static void setIsSyncable(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) int syncable);
//Set whether this account/provider is syncable.

static void setMasterSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Sets the master auto-sync setting that applies to all the providers and accounts.

static void setSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Set whether or not the provider is synced when it receives a network tickle.

void startSync(Uri uri, Bundle extras);
//This method was deprecated in API level 5. instead use requestSync(android.accounts.Account, String, android.os.Bundle);

final void unregisterContentObserver(ContentObserver observer);
//Unregisters a change observer.

final int update(@PolySource @PolySink Uri uri, @PolySource @PolySink ContentValues values, String where, String[] selectionArgs);
//Update row(s); in a content URI.

static void validateSyncExtrasBundle(Bundle extras);
//Check that only values of the following types are in the Bundle:
//Integer
//Long
//Boolean
//Float
//Double
//String
//Account
//null


}

class ContentUris {
    
static Uri.Builder appendId(Uri.Builder builder, long id);
//Appends the given ID to the end of the path.

static long parseId(Uri contentUri);
//Converts the last path segment to a long.

static Uri withAppendedId(Uri contentUri, long id);
//Appends the given ID to the end of the path.



}

class ContentValues implements Parcelable {
    static final String TAG;
    static final Creator<ContentValues> CREATOR;
    ContentValues();
    ContentValues(int arg0);
   @PolySource @PolySink  ContentValues(@PolySource @PolySink ContentValues arg0);
@PolyFlowReceiver
    boolean equals(Object arg0);
    int hashCode();
@PolyFlowReceiver
    void put(String arg0, String arg1);
@PolyFlowReceiver
    void putAll(ContentValues arg0);
@PolyFlowReceiver
    void put(String arg0, Byte arg1);
@PolyFlowReceiver
    void put(String arg0, Short arg1);
@PolyFlowReceiver
    void put(String arg0, Integer arg1);
@PolyFlowReceiver
    void put(String arg0, Long arg1);
@PolyFlowReceiver
    void put(String arg0, Float arg1);
@PolyFlowReceiver
    void put(String arg0, Double arg1);
@PolyFlowReceiver
    void put(String arg0, Boolean arg1);
@PolyFlowReceiver
    void put(String arg0, @PolySourceR @PolySinkR byte[] arg1);
@PolyFlowReceiver
    void putNull(String arg0);
    int size();
    void remove(String arg0);
    void clear();
@PolyFlowReceiver
    boolean containsKey(String arg0);
@PolyFlowReceiver
    Object get(String arg0);
@PolyFlowReceiver
    String getAsString(String arg0);
@PolyFlowReceiver
    Long getAsLong(String arg0);
@PolyFlowReceiver
    Integer getAsInteger(String arg0);
@PolyFlowReceiver
    Short getAsShort(String arg0);
@PolyFlowReceiver
    Byte getAsByte(String arg0);
@PolyFlowReceiver
    Double getAsDouble(String arg0);
@PolyFlowReceiver
    Float getAsFloat(String arg0);
@PolyFlowReceiver
    Boolean getAsBoolean(String arg0);
@PolyFlowReceiver
    @PolySourceR @PolySinkR byte[] getAsByteArray(String arg0);
    Set<Entry<@PolySourceR @PolySinkR String,@PolySourceR @PolySinkR Object>> valueSet(@PolySourceR @PolySinkR ContentValues this);
    Set<@PolySourceR @PolySinkR String> keySet(@PolySourceR @PolySinkR ContentValues this);
    int describeContents();
@AddsSourceData
@PolyFlowReceiver
    void writeToParcel(Parcel arg0, int arg1);
@PolyFlowReceiver
    String toString();
}



class ContentProviderOperation {
    
ContentProviderResult apply(ContentProvider provider, ContentProviderResult[] backRefs, int numBackRefs);
//Applies this operation using the given provider.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

Uri getUri();

boolean isReadOperation();

boolean isWriteOperation();

boolean isYieldAllowed();

static ContentProviderOperation.Builder newAssertQuery(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a ContentProviderOperation to assert a set of values as provided through withValues(ContentValues);.

static ContentProviderOperation.Builder newDelete(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a delete ContentProviderOperation.

static ContentProviderOperation.Builder newInsert(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an insert ContentProviderOperation.

static ContentProviderOperation.Builder newUpdate(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an update ContentProviderOperation.

String[] resolveSelectionArgsBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The Selection Arguments back references are represented as a Map of Integer->Integer where the key is an index into the selection argument array (see withSelection(String, String[]);); and the value is the index of the previous result that should be used for that selection argument array slot.

ContentValues resolveValueBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The ContentValues back references are represented as a ContentValues object where the key refers to a column and the 
//value is an index of the back reference whose valued should be associated with the column.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.



    
    
}

class ContentProviderOperation$Builder {
    
    
ContentProviderOperation build();
//Create a ContentProviderOperation from this ContentProviderOperation.Builder.

ContentProviderOperation.Builder withExpectedCount(int count);
//If set then if the number of rows affected by this operation do not match this count OperationApplicationException will be throw.

ContentProviderOperation.Builder withSelection(String selection, String[] selectionArgs);
//The selection and arguments to use.

ContentProviderOperation.Builder withSelectionBackReference(int selectionArgIndex, int previousResult);
//Add a back references as a selection arg.

ContentProviderOperation.Builder withValue(String key, @Sink(CONTENT_PROVIDER) Object value);
//A value to insert or update.

ContentProviderOperation.Builder withValueBackReference(String key, int previousResult);
//Add a ContentValues back reference.

ContentProviderOperation.Builder withValueBackReferences(@Sink(CONTENT_PROVIDER) ContentValues backReferences);
//Add a ContentValues of back references.

ContentProviderOperation.Builder withValues(@Sink(CONTENT_PROVIDER) ContentValues values);
//The ContentValues to use.

ContentProviderOperation.Builder withYieldAllowed(boolean yieldAllowed);
//


}


class Context {

        static final int MODE_PRIVATE;
        static final String LAYOUT_INFLATER_SERVICE;
        static final int BIND_AUTO_CREATE;
        static final String ALARM_SERVICE;
        static final String WINDOW_SERVICE;
        static final String ACTIVITY_SERVICE;
        static final String KEYGUARD_SERVICE;

        final String DEVICE_POLICY_SERVICE;
        final String NOTIFICATION_SERVICE;
        final String AUDIO_SERVICE;
        final String CONNECTIVITY_SERVICE;
        final String WIFI_SERVICE;
        final String VIBRATOR_SERVICE;
        final String LOCATION_SERVICE;
        final String POWER_SERVICE;
        final String TELEPHONY_SERVICE;


abstract boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

abstract int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

abstract int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

abstract int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

abstract int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

abstract int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

abstract int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

abstract int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

abstract void clearWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

abstract Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

abstract Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

abstract @Source(DATABASE) String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

abstract boolean deleteDatabase(@Sink(DATABASE) String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

abstract boolean deleteFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Delete the given private file associated with this Context's application package.

abstract void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

abstract void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

abstract void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

abstract void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

abstract Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

abstract ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

abstract AssetManager getAssets();
//Return an AssetManager instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE})File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

abstract ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

abstract ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getDatabasePath(@Sink(DATABASE) String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

abstract @Source({FILESYSTEM}) File getDir(@Sink({FILESYSTEM}) String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

abstract @Source({READ_EXTERNAL_STORAGE}) File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

abstract  File getExternalFilesDir(@Sink(WRITE_EXTERNAL_STORAGE) String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

abstract  File getFileStreamPath(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

abstract File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

abstract Looper getMainLooper();
//Return the Looper for the main thread of the current process.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

abstract String getPackageCodePath();
//Return the full path to this context's primary Android package.

abstract PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

abstract  String getPackageName();
//Return the name of this application's package.

abstract String getPackageResourcePath();
//Return the full path to this context's primary Android package.

abstract Resources getResources();
//Return a Resources instance for your application's package.

abstract @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(@Sink(SHARED_PREFERENCES) String name, @Sink(SHARED_PREFERENCES) int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

final  String getString(int resId);
//Return a localized string from the application's package's default string table.
@PolyFlow
final String getString(int resId, @PolySource @PolySink Object... formatArgs);
//Return a localized formatted string from the application's package's default string table, substituting the format arguments as defined in Formatter and format(String, Object...);.

abstract Object getSystemService(String name);
//Return the handle to a system-level service by name.

final  CharSequence getText(int resId);
//Return a localized, styled CharSequence from the application's package's default string table.

abstract Resources.Theme getTheme();
//Return the Theme object associated with this Context.

abstract Drawable getWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.get(); instead.

abstract int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumHeight(); instead.

abstract int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumWidth(); instead.

abstract void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

boolean isRestricted();
//Indicates whether this Context is restricted.

final TypedArray obtainStyledAttributes(int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(int resid, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes);
//Retrieve styled attribute information in this Context's theme.

@InferParameterizedPermission(FILESYSTEM)
abstract @Source({FILESYSTEM}) FileInputStream openFileInput( String name);
//Open a private file associated with this Context's application package for reading.

@InferParameterizedPermission(value=FILESYSTEM, isA="sink")
abstract @Sink({FILESYSTEM}) FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.

abstract @Source(DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(DATABASE) String name, @Sink(DATABASE) int mode, @Sink(DATABASE) SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract @Source(DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(DATABASE) String name, @Sink(DATABASE) int mode, @Sink(DATABASE) SQLiteDatabase.CursorFactory factory, @Sink(DATABASE) DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract Drawable peekWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.peek(); instead.

void registerComponentCallbacks(ComponentCallbacks callback);
//Add a new ComponentCallbacks to the base application of the Context, which will be called at the same times as the ComponentCallbacks methods of activities and other components are called.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

abstract void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

abstract void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

 abstract void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

 abstract void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

 abstract void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

 abstract void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

 abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

 abstract void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

 abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

 abstract void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

 abstract void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

 abstract void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

 abstract void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

abstract void setTheme(int resid);
//Set the base theme for this context.

abstract void setWallpaper(@Sink(SET_WALLPAPER) Bitmap bitmap);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void setWallpaper(@Sink(SET_WALLPAPER) InputStream data);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

abstract void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

abstract void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

abstract void startActivity(Intent intent, Bundle options);
//Launch a new activity.

abstract boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

 abstract ComponentName startService(Intent service);
//Request that a given application service be started.

abstract boolean stopService(Intent service);
//Request that a given application service be stopped.

abstract void unbindService(ServiceConnection conn);
//Disconnect from an application service.

void unregisterComponentCallbacks(ComponentCallbacks callback);
//Remove a ComponentCallbacks objec that was previously registered with registerComponentCallbacks(ComponentCallbacks);.

abstract void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

@Source(READ_EXTERNAL_STORAGE) abstract File[] getObbDirs();

@Source(READ_EXTERNAL_STORAGE)abstract File[] getExternalFilesDirs(String arg0);

@Source(READ_EXTERNAL_STORAGE)abstract File[] getExternalCacheDirs();

}

class ComponentName{
            String getClassName();
      ComponentName(Context pkg, Class<?> cls);

}

class ContextWrapper {
  void startActivity(@Sink(INTENT) Intent intent, @Sink(BUNDLE) Bundle options);
            ApplicationInfo getApplicationInfo();
            File getDir(String name, int mode);
            String getPackageCodePath();
            ContextWrapper(Context base);
             Context createPackageContext(String packageName, int flags) throws NameNotFoundException;            
                        String getPackageName();
             ComponentName startService(Intent service);
            PackageManager getPackageManager();
            File getFilesDir();
            AssetManager getAssets();
            Context getApplicationContext();
            Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
            Context getBaseContext();
             void sendBroadcast(Intent intent);
            @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(String name, int mode);
                        ContentResolver getContentResolver();

void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

boolean stopService(Intent name);
//Request that a given application service be stopped.

boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

//int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

//int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

//int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

//int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

//int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

//int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

//int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

//void clearWallpaper();
//This method was deprecated in API level . Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

//Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

//Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

//String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

//boolean deleteDatabase(String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

@Source(FILESYSTEM) boolean deleteFile(@Sink(FILESYSTEM) String name);
//Delete the given private file associated with this Context's application package.

//void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

//void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

//void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

//void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

//void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

 @Source(FILESYSTEM) String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

//ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

AssetManager getAssets();
//Return an AssetManager instance for your application's package.

Context getBaseContext();

//File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

//ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

//File getDatabasePath(String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

//File getDir(String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

//File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

@Source(WRITE_EXTERNAL_STORAGE) File getExternalFilesDir(String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

//File getFileStreamPath(String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

//File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

//Looper getMainLooper();
//Return the Looper for the main thread of the current process.

//File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

//String getPackageCodePath();
//Return the full path to this context's primary Android package.

//PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

//String getPackageName();
//Return the name of this application's package.

//String getPackageResourcePath();
//Return the full path to this context's primary Android package.

Resources getResources();
//Return a Resources instance for your application's package.

//SharedPreferences getSharedPreferences(String name, int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//Drawable getWallpaper();
//This method was deprecated in API level . Use WallpaperManager.get(); instead.

//int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumHeight(); instead.

//int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumWidth(); instead.

//void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

//boolean isRestricted();
//Indicates whether this Context is restricted.

@InferParameterizedPermission(FILESYSTEM)
@Source(FILESYSTEM) FileInputStream openFileInput(String name);
//Open a private file associated with this Context's application package for reading.

@Sink(FILESYSTEM) FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

//Drawable peekWallpaper();
//This method was deprecated in API level . Use WallpaperManager.peek(); instead.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

//void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

//void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

 void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

//void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

//void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

//void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

//void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

//void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void setTheme(int resid);
//Set the base theme for this context.

//void setWallpaper(Bitmap bitmap);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void setWallpaper(InputStream data);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

//void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

//void startActivity(Intent intent, Bundle options);
//Launch a new activity.

//boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

 ComponentName startService(Intent service);
//Request that a given application service be started.

//boolean stopService(Intent name);
//Request that a given application service be stopped.

//void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

//Protected Methods
//void attachBaseContext(Context base);
//Set the base context for this ContextWrapper.

}


class CursorLoader {
    
//CSH: found in spreadsheet, not in API:
//registerContentObserver


void deliverResult(Cursor cursor);
//Sends the result of the load to the registered listener.

//void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

//String[] getProjection();

//String getSelection();

//String[] getSelectionArgs();

//String getSortOrder();

//Uri getUri();

Cursor loadInBackground();

void onCanceled(Cursor cursor);
//Called if the task was canceled before it was completed.

//void setProjection(String[] projection);

//void setSelection(String selection);

//void setSelectionArgs(String[] selectionArgs);

//void setSortOrder(String sortOrder);

//void setUri(Uri uri);

//Protected Methods
//void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

//void onStartLoading();
//Starts an asynchronous load of the contacts list data.

void onStopLoading();
//Must be called from the UI thread
}

class DialogInterface {
static final int BUTTON_NEGATIVE;
static final int BUTTON_POSITIVE;
static final int BUTTON1;
static final int BUTTON2;
abstract void cancel();
abstract void dismiss();
}

class DialogInterface$OnClickListener{
        void onClick(DialogInterface arg0, int arg1);
}
class DialogInterface$OnKeyListener{
        boolean onKey(DialogInterface arg0, int arg1, KeyEvent arg2);
}

class DialogInterface$OnCancelListener{
            void onCancel(DialogInterface arg0);
}
class DialogInterface$OnMultiChoiceClickListener{
            void onClick(DialogInterface arg0, int arg1, boolean arg2);
}
class DialogInterface$OnDismissListener{
            void onDismiss(DialogInterface arg0);
}


class IntentFilter {
IntentFilter();

IntentFilter(@Sink(ANY) String action);
//New IntentFilter that matches a single action with no data.

final Iterator<String> actionsIterator();
//Return an iterator over the filter's actions.

final void addAction(@Sink(INTENT) String action);
//Add a new Intent action to match against.

final void addCategory(@Sink(INTENT) String category);
//Add a new Intent category to match against.

final void addDataAuthority(String host, String port);
//Add a new Intent data authority to match against.

final void addDataPath(String path, int type);
//Add a new Intent data path to match against.

final void addDataScheme(String scheme);
//Add a new Intent data scheme to match against.

final void addDataType(String type);
//Add a new Intent data type to match against.

final Iterator<IntentFilter.AuthorityEntry> authoritiesIterator();
//Return an iterator over the filter's data authorities.

final Iterator<String> categoriesIterator();
//Return an iterator over the filter's categories.

final int countActions();
//Return the number of actions in the filter.

final int countCategories();
//Return the number of categories in the filter.

final int countDataAuthorities();
//Return the number of data authorities in the filter.

final int countDataPaths();
//Return the number of data paths in the filter.

final int countDataSchemes();
//Return the number of data schemes in the filter.

final int countDataTypes();
//Return the number of data types in the filter.

static IntentFilter create(String action, String dataType);
//Create a new IntentFilter instance with a specified action and MIME type, where you know the MIME type is correctly formatted.

final int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(Printer du, String prefix);

final @Source(INTENT) String getAction(int index);
//Return an action in the filter.

final String getCategory(int index);
//Return a category in the filter.

final IntentFilter.AuthorityEntry getDataAuthority(int index);
//Return a data authority in the filter.

final PatternMatcher getDataPath(int index);
//Return a data path in the filter.

final String getDataScheme(int index);
//Return a data scheme in the filter.

final String getDataType(int index);
//Return a data type in the filter.

final int getPriority();
//Return the priority of this filter.

final boolean hasAction(String action);
//Is the given action included in the filter? Note that if the filter does not include any actions, false will always be returned.

final boolean hasCategory(String category);
//Is the given category included in the filter?

final boolean hasDataAuthority(Uri data);
//Is the given data authority included in the filter? Note that if the filter does not include any authorities, false will always be returned.

final boolean hasDataPath(String data);
//Is the given data path included in the filter? Note that if the filter does not include any paths, false will always be returned.

final boolean hasDataScheme(String scheme);
//Is the given data scheme included in the filter? Note that if the filter does not include any scheme, false will always be returned.

final boolean hasDataType(String type);
//Is the given data type included in the filter? Note that if the filter does not include any type, false will always be returned.

final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag);
//Test whether this filter matches the given intent.

final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag);
//Test whether this filter matches the given intent data.

final boolean matchAction(String action);
//Match this filter against an Intent's action.

final String matchCategories(Set<String> categories);
//Match this filter against an Intent's categories.

final int matchData(String type, String scheme, Uri data);
//Match this filter against an Intent's data (type, scheme and path);.

final int matchDataAuthority(Uri data);
//Match this intent filter against the given Intent data.

final Iterator<PatternMatcher> pathsIterator();
//Return an iterator over the filter's data paths.

void readFromXml(XmlPullParser parser);

final Iterator<String> schemesIterator();
//Return an iterator over the filter's data schemes.

final void setPriority(int priority);
//Modify priority of this filter.

final Iterator<String> typesIterator();
//Return an iterator over the filter's data types.

final void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.

void writeToXml(XmlSerializer serializer);
//Write the contents of the IntentFilter as an XML stream.

    
}


class Intent implements Parcelable, Cloneable {
//SOM, We have a special FlowPermission for INTENT
        static final String EXTRA_SUBJECT;
        static final  String EXTRA_TEXT;
        static final  String ACTION_SEARCH;
        static final String ACTION_SEND;
        static final String ACTION_SENDTO;
        static final String ACTION_SET_WALLPAPER;
        static final String EXTRA_SHORTCUT_ICON_RESOURCE;
        static final String ACTION_USER_PRESENT;
        static final String EXTRA_SHORTCUT_NAME;
        static final String ACTION_GET_CONTENT;
        static final String ACTION_MEDIA_MOUNTED;
        static final String ACTION_MEDIA_SCANNER_FINISHED;
        static final String ACTION_PACKAGE_ADDED;
        static final String ACTION_MAIN;
        static final String CATEGORY_OPENABLE;
        final  int FLAG_ACTIVITY_NEW_TASK;
        final  String ACTION_HEADSET_PLUG;
        final  String ACTION_BATTERY_OKAY;
        final  int FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;
        final  String ACTION_VIEW;
        final  int FLAG_ACTIVITY_NO_USER_ACTION;
        final  String ACTION_BATTERY_LOW;
        final  String ACTION_BOOT_COMPLETED;
        final  int FLAG_FROM_BACKGROUND;
        final  String ACTION_CALL;
        final  String ACTION_BATTERY_CHANGED;

String EXTRA_PHONE_NUMBER; 
 static final  String EXTRA_SHORTCUT_INTENT;
    Intent();
    @PolyFlow
    Intent(Intent arg0);
    Intent(@Sink(ANY) String arg0);
    Intent(@Sink(ANY) String arg0, @Sink(ANY)  Uri arg1);
    Intent(Context arg0, Class<?> arg1);
    Intent(@Sink(ANY) String arg0, @Sink(ANY) Uri arg1, @Sink(ANY)  Context arg2,@Sink(ANY)  Class<?> arg3);
    static Intent createChooser(Intent arg0, @Sink(INTENT) CharSequence arg1);
    Object clone();
   @Source(INTENT)  Intent cloneFilter();
    static Intent makeMainActivity(@Sink(INTENT) ComponentName arg0);
    static Intent makeMainSelectorActivity(String arg0, String arg1);
    static Intent makeRestartActivityTask(ComponentName arg0);
     static Intent getIntent(@Sink(INTENT) String arg0) throws URISyntaxException;
    static Intent parseUri(@Sink(INTENT) String arg0, int arg1) throws URISyntaxException;
     static Intent getIntentOld(@Sink(INTENT) String arg0) throws URISyntaxException;
    @Source(INTENT) String getAction();
     @Source(INTENT) Uri getData();
     @Source(INTENT) String getDataString();
    @Source(INTENT) String getScheme();
    @Source(INTENT) String getType();
    String resolveType(Context arg0);
     String resolveType(ContentResolver arg0);
     String resolveTypeIfNeeded(ContentResolver arg0);
     boolean hasCategory(String arg0);
    Set<String> getCategories();
    Intent getSelector();
    void setExtrasClassLoader(@Sink(INTENT) ClassLoader arg0);
    @Source(INTENT) boolean hasExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  boolean hasFileDescriptors();
   @Source(INTENT) boolean getBooleanExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
   @Source(INTENT) byte getByteExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
   @Source(INTENT) short getShortExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
   @Source(INTENT) char getCharExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
   @Source(INTENT)  int getIntExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
   @Source(INTENT) long getLongExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
   @Source(INTENT) float getFloatExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
   @Source(INTENT) double getDoubleExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
   @Source(INTENT) String getStringExtra(@Sink(INTENT) String arg0);
   @Source(INTENT) CharSequence getCharSequenceExtra(@Sink(INTENT) String arg0);
   <T extends @Source(INTENT) Object> @Source(INTENT) T getParcelableExtra(@Sink(INTENT) String arg0);
   @Source(INTENT) Parcelable[] getParcelableArrayExtra(@Sink(INTENT) String arg0);
    <T> ArrayList<T> getParcelableArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) Serializable getSerializableExtra(@Sink(INTENT) String arg0);
   @Source(INTENT) ArrayList< @Source(INTENT) Integer> getIntegerArrayListExtra(@Sink(INTENT) String arg0);
   @Source(INTENT) ArrayList< @Source(INTENT) String> getStringArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) CharSequence> getCharSequenceArrayListExtra(@Sink(INTENT) String arg0);
   @Source(INTENT) boolean @Source(INTENT) [] getBooleanArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) byte @Source(INTENT) [] getByteArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) short @Source(INTENT) [] getShortArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  char @Source(INTENT) [] getCharArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) int @Source(INTENT) [] getIntArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  long @Source(INTENT) [] getLongArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  float @Source(INTENT) [] getFloatArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  double @Source(INTENT) [] getDoubleArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  String @Source(INTENT) [] getStringArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   CharSequence @Source(INTENT) [] getCharSequenceArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  Bundle getBundleExtra(@Sink(INTENT) String arg0);
   @PolyFlow  Bundle getExtras();
    @Source(INTENT)  int getFlags();
    @Source(INTENT)  String getPackage();
    @Source(INTENT)  ComponentName getComponent();
    @Source(INTENT)  Rect getSourceBounds();
    @Source(INTENT)  ComponentName resolveActivity(@Sink(INTENT) PackageManager arg0);
    @Source(INTENT)  ActivityInfo resolveActivityInfo(@Sink(INTENT) PackageManager arg0, int arg1);
    @SetIntentFilter Intent setAction(@Sink(INTENT) String arg0);
    @SetIntentFilter Intent setData(@Sink(INTENT) Uri arg0);
    @SetIntentFilter Intent setType(@Sink(INTENT) String arg0);
    @SetIntentFilter Intent setDataAndType(@Sink(INTENT) Uri arg0, @Sink(INTENT) String arg1);
    @SetIntentFilter Intent addCategory(@Sink(INTENT) String arg0);
    @SetIntentFilter void removeCategory(@Sink(INTENT) String arg0);
    void setSelector(@Sink(INTENT) Intent arg0);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  CharSequence arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable @Sink(INTENT) [] arg1);
    Intent putParcelableArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) ? extends Parcelable> arg1);
    Intent putIntegerArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) Integer> arg1);
    Intent putStringArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) String> arg1);
     Intent putCharSequenceArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) CharSequence> arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Serializable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  char @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) CharSequence @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Bundle arg1);
    Intent putExtras(@Sink(INTENT) Intent arg0);
    Intent putExtras( @Sink(INTENT) Bundle arg0);
    Intent replaceExtras( @Sink(INTENT) Intent arg0);
    Intent replaceExtras( @Sink(INTENT) Bundle arg0);
    void removeExtra( @Sink(INTENT) String arg0);
    @SetIntentFilter Intent setFlags( @Sink(INTENT) int arg0);
    @SetIntentFilter Intent addFlags( @Sink(INTENT) int arg0);
    @SetIntentFilter Intent setPackage( @Sink(INTENT) String arg0);
    @SetIntentFilter Intent setComponent( @Sink(INTENT) ComponentName arg0);
    @SetIntentFilter Intent setClassName( @Sink(INTENT) Context arg0,  @Sink(INTENT) String arg1);
    @SetIntentFilter Intent setClassName( @Sink(INTENT) String arg0,  @Sink(INTENT) String arg1);
    @SetIntentFilter Intent setClass( @Sink(INTENT) Context arg0,  @Sink(INTENT) Class<?> arg1);
    void setSourceBounds( @Sink(INTENT) Rect arg0);
    @Source(INTENT)  int fillIn( @Sink(INTENT) Intent arg0,  @Sink(INTENT) int arg1);
    @Source(INTENT)  boolean filterEquals( @Sink(INTENT) Intent arg0);
     @Source(INTENT) int filterHashCode();
    @Source(INTENT)  String toString();
     @Source(INTENT) String toURI();
    @Source(INTENT)  String toUri( @Sink(INTENT) int arg0);
    @Source(INTENT)  int describeContents();
    void writeToParcel( @Sink(INTENT) Parcel arg0,  @Sink(INTENT) int arg1);
    void readFromParcel( @Sink(INTENT) Parcel arg0);
    static Intent parseIntent( @Sink(INTENT) Resources arg0, @Sink(INTENT)  XmlPullParser arg1,  @Sink(INTENT) AttributeSet arg2) throws XmlPullParserException,IOException;
      @Source(INTENT)  ClipData getClipData();
        void setClipData(@Sink(INTENT) ClipData clip);
}

class Intent$ShortcutIconResource{
        static ShortcutIconResource fromContext(Context context, int resourceId);
}

class Loader<D> {

int getId();
    
void abandon();
//Tell the Loader that it is being abandoned.

String dataToString(D data);
//For debugging, converts an instance of the Loader's data class to a string that can be printed.

void deliverResult(D data);
//Sends the result of the load to the registered listener.

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.
//CSH: filedescriptor

void forceLoad();
//Force an asynchronous load.

Context getContext();

//int getId();

boolean isAbandoned();
//Return whether this loader has been abandoned.

boolean isReset();
//Return whether this load has been reset.

boolean isStarted();
//Return whether this load has been started.

void onContentChanged();
//Called when Loader.ForceLoadContentObserver detects a change.

void registerListener(int id, OnLoadCompleteListener<D> listener);
//Registers a class that will receive callbacks when a load is complete.

void reset();
//Resets the state of the Loader.

final void startLoading();
//Starts an asynchronous load of the Loader's data.

void stopLoading();
//Stops delivery of updates until the next time startLoading(); is called.

boolean takeContentChanged();
//Take the current flag indicating whether the loader's content had changed while it was stopped.

//String toString();
//Returns a string containing a concise, human-readable description of this object.

void unregisterListener(OnLoadCompleteListener<D> listener);
//Remove a listener that was previously added with registerListener(int, Loader.OnLoadCompleteListener);.


//Protected Methods
void onAbandon();
//Subclasses implement this to take care of being abandoned.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

void onStartLoading();
//Subclasses must implement this to take care of loading their data, as per startLoading();.

void onStopLoading();
//Subclasses must implement this to take care of stopping their loader, as per stopLoading();.



}

class ServiceConnection {
    void onServiceDisconnected(ComponentName arg0);
    //Called when a connection to the Service has been lost.

    void onServiceConnected(ComponentName arg0, IBinder arg1);
    //Called when a connection to the Service has been established, with the IBinder of the communication channel to the Service.
}

class UriMatcher {
        UriMatcher(int code);
    void addURI(@PolySource @PolySink UriMatcher this, @PolySource @PolySink String authority, @PolySource @PolySink String path, @PolySource @PolySink int code);
    @PolyFlow int match(Uri uri);
}


class SharedPreferences {
    
abstract @Source(SHARED_PREFERENCES) boolean contains(@Sink(SHARED_PREFERENCES) String key);
//Checks whether the preferences contains a preference.

abstract @Source(SHARED_PREFERENCES) SharedPreferences.Editor edit();
//Create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.

abstract @Source(SHARED_PREFERENCES) Map<@Source(SHARED_PREFERENCES) String, @Source(SHARED_PREFERENCES) ?> getAll();
//Retrieve all values from the preferences.

abstract @Source(SHARED_PREFERENCES) boolean getBoolean(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) boolean defValue);
//Retrieve a boolean value from the preferences.

abstract @Source(SHARED_PREFERENCES) float getFloat(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) float defValue);
//Retrieve a float value from the preferences.

abstract @Source(SHARED_PREFERENCES) int getInt(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) int defValue);
//Retrieve an int value from the preferences.

abstract @Source(SHARED_PREFERENCES) long getLong(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) long defValue);
//Retrieve a long value from the preferences.

abstract @Source(SHARED_PREFERENCES) String getString(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) String defValue);
//Retrieve a String value from the preferences.

abstract @Source(SHARED_PREFERENCES) Set<String> getStringSet(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) Set<String> defValues);
//Retrieve a set of String values from the preferences.

abstract void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Registers a callback to be invoked when a change happens to a preference.

abstract void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Unregisters a previous callback.

}

class SharedPreferences$Editor {
//CSH: I think this is the right way to annotate this.  The put* methods don't actually send the data until commit() or apply() is called, so those are the methods that should be annotated.?

abstract void apply();
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor clear() ;
//Mark in the editor to remove all values from the preferences.

abstract boolean commit();
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor putBoolean(@Sink(SHARED_PREFERENCES)String key, @Sink(SHARED_PREFERENCES) boolean value);
//Set a boolean value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putFloat(@Sink(SHARED_PREFERENCES)String key, @Sink(SHARED_PREFERENCES) float value);
//Set a float value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putInt(@Sink(SHARED_PREFERENCES)String key, @Sink(SHARED_PREFERENCES) int value);
//Set an int value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putLong(@Sink(SHARED_PREFERENCES)String key, @Sink(SHARED_PREFERENCES)long value);
//Set a long value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putString(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) String value);
//Set a String value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putStringSet(@Sink(SHARED_PREFERENCES)String key, Set<@Sink(SHARED_PREFERENCES)String> values);
//Set a set of String values in the preferences editor, to be written back once commit(); is called.

abstract SharedPreferences.Editor remove(@Sink(SHARED_PREFERENCES)String key);
//Mark in the editor that a preference value should be removed, which will be done in the actual preferences once commit(); is called.



}

class SharedPreferences$OnSharedPreferenceChangeListener {
    void onSharedPreferenceChanged(SharedPreferences arg0, @Source() @Sink(ANY) String arg1);
}

package android.content.pm;

class ApplicationInfo{
        final int FLAG_SYSTEM;
        int flags;
        String sourceDir;
}

class ComponentInfo {
CharSequence loadLabel(PackageManager pm);
}

class PackageItemInfo{
        @Source(PACKAGE_INFO) String packageName;
        @Source(PACKAGE_INFO) String name;
        CharSequence loadLabel(PackageManager pm);
        XmlResourceParser loadXmlMetaData(PackageManager pm, String name);
}

class PackageInfo implements Parcelable {
    @Source(PACKAGE_INFO) String packageName;
    @Source(PACKAGE_INFO) int versionCode;
    @Source(PACKAGE_INFO) String versionName;
    @Source(PACKAGE_INFO) String sharedUserId;
    @Source(PACKAGE_INFO) int sharedUserLabel;
    @Source(PACKAGE_INFO) ApplicationInfo applicationInfo;
    @Source(PACKAGE_INFO) long firstInstallTime;
    @Source(PACKAGE_INFO) long lastUpdateTime;
    @Source(PACKAGE_INFO) int[] gids;
    @Source(PACKAGE_INFO) ActivityInfo[] activities;
    @Source(PACKAGE_INFO) ActivityInfo[] receivers;
    @Source(PACKAGE_INFO) ServiceInfo[] services;
    @Source(PACKAGE_INFO) ProviderInfo[] providers;
    @Source(PACKAGE_INFO) InstrumentationInfo[] instrumentation;
    @Source(PACKAGE_INFO) PermissionInfo[] permissions;
    @Source(PACKAGE_INFO) String[] requestedPermissions;
    @Source(PACKAGE_INFO) int[] requestedPermissionsFlags;
    static final int REQUESTED_PERMISSION_REQUIRED;
    static final int REQUESTED_PERMISSION_GRANTED;
    @Source(PACKAGE_INFO) Signature[] signatures;
    @Source(PACKAGE_INFO) ConfigurationInfo[] configPreferences;
    @Source(PACKAGE_INFO) FeatureInfo[] reqFeatures;
    static final Creator<PackageInfo> CREATOR;
    PackageInfo();
    @Source(PACKAGE_INFO) String toString();
    int describeContents();
@AddsSourceData
    void writeToParcel(@Source(PACKAGE_INFO) Parcel arg0, int arg1);
}

class PackageManager{
        static final int GET_META_DATA;
        boolean hasSystemFeature(String arg0);
        Intent getLaunchIntentForPackage(@Source(PACKAGE_INFO) String arg0);
        CharSequence getApplicationLabel(ApplicationInfo arg0);
        static final int DONT_KILL_APP;
        int getComponentEnabledSetting(ComponentName arg0);
        void setComponentEnabledSetting(ComponentName arg0, int arg1, int arg2);
        static final int COMPONENT_ENABLED_STATE_DISABLED;
        static final int COMPONENT_ENABLED_STATE_DEFAULT;
        static final int COMPONENT_ENABLED_STATE_ENABLED;
        static final int GET_GIDS;
        static final int GET_PERMISSIONS;
        @Source(PACKAGE_INFO) String[] getPackagesForUid(int arg0);
        List<PackageInfo> getInstalledPackages(int arg0);
        @Source(PACKAGE_INFO) PackageInfo getPackageInfo(String arg0, int arg1) throws NameNotFoundException;
        List<@Source(PACKAGE_INFO) ResolveInfo> queryIntentActivityOptions(ComponentName arg0, Intent[] arg1, Intent arg2, int arg3);
        List<@Source(PACKAGE_INFO) ResolveInfo> queryIntentActivities(Intent arg0, int flags);
        @Source(PACKAGE_INFO) ResolveInfo resolveActivity(Intent arg0, int arg1);
}

class ResolveInfo {
@Source(PACKAGE_INFO) ActivityInfo activityInfo;

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(Printer pw, String prefix);

final int getIconResource();
//Return the icon resource identifier to use for this match.

Drawable loadIcon(PackageManager pm);
//Retrieve the current graphical icon associated with this resolution.

CharSequence loadLabel(PackageManager pm);
//Retrieve the current textual label associated with this resolution.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int parcelableFlags);
//Flatten this object in to a Parcel.

}

package android.content.res;
class AssetFileDescriptor{
  @Source(FILESYSTEM) FileInputStream createInputStream() throws IOException;
}
class AssetManager {
//CSH: maybe Filesystem permission here...
static final int ACCESS_BUFFER;

void close();
//Close this asset manager.

final String[] getLocales();
//Get the locales that this asset manager contains data for.

final String[] list(String path);
//Return a String array of all the assets at the given path.

final InputStream open(String fileName);
//Open an asset using ACCESS_STREAMING mode.

final InputStream open(String fileName, int accessMode);
//Open an asset using an explicit access mode, returning an InputStream to read its contents.

final AssetFileDescriptor openFd(String fileName);

final AssetFileDescriptor openNonAssetFd(String fileName);

final AssetFileDescriptor openNonAssetFd(int cookie, String fileName);

final XmlResourceParser openXmlResourceParser(String fileName);
//Retrieve a parser for a compiled XML file.

final XmlResourceParser openXmlResourceParser(int cookie, String fileName);
//Retrieve a parser for a compiled XML file.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.
}

class ColorStateList {
    
    
static ColorStateList createFromXml(Resources r, XmlPullParser parser);
//Create a ColorStateList from an XML document, given a set of Resources.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

int getColorForState(int[] stateSet, int defaultColor);
//Return the color associated with the given set of View states.

int getDefaultColor();
//Return the default color in this ColorStateList.

boolean isStateful();

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ColorStateList valueOf(int color);
//Creates or retrieves a ColorStateList that always returns a single color.

ColorStateList withAlpha(int alpha);
//Creates a new ColorStateList that has the same states and colors as this one but where each color has the specified alpha value (0-255);.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.




}

class Configuration{
        static final int ORIENTATION_PORTRAIT;
        int orientation;
        int screenLayout;
        static final int SCREENLAYOUT_SIZE_LARGE;
        static final int SCREENLAYOUT_SIZE_MASK;
}

class Resources$Theme {
boolean resolveAttribute(int resid, TypedValue outValue, boolean resolveRefs);
}

class Resources {
final void finishPreloading();
//Called by zygote when it is done preloading resources, to change back to normal Resources operation.

final void flushLayoutCache();
//Call this to remove all cached loaded layout resources from the Resources object.

XmlResourceParser getAnimation(int id);
//Return an XmlResourceParser through which you can read an animation description for the given resource ID.

final AssetManager getAssets();
//Retrieve underlying AssetManager storage for these resources.

 boolean getBoolean(int id);
//Return a boolean associated with a particular resource ID.

 int getColor(int id);
//Return a color integer associated with a particular resource ID.

ColorStateList getColorStateList(int id);
//Return a color state list associated with a particular resource ID.

Configuration getConfiguration();
//Return the current configuration that is in effect for this resource object.

 float getDimension(int id);
//Retrieve a dimensional for a particular resource ID.

 int getDimensionPixelOffset(int id);
//Retrieve a dimensional for a particular resource ID for use as an offset in raw pixels.

 int getDimensionPixelSize(int id);
//Retrieve a dimensional for a particular resource ID for use as a size in raw pixels.

DisplayMetrics getDisplayMetrics();
//Return the current display metrics that are in effect for this resource object.

 Drawable getDrawable(int id);
//Return a drawable object associated with a particular resource ID.

 Drawable getDrawableForDensity(int id, int density);
//Return a drawable object associated with a particular resource ID for the given screen density in DPI.

 float getFraction(int id, int base, int pbase);
//Retrieve a fractional unit for a particular resource ID.

 int getIdentifier(String name, String defType, String defPackage);
//Return a resource identifier for the given resource name.

 int[] getIntArray(int id);
//Return the int array associated with a particular resource ID.

 int getInteger(int id);
//Return an integer associated with a particular resource ID.

XmlResourceParser getLayout(int id);
//Return an XmlResourceParser through which you can read a view layout description for the given resource ID.

 Movie getMovie(int id);
//Return a movie object associated with the particular resource ID.

 String getQuantityString(int id, int quantity);
//Return the string value associated with a particular resource ID for a particular numerical quantity.

@PolyFlow
String getQuantityString(int id, int quantity, @PolySource @PolySink Object... formatArgs);
//Return the string value associated with a particular resource ID for a particular numerical quantity, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

 CharSequence getQuantityText(int id, int quantity);
//Return the character sequence associated with a particular resource ID for a particular numerical quantity.

 String getResourceEntryName(int resid);
//Return the entry name for a given resource identifier.

 String getResourceName(int resid);
//Return the full name for a given resource identifier.

 String getResourcePackageName(int resid);
//Return the package name for a given resource identifier.

 String getResourceTypeName(int resid);
//Return the type name for a given resource identifier.

 String getString(int id);
//Return the string value associated with a particular resource ID. It will be stripped of any styled text information.

@PolyFlow
final String getString(int resId, @PolySource @PolySink Object... formatArgs);
//Return the string value associated with a particular resource ID, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

 String[] getStringArray(int id);
//Return the string array associated with a particular resource ID.

static Resources getSystem();
//Return a global shared Resources object that provides access to only system resources (no application resources);, and is not configured for the current screen (can not use dimension units, does not change based on orientation, etc);.

 CharSequence getText(int id, CharSequence def);
//Return the string value associated with a particular resource ID.

 CharSequence getText(int id);
//Return the string value associated with a particular resource ID. The returned object will be a String if this is a plain string; it will be some other type of CharSequence if it is styled.

 CharSequence[] getTextArray(int id);
//Return the styled text array associated with a particular resource ID.

void getValue(String name, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValue(int id, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValueForDensity(int id, int density, TypedValue outValue, boolean resolveRefs);
//Get the raw value associated with a resource with associated density.

XmlResourceParser getXml(int id);
//Return an XmlResourceParser through which you can read a generic XML resource for the given resource ID.

final Resources.Theme newTheme();
//Generate a new Theme object for this set of Resources.

TypedArray obtainAttributes(AttributeSet set, int[] attrs);
//Retrieve a set of basic attribute values from an AttributeSet, not performing styling of them using a theme and/or style resources.

TypedArray obtainTypedArray(int id);
//Return an array of heterogeneous values.

InputStream openRawResource(int id, TypedValue value);
//Open a data stream for reading a raw resource.

InputStream openRawResource(int id);
//Open a data stream for reading a raw resource.

@Source({FILESYSTEM, READ_EXTERNAL_STORAGE})AssetFileDescriptor openRawResourceFd(int id);
//Open a file descriptor for reading a raw resource.

void parseBundleExtra(String tagName, AttributeSet attrs, Bundle outBundle);
//Parse a name/value pair out of an XML tag holding that data.

void parseBundleExtras(XmlResourceParser parser, Bundle outBundle);
//Parse a series of <extra> tags from an XML file.

void updateConfiguration(Configuration config, DisplayMetrics metrics);
//Store the newly updated configuration.
}

class TypedArray {
    
boolean getBoolean(int index, boolean defValue);
//Retrieve the boolean value for the attribute at index.

int getColor(int index, int defValue);
//Retrieve the color value for the attribute at index.

ColorStateList getColorStateList(int index);
//Retrieve the ColorStateList for the attribute at index.

float getDimension(int index, float defValue);
//Retrieve a dimensional unit attribute at index.

int getDimensionPixelOffset(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as an offset in raw pixels.

int getDimensionPixelSize(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as a size in raw pixels.

Drawable getDrawable(int index);
//Retrieve the Drawable for the attribute at index.

float getFloat(int index, float defValue);
//Retrieve the float value for the attribute at index.

float getFraction(int index, int base, int pbase, float defValue);
//Retrieve a fractional unit attribute at index.

int getIndex(int at);
//Return an index in the array that has data.

int getIndexCount();
//Return the number of indices in the array that actually have data.

int getInt(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getInteger(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getLayoutDimension(int index, String name);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

int getLayoutDimension(int index, int defValue);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.


String getNonResourceString(int index);
//Retrieve the string value for the attribute at index, but only if that string comes from an immediate value in an XML file.

String getPositionDescription();
//Returns a message about the parser state suitable for printing error messages.

int getResourceId(int index, int defValue);
//Retrieve the resource identifier for the attribute at index.

Resources getResources();
//Return the Resources object this array was loaded from.

String getString(int index);
//Retrieve the string value for the attribute at index.

CharSequence getText(int index);
//Retrieve the styled string value for the attribute at index.

CharSequence[] getTextArray(int index);
//Retrieve the CharSequence[] for the attribute at index.

boolean getValue(int index, TypedValue outValue);
//Retrieve the raw TypedValue for the attribute at index.

boolean hasValue(int index);
//Determines whether there is an attribute at index.

int length();
//Return the number of values in this array.

TypedValue peekValue(int index);
//Retrieve the raw TypedValue for the attribute at index and return a temporary object holding its data.

void recycle();
//Give back a previously retrieved array, for later re-use.

String toString();
//Returns a string containing a concise, human-readable description of this object.



}

