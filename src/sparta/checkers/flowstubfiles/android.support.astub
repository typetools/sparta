package android.support.v4.app;

class ActionBarDrawerToggle {
Drawable getThemeUpIndicator();
void setActionBarDescription(int contentDescRes);
void setActionBarUpIndicator(Drawable upDrawable, int contentDescRes);
void syncState();
}

class ActionBarDrawerToggle$Delegate {
Drawable getThemeUpIndicator();
void setActionBarDescription(int arg0);
void setActionBarUpIndicator(Drawable arg0, int arg1);
}

class ActionBarDrawerToggle$DelegateProvider {
Delegate getDrawerToggleDelegate();
}

class FragmentManager$OnBackStackChangedListener {
void onBackStackChanged();
}

class FragmentStatePagerAdapter {
Fragment getItem(int arg0);
}

class FragmentTabHost {
FragmentTransaction doTabChanged(String tabId, FragmentTransaction ft);
void ensureContent();
void ensureHierarchy(Context context);
void initFragmentTabHost(Context context, AttributeSet attrs);
}
class FragmentTransaction{
        int commit();
        FragmentTransaction add(Fragment arg0, String arg1);
}

class NotificationCompat{
        final int PRIORITY_MIN;
}


class NotificationCompat$Style {
void setBuilder(Builder builder);
void setBuilder(Builder builder);
void setBuilder(Builder builder);
}

class ShareCompat {
static ComponentName getCallingActivity(Activity calledActivity);
static String getCallingPackage(Activity calledActivity);
static void configureMenuItem(Menu menu, int menuItemId, IntentBuilder shareIntent);
static void configureMenuItem(MenuItem item, IntentBuilder shareIntent);
}

class TaskStackBuilder$SupportParentable {
Intent getSupportParentActivityIntent();
}

class ShareCompat$IntentReader {
boolean isMultipleShare();
CharSequence getText();
int getStreamCount();
}

class FragmentPagerAdapter {
static String makeFragmentName(int viewId, long id);
long getItemId(int position);
Fragment getItem(int arg0);

}

class ListFragment{
        ListView getListView();
        View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);
        void setEmptyText(@Sink(DISPLAY) CharSequence text);
        void onActivityCreated(Bundle savedInstanceState);
        void onListItemClick(ListView l, View v, int position, long id);
        void setListAdapter(ListAdapter adapter);
        ListFragment();
}

class TaskStackBuilder {
TaskStackBuilder addParentStack(Activity sourceActivity);
//TaskStackBuilder addParentStack(Class<?> sourceActivityClass);
TaskStackBuilder addParentStack(ComponentName sourceActivityName);
TaskStackBuilder addNextIntent(@Sink(INTENT) Intent nextIntent);
PendingIntent getPendingIntent(int requestCode, int flags);
PendingIntent getPendingIntent(int requestCode, int flags, @Sink(BUNDLE) Bundle options);
static TaskStackBuilder create(Context context);
void startActivities();
void startActivities(Bundle options);
@Source(INTENT) Intent editIntentAt(int index);
}


class LoaderManager{
        <D> Loader<D> restartLoader(int arg0, Bundle arg1, LoaderCallbacks<D> arg2);
        <D> Loader<D> initLoader(int arg0, Bundle arg1, LoaderCallbacks<D> arg2);
}

class LoaderManager$LoaderCallbacks {
Loader<D> onCreateLoader(int arg0, Bundle arg1);
void onLoadFinished(Loader<D> arg0, @Sink(DISPLAY) D arg1);
void onLoaderReset(Loader<D> arg0);
}

class ShareCompat$IntentBuilder {
@Source(INTENT) Intent getIntent();
@Source(INTENT) Intent createChooserIntent();
IntentBuilder setText(CharSequence text);
IntentBuilder setStream(Uri streamUri);
IntentBuilder setChooserTitle(CharSequence title);
IntentBuilder setChooserTitle(int resId);
Activity getActivity();
}

class NotificationCompat$Style {
	void setBuilder(Builder builder);
}

class NotificationCompat$Builder {
void setFlag(int mask, boolean value);
Builder setStyle(Style style);
Notification build();
Builder setContentText(CharSequence text);
Builder setContentTitle(CharSequence title);
Builder setSmallIcon(int icon);
Builder setPriority(int pri);
Builder setContentIntent(PendingIntent intent);
Builder(Context context);
Builder setOngoing(boolean ongoing);
}

class NotificationCompat$InboxStyle{
        InboxStyle(Builder builder);
        InboxStyle addLine(CharSequence cs);
}


class FragmentActivity {
//CSH: in spreadsheet, not found in API:
// doReallyStop
// dumpViewHierarchy
// invalidateSupportFragment
// onReallyStop
// viewToString
FragmentActivity();

LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create);

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Activity's state into the given stream.

Object getLastCustomNonConfigurationInstance();
//Return the value previously returned from onRetainCustomNonConfigurationInstance();.

FragmentManager getSupportFragmentManager();
//Return the FragmentManager for interacting with fragments associated with this activity.

LoaderManager getSupportLoaderManager();
//Return the LoaderManager for this fragment, creating it if needed.

void onAttachFragment(Fragment fragment);
//Called when a fragment is attached to the activity.

void onBackPressed();
//Take care of popping the fragment back stack or finishing the activity as appropriate.

void onConfigurationChanged(Configuration newConfig);
//Dispatch configuration change to all fragments.

boolean onCreatePanelMenu(int featureId, Menu menu);
//Dispatch to Fragment.onCreateOptionsMenu();.

View onCreateView(String name, Context context, AttributeSet attrs);
//Add support for inflating the <fragment> tag.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Take care of calling onBackPressed(); for pre-Eclair platforms.

void onLowMemory();
//Dispatch onLowMemory(); to all fragments.

boolean onMenuItemSelected(int featureId, MenuItem item);
//Dispatch context and options menu to fragments.

void onPanelClosed(int featureId, Menu menu);
//Call onOptionsMenuClosed(); on fragments.

boolean onPreparePanel(int featureId, View view, Menu menu);
//Dispatch onPrepareOptionsMenu(); to fragments.

Object onRetainCustomNonConfigurationInstance();
//Use this instead of onRetainNonConfigurationInstance();.

final Object onRetainNonConfigurationInstance();
//This method was deprecated in API level . Use the new Fragment API setRetainInstance(boolean); instead; this is also available on older platforms through the Android compatibility package.

void startActivityForResult(Intent intent, int requestCode);
//Modifies the standard behavior to allow results to be delivered to fragments.

void startActivityFromFragment(Fragment fragment, Intent intent, int requestCode);
//Called by Fragment.startActivityForResult(); to implement its behavior.

void supportInvalidateOptionsMenu();
//Invalidate the activity's options menu.


//Protected Methods
void onActivityResult(int requestCode, int resultCode, Intent data);
//Dispatch incoming result to the correct fragment.

void onCreate(Bundle savedInstanceState);
//Perform initialization of all fragments and loaders.

void onDestroy();
//Destroy all fragments and loaders.

void onNewIntent(Intent intent);
//Handle onNewIntent(); to inform the fragment manager that the state is not saved.

void onPause();
//Dispatch onPause(); to fragments.

void onPostResume();
//Dispatch onResume(); to fragments.

void onResume();
//Dispatch onResume(); to fragments.

void onResumeFragments();
//This is the fragment-orientated version of onResume(); that you can override to perform operations in the Activity at the same point where its fragments are resumed.

void onSaveInstanceState(Bundle outState);
//Save all appropriate fragment state.

void onStart();
//Dispatch onStart(); to all fragments.

void onStop();
//Dispatch onStop(); to all fragments.
}

class FragmentTabHost {
    
    
//CSH: in spreadsheet, not found in API:
//doTabChanged
//ensureContent
//initFragmentTabHost

void addTab(@Sink(DISPLAY) TabHost.TabSpec tabSpec, Class<?> clss, Bundle args);

//void onTabChanged(String tabId);

//void setOnTabChangedListener(TabHost.OnTabChangeListener l);
//Register a callback to be invoked when the selected state of any of the items in this list changes

//void setup();
//This method was deprecated in API level . Don't call the original TabHost setup, you must instead call setup(Context, FragmentManager); or setup(Context, FragmentManager, int);.

//void setup(Context context, FragmentManager manager);

//void setup(Context context, FragmentManager manager, int containerId);

//Protected Methods
//void onAttachedToWindow();
//This is called when the view is attached to a window.

//void onDetachedFromWindow();
//This is called when the view is detached from a window.

//void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

//Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

}

class Fragment{
        boolean isInLayout();
        boolean onContextItemSelected(MenuItem item);
        CharSequence getText(int resId);
        void onSaveInstanceState(Bundle outState);
        void onResume();
        View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);
        void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo);
        void onAttach(Activity activity);
        String getString(int resId, @Source() @Sink(ANY) Object @Source() @Sink(ANY) [] formatArgs);
        void registerForContextMenu(View view);
        void onCreateOptionsMenu(Menu menu, MenuInflater inflater);
        Resources getResources();
        void onPause();

        void setHasOptionsMenu(boolean hasMenu);
        void startActivity(Intent intent);
        void onCreate(Bundle savedInstanceState);
        Fragment();
        boolean onOptionsItemSelected(MenuItem item);
        void onActivityCreated( Bundle savedInstanceState);
        LoaderManager getLoaderManager();
        void setArguments(@Source({INTENT}) Bundle args);
        Bundle getArguments();
        boolean isResumed();
        FragmentActivity getActivity();
		FragmentManager getFragmentManager();
		View getView();
}

class DialogFragment {
void dismissInternal(boolean allowStateLoss);
Dialog onCreateDialog(@Source(BUNDLE) Bundle savedInstanceState);
int getTheme();
void show(FragmentManager manager, String tag);
void onCreate(Bundle savedInstanceState);
DialogFragment();
}

class NavUtils{
static void navigateUpFromSameTask(Activity sourceActivity);

static String getParentActivityName(Activity sourceActivity);

static String getParentActivityName(Context context, ComponentName componentName) throws NameNotFoundException;

static Intent getParentActivityIntent(Activity sourceActivity);

static Intent getParentActivityIntent(Context context, Class<?> sourceActivityClass) throws NameNotFoundException;

static Intent getParentActivityIntent(Context context, ComponentName componentName) throws NameNotFoundException;

static void navigateUpTo(Activity sourceActivity, Intent upIntent);
}

class FragmentManager {
FragmentTransaction beginTransaction();

boolean executePendingTransactions();

Fragment findFragmentByTag(String arg0);

SavedState saveFragmentInstanceState(Fragment arg0);

void putFragment(Bundle arg0, String arg1, Fragment arg2);

void popBackStack();

void popBackStack(String arg0, int arg1);

void popBackStack(int arg0, int arg1);

Fragment getFragment(Bundle arg0, String arg1);

Fragment findFragmentById(int arg0);

//int commit();

//FragmentTransaction add(Fragment arg0, String arg1);

//FragmentTransaction add(int arg0, Fragment arg1);

//FragmentTransaction add(int arg0, Fragment arg1, String arg2);

//FragmentTransaction detach(Fragment arg0);

//int commitAllowingStateLoss();

//FragmentTransaction remove(Fragment arg0);

//FragmentTransaction attach(Fragment arg0);

//FragmentTransaction replace(int arg0, Fragment arg1);

//FragmentTransaction replace(int arg0, Fragment arg1, String arg2);


}


package android.support.v4.os;

class ParcelableCompatCreatorCallbacks {
T createFromParcel(@Sink(PARCEL) Parcel arg0, ClassLoader arg1);
T[] newArray(int arg0);
}

class ParcelableCompat {
static <T> Creator<T> newCreator(ParcelableCompatCreatorCallbacks<T> callbacks);
}




package android.support.v4.content;

class FileProvider {
static File buildPath(File base, String[] segments);
static int modeToMode(String mode);
static Object[] copyOf(Object[] original, int newLength);
static PathStrategy getPathStrategy(Context context, String authority);
static PathStrategy parsePathStrategy(Context context, String authority) throws IOException,XmlPullParserException;
static String[] copyOf(String[] original, int newLength);
}

class Loader$OnLoadCompleteListener {
void onLoadComplete(Loader<D> arg0, D arg1);
}

class CursorLoader {
void deliverResult(Cursor cursor);
protected void onStopLoading();
void onCanceled(Cursor cursor);
Cursor loadInBackground();
}

class ContextCompat {
static boolean startActivities(Context context, @Sink(INTENT) Intent[] intents);
static boolean startActivities(Context context, @Sink(INTENT) Intent[] intents, Bundle options);
}

class IntentCompat {
@Source(INTENT) static Intent makeMainActivity(ComponentName mainActivity);
}


class Loader<D> {
void deliverResult(D data);
protected void onReset();
boolean isAbandoned();
void rollbackContentChanged();
void commitContentChanged();
boolean isStarted();
boolean isReset();
Context getContext();
void forceLoad();
void unregisterListener(OnLoadCompleteListener<D> listener);
protected void onForceLoad();
void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, PrintWriter writer, String[] args);
void abandon();
void stopLoading();
void startLoading();
void reset();
void registerListener(int id, OnLoadCompleteListener<D> listener);
protected void onStopLoading();
protected void onStartLoading();
protected void onReset();
void onContentChanged();
protected void onAbandon();
void forceLoad();
String dataToString(D data);
boolean takeContentChanged();

}

class AsyncTaskLoader {
AsyncTaskLoader(Context context);
void onCanceled(D data);
protected D onLoadInBackground();
D loadInBackground();
void dump(String prefix,  @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, PrintWriter writer, String[] args);
boolean cancelLoad();
}



class LocalBroadcastManager{
static LocalBroadcastManager getInstance(Context context);
void registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
boolean sendBroadcast(@Sink(INTENT) Intent intent);
void executePendingBroadcasts();
void unregisterReceiver(BroadcastReceiver receiver);
}

package android.support.v4.util;



class ArrayMap {
MapCollections<K,V> getCollection();
}

class AtomicFile {
FileInputStream openRead() throws FileNotFoundException;
static boolean sync(FileOutputStream stream);
}

class SimpleArrayMap {
boolean isEmpty();
int indexOf(Object key, int hash);
int indexOf(Object key, int hash);
int indexOfNull();
int indexOfNull();
int indexOfValue(Object value);
int indexOfValue(Object value);
int size();
K keyAt(int index);
static void freeArrays(int[] hashes, Object[] array, int size);
V get(Object key);
V put(K key, V value);
V put(K key, V value);
V remove(Object key);
V removeAt(int index);
V removeAt(int index);
V setValueAt(int index, V value);
V valueAt(int index);
void allocArrays(int size);
void clear();
void ensureCapacity(int minimumCapacity);
void ensureCapacity(int minimumCapacity);
void putAll(SimpleArrayMap<? extends K,? extends V> array);
}

class LogWriter {
void flushBuilder();
}

class LruCache {
protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue);
void trimToSize(int maxSize);
protected int sizeOf(K key, V value);
protected V create(K key);
}

class LongSparseArray {
//CSH: found in spreadsheet, not in API
//binarySearch
//gc

//void append(long key, E value);
//Puts a key/value pair into the array, optimizing for the case where the key is greater than all existing keys in the array.

//void clear();
//Removes all key-value mappings from this LongSparseArray.

LongSparseArray<E> clone();
//Creates and returns a copy of this Object.

void delete(long key);
//Removes the mapping from the specified key, if there was any.

E get(long key, E valueIfKeyNotFound);
//Gets the Object mapped from the specified key, or the specified Object if no such mapping has been made.

E get(long key);
//Gets the Object mapped from the specified key, or null if no such mapping has been made.

static int idealByteArraySize(int need);

static int idealLongArraySize(int need);

//int indexOfKey(long key);
//Returns the index for which keyAt(int); would return the specified key, or a negative number if the specified key is not mapped.

//int indexOfValue(E value);
//Returns an index for which valueAt(int); would return the specified key, or a negative number if no keys map to the specified value.

//long keyAt(int index);
//Given an index in the range 0...size();-1, returns the key from the indexth key-value mapping that this LongSparseArray stores.

void put(long key, E value);
//Adds a mapping from the specified key to the specified value, replacing the previous mapping from the specified key if there was one.

//void remove(long key);
//Alias for delete(long);.

//void removeAt(int index);
//Removes the mapping at the specified index.

//void setValueAt(int index, E value);
//Given an index in the range 0...size();-1, sets a new value for the indexth key-value mapping that this LongSparseArray stores.

//int size();
//Returns the number of key-value mappings that this LongSparseArray currently stores.

//E valueAt(int index);
//Given an index in the range 0...size();-1, returns the value from the indexth key-value mapping that this LongSparseArray stores.

void gc();

E valueAt(int index);

int size();

long keyAt(int index);

}

class SparseArrayCompat {
// CSH: specified in spreadsheet but not found in class or parents
// binarySearch
// gc
// idealByteArraySize
// idealIntArraySize

void append(int key, E value);
//Puts a key/value pair into the array, optimizing for the case where the key is greater than all existing keys in the array.

void clear();
//Removes all key-value mappings from this SparseArray.

void delete(int key);
//Removes the mapping from the specified key, if there was any.

E get(int key);
//Gets the Object mapped from the specified key, or null if no such mapping has been made.

E get(int key, E valueIfKeyNotFound);
//Gets the Object mapped from the specified key, or the specified Object if no such mapping has been made.

int indexOfKey(int key);
//Returns the index for which keyAt(int); would return the specified key, or a negative number if the specified key is not mapped.

int indexOfValue(E value);
//Returns an index for which valueAt(int); would return the specified key, or a negative number if no keys map to the specified value.

int keyAt(int index);
//Given an index in the range 0...size();-1, returns the key from the indexth key-value mapping that this SparseArray stores.

void put(int key, E value);
//Adds a mapping from the specified key to the specified value, replacing the previous mapping from the specified key if there was one.

void remove(int key);
//Alias for delete(int);.

void removeAt(int index);
//Removes the mapping at the specified index.

void removeAtRange(int index, int size);
//Remove a range of mappings as a batch.

void setValueAt(int index, E value);
//Given an index in the range 0...size();-1, sets a new value for the indexth key-value mapping that this SparseArray stores.

int size();
//Returns the number of key-value mappings that this SparseArray currently stores.

E valueAt(int index);
//Given an index in the range 0...size();-1, returns the value from the indexth key-value mapping that this SparseArray stores.
}

package android.support.v4.view;



class AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge {         
boolean dispatchPopulateAccessibilityEvent(View arg0, AccessibilityEvent arg1);
boolean onRequestSendAccessibilityEvent(ViewGroup arg0, View arg1, AccessibilityEvent arg2);
void onInitializeAccessibilityEvent(View arg0, AccessibilityEvent arg1);
void onInitializeAccessibilityNodeInfo(View arg0, Object arg1);
void onPopulateAccessibilityEvent(View arg0, AccessibilityEvent arg1);
void sendAccessibilityEvent(View arg0, int arg1);
void sendAccessibilityEventUnchecked(View arg0, AccessibilityEvent arg1);
}

class AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean {          
boolean dispatchPopulateAccessibilityEvent(View arg0, AccessibilityEvent arg1);
boolean onRequestSendAccessibilityEvent(ViewGroup arg0, View arg1, AccessibilityEvent arg2);
boolean performAccessibilityAction(View arg0, int arg1, Bundle arg2);
Object getAccessibilityNodeProvider(View arg0);
void onInitializeAccessibilityEvent(View arg0, AccessibilityEvent arg1);
void onInitializeAccessibilityNodeInfo(View arg0, Object arg1);
void onPopulateAccessibilityEvent(View arg0, AccessibilityEvent arg1);
void sendAccessibilityEvent(View arg0, int arg1);
void sendAccessibilityEventUnchecked(View arg0, AccessibilityEvent arg1);
}

class ActionProvider {
boolean isVisible();
boolean overridesItemVisibility();
View onCreateActionView();
View onCreateActionView(MenuItem forItem);
}

class ActionProvider$SubUiVisibilityListener {
void onSubUiVisibilityChanged(boolean arg0); 
}

class ActionProvider$VisibilityListener {
void onActionProviderVisibilityChanged(boolean arg0);
}

class GravityCompat {
static int getAbsoluteGravity(int gravity, int layoutDirection);
}

class KeyEventCompat {
static boolean dispatch(KeyEvent event, Callback receiver, Object state, Object target);
static boolean hasModifiers(KeyEvent event, int modifiers);
static boolean hasNoModifiers(KeyEvent event);
static Object getKeyDispatcherState(View view);
static void startTracking(KeyEvent event);
}

class MenuItemCompat {
static void setShowAsAction(MenuItem item, int actionEnum);
}

class MenuItemCompat$OnActionExpandListener {
boolean onMenuItemActionCollapse(MenuItem arg0);
boolean onMenuItemActionExpand(MenuItem arg0);
}

class ViewCompatKitKat {
static int getAccessibilityLiveRegion(View view);
static void setAccessibilityLiveRegion(View view, int mode);
}

class ViewConfigurationCompat {
static int getScaledPagingTouchSlop(ViewConfiguration config);
}

class ViewGroupCompat {
static void setMotionEventSplittingEnabled(ViewGroup group, boolean split);
}

class ViewPager$PageTransformer {
void transformPage(View arg0, float arg1);
}

class ViewParentCompat {
static boolean requestSendAccessibilityEvent(ViewParent parent, View child, AccessibilityEvent event);
}

class ViewParentCompatICS {
static boolean requestSendAccessibilityEvent(ViewParent parent, View child, AccessibilityEvent event);
}


package android.support.v4.view;
class AccessibilityDelegateCompat {
Object getBridge();
boolean performAccessibilityAction(View host, int action, @Sink(BUNDLE) Bundle args);
AccessibilityNodeProvider getAccessibilityNodeProvider(View host);
}

class ViewCompat {
static void postInvalidateOnAnimation(View view);
static void postInvalidateOnAnimation(View view, int left, int top, int right, int bottom);
static void setImportantForAccessibility(View view, int mode);
static void setAccessibilityDelegate(View v, AccessibilityDelegateCompat delegate);
static boolean canScrollHorizontally(View v, int direction);
static void setLayerType(View view, int layerType, Paint paint);
static void postOnAnimation(View view, Runnable action);
static int getImportantForAccessibility(View view);
static int getOverScrollMode(View v);
static int getLayoutDirection(View view);
static ViewParent getParentForAccessibility(View view);
static int getLayerType(View view);
static void setLayerPaint(View view, Paint paint);
static void postOnAnimationDelayed(View view, Runnable action, long delayMillis);
static boolean performAccessibilityAction(View view, int action, Bundle arguments);
static void onInitializeAccessibilityNodeInfo(View v, AccessibilityNodeInfoCompat info);
static void onInitializeAccessibilityEvent(View v, AccessibilityEvent event);
static boolean isOpaque(View view);
static float getAlpha(View view);
static boolean canScrollVertically(View v, int direction);
}

class VelocityTrackerCompat {
static float getYVelocity(VelocityTracker tracker, int pointerId);

static float getXVelocity(VelocityTracker tracker, int pointerId);
}

class AccessibilityDelegateCompat {
//CSH: Methods in spreadsheet but not in class or parent:
//getBridge

//CSH: It's unclear whether these push anything to the screen, AccessibilityEvent probably holds that answer.
   
//boolean dispatchKeyEventAccessibilityEvent(View host, AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the host View first and then to its children for adding their text content to the event.

AccessibilityNodeProviderCompat getAccessibilityNodeProvider(View host);
//Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.

void onInitializeAccessibilityEvent(View host, AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about the the host View which is the event source.

void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info);
//Initializes an AccessibilityNodeInfoCompat with information about the host view.

void onPopulateAccessibilityEvent(View host, AccessibilityEvent event);
//Gives a chance to the host View to populate the accessibility event with its text content.

boolean onRequestSendAccessibilityEvent(ViewGroup host, View child, AccessibilityEvent event);
//Called when a child of the host View has requested sending an AccessibilityEvent and gives an opportunity to the parent (the host); to augment the event.

boolean performAccessibilityAction(View host, int action, Bundle args);
//Performs the specified accessibility action on the view.

void sendAccessibilityEvent(View host, int eventType);
//Sends an accessibility event of the given type.

void sendAccessibilityEventUnchecked(View host, AccessibilityEvent event);
//Sends an accessibility event.

}

class MotionEventCompat {
static int findPointerIndex(MotionEvent event, int pointerId);
//Call findPointerIndex(int);.

static int getActionIndex(MotionEvent event);
//Call getAction();, returning only the pointer index portion

//static int getActionMasked(MotionEvent event);
//Call getAction();, returning only the ACTION_MASK portion.

//static int getPointerCount(MotionEvent event);
//The number of pointers of data contained in this event.

static int getPointerId(MotionEvent event, int pointerIndex);
//Call getPointerId(int);.

static float getX(MotionEvent event, int pointerIndex);
//Call getX(int);.

static float getY(MotionEvent event, int pointerIndex);
//Call getY(int);.

static int getActionMasked(MotionEvent event);

static int getPointerCount(MotionEvent event);



}

class PagerAdapter {
void destroyItem(ViewGroup container, int position, Object object);
//Remove a page for the given position.

void destroyItem(View container, int position, Object object);
//This method was deprecated in API level . Use destroyItem(ViewGroup, int, Object);

void finishUpdate(View container);
//This method was deprecated in API level . Use finishUpdate(ViewGroup);

void finishUpdate(ViewGroup container);
//Called when the a change in the shown pages has been completed.

abstract int getCount();
//Return the number of views available.

int getItemPosition(Object object);
//Called when the host view is attempting to determine if an item's position has changed.

CharSequence getPageTitle(int position);
//This method may be called by the ViewPager to obtain a title string to describe the specified page.

float getPageWidth(int position);
//Returns the proportional width of a given page as a percentage of the ViewPager's measured width from (0.f-1.f]

Object instantiateItem(ViewGroup container, int position);
//Create the page for the given position.

Object instantiateItem(View container, int position);
//This method was deprecated in API level . Use instantiateItem(ViewGroup, int);

abstract boolean isViewFromObject(View view, Object object);
//Determines whether a page View is associated with a specific key object as returned by instantiateItem(ViewGroup, int);.

void notifyDataSetChanged();
//This method should be called by the application if the data backing this adapter has changed and associated views should update.

void registerDataSetObserver(DataSetObserver observer);
//Register an observer to receive callbacks related to the adapter's data changing.

void restoreState(Parcelable state, ClassLoader loader);
//Restore any instance state associated with this adapter and its pages that was previously saved by saveState();.

Parcelable saveState();
//Save any instance state associated with this adapter and its pages that should be restored if the current UI state needs to be reconstructed.

void setPrimaryItem(View container, int position, Object object);
//This method was deprecated in API level . Use setPrimaryItem(ViewGroup, int, Object);

void setPrimaryItem(ViewGroup container, int position, Object object);
//Called to inform the adapter of which item is currently considered to be the "primary", that is the one show to the user as the current page.

void startUpdate(View container);
//This method was deprecated in API level . Use startUpdate(ViewGroup);

void startUpdate(ViewGroup container);
//Called when a change in the shown pages is going to start being made.

void unregisterDataSetObserver(DataSetObserver observer);
//Unregister an observer from callbacks related to the adapter's data changing.
}

class PagerTabStrip {

//boolean getDrawFullUnderline();
//Return whether or not this tab strip will draw a full-width underline.

//int getTabIndicatorColor();

//boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

//void setBackgroundColor(int color);
//Sets the background color for this view.

//void setBackgroundDrawable(Drawable d);
//This method was deprecated in API level . use setBackground(Drawable); instead

//void setBackgroundResource(int resId);
//Set the background to a given resource.

//void setDrawFullUnderline(boolean drawFull);
//Set whether this tab strip should draw a full-width underline in the current tab indicator color.

void setPadding(int left, int top, int right, int bottom);
//Sets the padding.

void setTabIndicatorColor(int color);
//Set the color of the tab indicator bar.

//void setTabIndicatorColorResource(int resId);
//Set the color of the tab indicator bar from a color resource.

void setTextSpacing(int textSpacing);
//Set the required spacing between title segments.

//Protected Methods
//void onDraw(Canvas canvas);
//Implement this to do your drawing.

}

class PagerTitleStrip {
//CSH: Methods in spreadsheet not found in class or parents:
// access$100
// setSingleLineAllCaps
// updateAdapter
// updateText
// updateTextPositions


int getTextSpacing();

void requestLayout();
//Call this when something has changed which has invalidated the layout of this view.

void setGravity(int gravity);
//Set the Gravity used to position text within the title strip.

void setNonPrimaryAlpha(float alpha);
//Set the alpha value used for non-primary page titles.

void setTextColor(int color);
//Set the color value used as the base color for all displayed page titles.

void setTextSize(int unit, float size);
//Set the default text size to a given unit and value.

void setTextSpacing(int spacingPixels);
//Set the required spacing between title segments.

//Protected Methods
void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

}

class ViewPager {
// CSH: Methods in spreadsheet not found in ViewPager or parent classes
// populate
// setCurrentItemInternal
// access$300
// access$200
// setScrollState
// infoForChild
// setScrollingCacheEnabled
// infoForPosition
// completeScroll
// scrollToItem
// getChildRectInPagerCoordinates
// addNewItem
// performDrag
// pageScrolled
// determineTargetPage
// smoothScrollTo
// setOnAdapterChangeListener
// setInternalPageChangeListener
// recomputeScrollPosition
// pageRight
// pageLeft
// initViewPager
// infoForCurrentScrollPosition
// infoForAnyChild
// distanceInfluenceForSnapDuration
// dataSetChanged
// calculatePageOffsets
// setChildrenDrawingOrderEnabledCompat
// removeNonDecorViews
// onSecondaryPointerUp
// endDrag
// enableLayers
// access$400
// access$000
//isGutterDrag

//void onPageSelected(int arg0);
//void onPageScrollStateChanged(int arg0);
 
void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//We only want the current page that is being shown to be focusable.

void addTouchables(ArrayList<View> views);
//We only want the current page that is being shown to be touchable.

void addView(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

boolean arrowScroll(int direction);

boolean beginFakeDrag();
//Start a fake drag of the pager.

void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

void endFakeDrag();
//End a fake drag of the pager.

boolean executeKeyEvent(@Source(USER_INPUT) KeyEvent event);
//You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.

void fakeDragBy(float xOffset);
//Fake drag by an offset in pixels.

ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

PagerAdapter getAdapter();
//Retrieve the current adapter supplying pages.

int getCurrentItem();

int getOffscreenPageLimit();
//Returns the number of pages that will be retained to either side of the current page in the view hierarchy in an idle state.

int getPageMargin();
//Return the margin between pages.

boolean isFakeDragging();
//Returns true if a fake drag is in progress.

boolean onInterceptTouchEvent(MotionEvent ev);
//Implement this method to intercept all touch screen motion events.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

void removeView(View view);
//Note: do not invoke this method from draw(android.graphics.Canvas);, onDraw(android.graphics.Canvas);, dispatchDraw(android.graphics.Canvas); or any related method.

void setAdapter(PagerAdapter adapter);
//Set a PagerAdapter that will supply views for this pager as needed.

void setCurrentItem(int item, boolean smoothScroll);
//Set the currently selected page.

void setCurrentItem(int item);
//Set the currently selected page.

void setOffscreenPageLimit(int limit);
//Set the number of pages that should be retained to either side of the current page in the view hierarchy in an idle state.

void setOnPageChangeListener(ViewPager.OnPageChangeListener listener);
//Set a listener that will be invoked whenever the page changes or is incrementally scrolled.

void setPageMargin(int marginPixels);
//Set the margin between pages.

void setPageMarginDrawable(int resId);
//Set a drawable that will be used to fill the margin between pages.

void setPageMarginDrawable(Drawable d);
//Set a drawable that will be used to fill the margin between pages.

void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer);
//Set a ViewPager.PageTransformer that will be called for each attached page whenever the scroll position is changed.

//Protected Methods
boolean canScroll(View v, boolean checkV, int dx, int x, int y);
//Tests scrollability within child views of v given a delta of dx.

boolean checkLayoutParams(ViewGroup.LayoutParams p);

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

ViewGroup.LayoutParams generateDefaultLayoutParams();
//Returns a set of default layout parameters.

ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

int getChildDrawingOrder(int childCount, int i);
//Returns the index of the child to draw for this iteration.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onPageScrolled(int position, float offset, int offsetPixels);
//This method will be invoked when the current page is scrolled, either as part of a programmatically initiated smooth scroll or a user initiated touch scroll.

boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect);
//We only want the current page that is being shown to be focusable.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.
}

package android.support.v4.view.accessibility;

class AccessibilityRecordCompat {
Object getImpl();
void setToIndex(int toIndex);
void setSource(View source);
void setSource(View root, int virtualDescendantId);
void setScrollable(boolean scrollable);
void setItemCount(int itemCount);
void setFromIndex(int fromIndex);
static AccessibilityRecordCompat obtain(AccessibilityRecordCompat record);
static AccessibilityRecordCompat obtain();
}
class AccessibilityEventCompat{          
static AccessibilityRecordCompat asRecord(AccessibilityEvent event);
}

class AccessibilityManagerCompat {
static boolean isTouchExplorationEnabled(AccessibilityManager manager);
}          
 
class AccessibilityManagerCompat$AccessibilityStateChangeListenerCompat {
void onAccessibilityStateChanged(boolean arg0);
}

class AccessibilityNodeProviderCompat {
boolean performAction(int virtualViewId, int action, Bundle arguments);
List<AccessibilityNodeInfoCompat> findAccessibilityNodeInfosByText(String text, int virtualViewId);
AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int virtualViewId);
Object getProvider();
AccessibilityNodeInfoCompat findFocus(int focus);
}

class AccessibilityNodeInfoCompat {
// CSH: Present in spreadsheet but not in class or parents:
// wrapNonNullInstance
    
void addAction(int action);
//Adds an action that can be performed on the node.

//void addChild(View child);
//Adds a child.

//void addChild(View root, int virtualDescendantId);
//Adds a virtual child which is a descendant of the given root.

//boolean equals(Object obj);
//Compares this instance with the specified object and indicates if they are equal.

//List<AccessibilityNodeInfoCompat> findAccessibilityNodeInfosByText(String text);
//Finds AccessibilityNodeInfos by text.

//AccessibilityNodeInfoCompat findFocus(int focus);
//Find the view that has the specified focus type.

//AccessibilityNodeInfoCompat focusSearch(int direction);
//Searches for the nearest view in the specified direction that can take input focus.

//int getActions();
//Gets the actions that can be performed on the node.

//void getBoundsInParent(Rect outBounds);
//Gets the node bounds in parent coordinates.

//void getBoundsInScreen(Rect outBounds);
//Gets the node bounds in screen coordinates.

//AccessibilityNodeInfoCompat getChild(int index);
//Get the child at given index.

//int getChildCount();
//Gets the number of children.

//CharSequence getClassName();
//Gets the class this node comes from.

//CharSequence getContentDescription();
//Gets the content description of this node.

Object getInfo();

//int getMovementGranularities();
//Gets the movement granularities for traversing the text of this node.

//CharSequence getPackageName();
//Gets the package this node comes from.

//AccessibilityNodeInfoCompat getParent();
//Gets the parent.

//CharSequence getText();
//Gets the text of this node.

//int getWindowId();
//Gets the id of the window from which the info comes from.

//int hashCode();
//Returns an integer hash code for this object.

//boolean isAccessibilityFocused();
//Gets whether this node is accessibility focused.

//boolean isCheckable();
//Gets whether this node is checkable.

//boolean isChecked();
//Gets whether this node is checked.

//boolean isClickable();
//Gets whether this node is clickable.

//boolean isEnabled();
//Gets whether this node is enabled.

//boolean isFocusable();
//Gets whether this node is focusable.

//boolean isFocused();
//Gets whether this node is focused.

//boolean isLongClickable();
//Gets whether this node is long clickable.

//boolean isPassword();
//Gets whether this node is a password.

//boolean isScrollable();
//Gets if the node is scrollable.

//boolean isSelected();
//Gets whether this node is selected.

//boolean isVisibleToUser();
//Sets whether this node is visible to the user.

//static AccessibilityNodeInfoCompat obtain(View root, int virtualDescendantId);
//Returns a cached instance if such is available otherwise a new one and sets the source.

//static AccessibilityNodeInfoCompat obtain(AccessibilityNodeInfoCompat info);
//Returns a cached instance if such is available or a new one is create.

//static AccessibilityNodeInfoCompat obtain();
//Returns a cached instance if such is available otherwise a new one.

//static AccessibilityNodeInfoCompat obtain(View source);
//Returns a cached instance if such is available otherwise a new one and sets the source.

//boolean performAction(int action);
//Performs an action on the node.

//boolean performAction(int action, Bundle arguments);
//Performs an action on the node.

//void recycle();
//Return an instance back to be reused.

//void setAccessibilityFocused(boolean focused);
//Sets whether this node is accessibility focused.

//void setBoundsInParent(Rect bounds);
//Sets the node bounds in parent coordinates.

//void setBoundsInScreen(Rect bounds);
//Sets the node bounds in screen coordinates.

//void setCheckable(boolean checkable);
//Sets whether this node is checkable.

//void setChecked(boolean checked);
//Sets whether this node is checked.

void setClassName(CharSequence className);
//Sets the class this node comes from.

//void setClickable(boolean clickable);
//Sets whether this node is clickable.

//void setContentDescription(CharSequence contentDescription);
//Sets the content description of this node.

//void setEnabled(boolean enabled);
//Sets whether this node is enabled.

//void setFocusable(boolean focusable);
//Sets whether this node is focusable.

//void setFocused(boolean focused);
//Sets whether this node is focused.

//void setLongClickable(boolean longClickable);
//Sets whether this node is long clickable.

//void setMovementGranularities(int granularities);
//Sets the movement granularities for traversing the text of this node.

//void setPackageName(CharSequence packageName);
//Sets the package this node comes from.

//void setParent(View parent);
//Sets the parent.

//void setParent(View root, int virtualDescendantId);
//Sets the parent to be a virtual descendant of the given root.

//void setPassword(boolean password);
//Sets whether this node is a password.

//void setScrollable(boolean scrollable);
//Sets if the node is scrollable.

//void setSelected(boolean selected);
//Sets whether this node is selected.

//void setSource(View root, int virtualDescendantId);
//Sets the source to be a virtual descendant of the given root.

//void setSource(View source);
//Sets the source.

//void setText(CharSequence text);
//Sets the text of this node.

//void setVisibleToUser(boolean visibleToUser);
//Sets whether this node is visible to the user.

//void populate();
//void populate(int newCurrentItem);
//void setCurrentItemInternal(int item, boolean smoothScroll, boolean always);
//void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity);
//ItemInfo infoForChild(View child);
//void setScrollState(int newState);
//void setScrollingCacheEnabled(boolean enabled);
//ItemInfo infoForPosition(int position);
//void completeScroll(boolean postEvents);
//void scrollToItem(int item, boolean smoothScroll, int velocity, boolean dispatchSelected);
//Rect getChildRectInPagerCoordinates(Rect outRect, View child);
//ItemInfo addNewItem(int position, int index);
//int determineTargetPage(int currentPage, float pageOffset, int velocity, int deltaX);
//boolean performDrag(float x);
//boolean pageScrolled(int xpos);
//void smoothScrollTo(int x, int y);
//void smoothScrollTo(int x, int y, int velocity);
//void setOnAdapterChangeListener(OnAdapterChangeListener listener);
//OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener);
//void recomputeScrollPosition(int width, int oldWidth, int margin, int oldMargin);
//boolean pageRight();
//boolean pageLeft();
//void initViewPager();
//ItemInfo infoForCurrentScrollPosition();
//ItemInfo infoForAnyChild(View child);
//float distanceInfluenceForSnapDuration(float f);
//void dataSetChanged();
//void calculatePageOffsets(ItemInfo curItem, int curIndex, ItemInfo oldCurInfo);
//void removeNonDecorViews();
//void onSecondaryPointerUp(MotionEvent ev);
//boolean isGutterDrag(float x, float dx);
//void endDrag();
//void setChildrenDrawingOrderEnabledCompat(boolean enable);
//void enableLayers(boolean enable);
//int getClientWidth();
//boolean canScrollHorizontally(int direction);
//void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept);

void setScrollable(boolean scrollable);

void setAccessibilityFocused(boolean focused);

static AccessibilityNodeInfoCompat obtain(View source);

static AccessibilityNodeInfoCompat obtain(View root, int virtualDescendantId);

static AccessibilityNodeInfoCompat obtain();

static AccessibilityNodeInfoCompat obtain(AccessibilityNodeInfoCompat info);

CharSequence getContentDescription();

void getBoundsInParent(Rect outBounds);

int getActions();

void setVisibleToUser(boolean visibleToUser);

void setSource(View source);

void setSource(View root, int virtualDescendantId);

void setParent(View parent);

void setParent(View root, int virtualDescendantId);

void setPackageName(CharSequence packageName);

void setEnabled(boolean enabled);

void setBoundsInScreen(Rect bounds);

void setBoundsInParent(Rect bounds);

boolean isSelected();

boolean isLongClickable();

boolean isFocused();

boolean isFocusable();

boolean isEnabled();

boolean isClickable();

CharSequence getPackageName();

CharSequence getClassName();

void getBoundsInScreen(Rect outBounds);

void addChild(View child);

void addChild(View root, int virtualDescendantId);

void setSelected(boolean selected);

void setLongClickable(boolean longClickable);

void setFocused(boolean focused);

void setFocusable(boolean focusable);

void setContentDescription(CharSequence contentDescription);

void setClickable(boolean clickable);

void recycle();

boolean isVisibleToUser();

boolean isAccessibilityFocused();

CharSequence getText();

void setMovementGranularities(int granularities);

boolean isScrollable();

boolean isPassword();

boolean isChecked();

boolean isCheckable();

String getViewIdResourceName();

int getMovementGranularities();
    
}

package android.support.v4.widget;

class AutoScrollHelper {
AutoScrollHelper setActivationDelay(int delayMillis);
AutoScrollHelper setEdgeType(int type);
AutoScrollHelper setMaximumEdges(float horizontalMax, float verticalMax);
AutoScrollHelper setMaximumVelocity(float horizontalMax, float verticalMax);
AutoScrollHelper setMinimumVelocity(float horizontalMin, float verticalMin);
AutoScrollHelper setRampDownDuration(int durationMillis);
AutoScrollHelper setRampUpDuration(int durationMillis);
AutoScrollHelper setRelativeEdges(float horizontal, float vertical);
AutoScrollHelper setRelativeVelocity(float horizontal, float vertical);
boolean canTargetScrollHorizontally(int arg0);
boolean canTargetScrollVertically(int arg0);
boolean shouldAnimate();
float computeTargetVelocity(int direction, float coordinate, float srcSize, float dstSize);
float constrainEdgeValue(float current, float leading);
float getEdgeValue(float relativeValue, float size, float maxValue, float current);
static float constrain(float value, float min, float max);
static int constrain(int value, int min, int max);
void cancelTargetTouch();
void requestStop();
void scrollTargetBy(int arg0, int arg1);
void startAnimating();
}

class ContentLoadingProgressBar {
void removeCallbacks();
}

class ExploreByTouchHelper {
AccessibilityEvent createEvent(int virtualViewId, int eventType);
AccessibilityEvent createEventForChild(int virtualViewId, int eventType);
AccessibilityEvent createEventForHost(int eventType);
AccessibilityNodeInfoCompat createNode(int virtualViewId);
AccessibilityNodeInfoCompat createNodeForChild(int virtualViewId);
AccessibilityNodeInfoCompat createNodeForHost();
boolean clearAccessibilityFocus(int virtualViewId);
boolean intersectVisibleToUser(Rect localRect);
boolean isAccessibilityFocused(int virtualViewId);
boolean manageFocusForChild(int virtualViewId, int action, Bundle arguments);
boolean performAction(int virtualViewId, int action, Bundle arguments);
boolean performActionForChild(int virtualViewId, int action, Bundle arguments);
boolean performActionForHost(int action, Bundle arguments);
boolean requestAccessibilityFocus(int virtualViewId);
boolean sendEventForVirtualView(int virtualViewId, int eventType);
protected boolean onPerformActionForVirtualView(int arg0, int arg1, Bundle arg2);
protected int getVirtualViewAt(float arg0, float arg1);
protected void getVisibleVirtualViews(List<Integer> arg0);
protected void onPopulateEventForVirtualView(int arg0, AccessibilityEvent arg1);
protected void onPopulateNodeForVirtualView(int arg0, AccessibilityNodeInfoCompat arg1);
void invalidateVirtualView(int virtualViewId);
void updateHoveredVirtualView(int virtualViewId);
}

class DrawerLayout {
boolean checkDrawerViewAbsoluteGravity(View drawerView, int checkFor);
boolean hasPeekingDrawer();
boolean hasVisibleDrawer();
boolean isContentView(View child);
boolean isDrawerOpen(int drawerGravity);
boolean isDrawerOpen(View drawer);
boolean isDrawerView(View child);
boolean isDrawerVisible(int drawerGravity);
boolean isDrawerVisible(View drawer);
float getDrawerViewOffset(View drawerView);
int getDrawerLockMode(int edgeGravity);
int getDrawerLockMode(View drawerView);
int getDrawerViewAbsoluteGravity(View drawerView);
static String gravityToString(int gravity);
View findDrawerWithGravity(int gravity);
View findOpenDrawer();
View findVisibleDrawer();
void cancelChildViewTouch();
void closeDrawer(int gravity);
void closeDrawer(View drawerView);
void closeDrawers();
void closeDrawers(boolean peekingOnly);
void dispatchOnDrawerClosed(View drawerView);
void dispatchOnDrawerOpened(View drawerView);
void dispatchOnDrawerSlide(View drawerView, float slideOffset);
void openDrawer(int gravity);
void openDrawer(View drawerView);
void setDrawerLockMode(int lockMode, int edgeGravity);
void setDrawerLockMode(int lockMode, View drawerView);
void setDrawerLockMode(int lockMode);
void setDrawerShadow(Drawable shadowDrawable, int gravity);
void setDrawerShadow(int resId, int gravity);
void setDrawerViewOffset(View drawerView, float slideOffset);
void updateDrawerState(int forGravity, int activeState, View activeDrawer);
}

class DrawerLayout$DrawerListener {
void onDrawerClosed(View arg0);
void onDrawerOpened(View arg0);
void onDrawerSlide(View arg0, float arg1);
void onDrawerStateChanged(int arg0);
}

class ScrollerCompat {
boolean computeScrollOffset();
boolean isFinished();
int getCurrX();
int getCurrY();
int getFinalX();
int getFinalY();
static ScrollerCompat create(Context context, Interpolator interpolator);
static ScrollerCompat create(Context context);
void abortAnimation();
}

class SearchViewCompat$OnCloseListenerCompat {
boolean onClose();
}

class SearchViewCompat$OnQueryTextListenerCompat {
 boolean onQueryTextChange(String newText);
 boolean onQueryTextSubmit(String query);
}

class SimpleCursorAdapter$ViewBinder {
boolean setViewValue(View arg0, Cursor arg1, int arg2);
}


class SlidingPaneLayout {
boolean closePane();
boolean closePane(View pane, int initialVelocity);
boolean isDimmed(View child);
boolean isOpen();
boolean isSlideable();
boolean openPane();
boolean openPane(View pane, int initialVelocity);
boolean smoothSlideTo(float slideOffset, int velocity);
void dimChildView(View v, float mag, int fadeColor);
void dispatchOnPanelClosed(View panel);
void dispatchOnPanelOpened(View panel);
void dispatchOnPanelSlide(View panel);
void invalidateChildRegion(View v);
void onPanelDragged(int newLeft);
void parallaxOtherViews(float slideOffset);
void setAllChildrenVisible();
void setShadowDrawable(Drawable d);
void updateObscuredViewsVisibility(View panel);
}

class SlidingPaneLayout$PanelSlideListener {
void onPanelClosed(View arg0);
void onPanelOpened(View arg0);
void onPanelSlide(View arg0, float arg1);
}

class ViewDragHelper$Callback {
boolean onEdgeLock(int edgeFlags);
boolean tryCaptureView(View arg0, int arg1);
int clampViewPositionHorizontal(View child, int left, int dx);
int clampViewPositionVertical(View child, int top, int dy);
int getOrderedChildIndex(int index);
int getViewHorizontalDragRange(View child);
int getViewVerticalDragRange(View child);
void onEdgeDragStarted(int edgeFlags, int pointerId);
void onEdgeTouched(int edgeFlags, int pointerId);
void onViewCaptured(View capturedChild, int activePointerId);
void onViewDragStateChanged(int state);
void onViewReleased(View releasedChild, float xvel, float yvel);
}

class ViewDragHelper {
boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge);
boolean checkTouchSlop(int directions, int pointerId);
boolean checkTouchSlop(int directions);
boolean checkTouchSlop(View child, float dx, float dy);
boolean continueSettling(boolean deferCallbacks);
boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel);
boolean isCapturedViewUnder(int x, int y);
boolean isEdgeTouched(int edges, int pointerId);
boolean isEdgeTouched(int edges);
boolean isPointerDown(int pointerId);
boolean isViewUnder(View view, int x, int y);
boolean settleCapturedViewAt(int finalLeft, int finalTop);
boolean shouldInterceptTouchEvent(MotionEvent ev);
boolean smoothSlideViewTo(View child, int finalLeft, int finalTop);
boolean tryCaptureViewForDrag(View toCapture, int pointerId);
float clampMag(float value, float absMin, float absMax);
float distanceInfluenceForSnapDuration(float f);
int clampMag(int value, int absMin, int absMax);
int computeAxisDuration(int delta, int velocity, int motionRange);
int getEdgeSize();
int getEdgesTouched(int x, int y);
int getTouchSlop();
int getViewDragState();
static ViewDragHelper create(ViewGroup forParent, Callback cb);
static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb);
View findTopChildUnder(int x, int y);
View getCapturedView();
void abort();
void cancel();
void captureChildView(View childView, int activePointerId);
void clearMotionHistory();
void clearMotionHistory(int pointerId);
void dispatchViewReleased(float xvel, float yvel);
void dragTo(int left, int top, int dx, int dy);
void ensureMotionHistorySizeForId(int pointerId);
void processTouchEvent(MotionEvent ev);
void reportNewEdgeDrags(float dx, float dy, int pointerId);
void saveInitialMotion(float x, float y, int pointerId);
void saveLastMotion(MotionEvent ev);
void setDragState(int state);
void setEdgeTrackingEnabled(int edgeFlags);
void setMinVelocity(float minVel);
}

class CursorAdapter {
protected void init(Context context, Cursor c, boolean autoRequery);
void init(Context context, Cursor c, int flags);
View newView(Context arg0, Cursor arg1, ViewGroup arg2);
void bindView(View arg0, Context arg1, Cursor arg2);
Cursor swapCursor(Cursor newCursor);
protected void onContentChanged();
View newDropDownView(Context context, Cursor cursor, ViewGroup parent);
Cursor swapCursor(Cursor newCursor);
CharSequence convertToString(Cursor cursor);
void changeCursor(Cursor cursor);
}

class SimpleCursorAdapter {
void findColumns(String[] from);
void setViewText(TextView v, String text);
void setViewImage(ImageView v, String value);
SimpleCursorAdapter(Context context, int layout, Cursor c,
@Sink(DATABASE) String[] from, int[] to, int flags);
}


class EdgeEffectCompat {

boolean draw(Canvas canvas);
//Draw into the provided canvas.

void finish();
//Immediately finish the current animation.

boolean isFinished();
//Reports if this EdgeEffectCompat's animation is finished.

//boolean onAbsorb(int velocity);
//Call when the effect absorbs an impact at the given velocity.

boolean onPull(float deltaDistance);
//A view should call this when content is pulled away from an edge by the user.

//boolean onRelease();
//Call when the object is released after being pulled.

void setSize(int width, int height);
//Set the size of this edge effect in pixels.

}

package android.support.v4.text;

class TextUtilsCompat {
static int getLayoutDirectionFromFirstChar(Locale locale);
static int getLayoutDirectionFromLocale(Locale locale);
}

class TextDirectionHeuristicsCompat {
static int isRtlText(int directionality);
static int isRtlTextOrFormat(int directionality);
}

class TextDirectionHeuristicCompat {
boolean isRtl(char[] arg0, int arg1, int arg2);
boolean isRtl(CharSequence arg0, int arg1, int arg2);
}

class ICUCompat {
static String addLikelySubtags(String locale);
static String getScript(String locale);
}

class BidiFormatter$Builder {
BidiFormatter build();
static BidiFormatter getDefaultInstanceFromContext(boolean isRtlContext);
void initialize(boolean isRtlContext);
}

class BidiFormatter {
boolean getStereoReset();
static boolean isRtlLocale(Locale locale);
static int getEntryDir(String str);
static int getExitDir(String str);
String markAfter(String str, TextDirectionHeuristicCompat heuristic);
String markBefore(String str, TextDirectionHeuristicCompat heuristic);
String unicodeWrap(String str, boolean isolate);
String unicodeWrap(String str, TextDirectionHeuristicCompat heuristic, boolean isolate);
String unicodeWrap(String str, TextDirectionHeuristicCompat heuristic);
String unicodeWrap(String str);
}

package android.support.v4.print;
class PrintHelperKitKat {
Bitmap loadBitmap(Uri uri, Options o) throws FileNotFoundException;
Bitmap loadConstrainedBitmap(Uri uri, int maxSideLength) throws FileNotFoundException;
int getColorMode();
int getScaleMode();
void printBitmap(String jobName, Bitmap bitmap);
void printBitmap(String jobName, Uri imageFile) throws FileNotFoundException;
void setColorMode(int colorMode);
void setScaleMode(int scaleMode);
}

class PrintHelper {
static boolean systemSupportsPrint();
}

package android.support.v4.media;
class TransportStateListener {
void onPlayingChanged(TransportController controller);
void onTransportControlsChanged(TransportController controller);
}



class TransportPerformer {
boolean onIsPlaying();
boolean onMediaButtonDown(int keyCode, KeyEvent event);
boolean onMediaButtonUp(int keyCode, KeyEvent event);
int onGetBufferPercentage();
int onGetTransportControlFlags();
long onGetCurrentPosition();
long onGetDuration();
void onAudioFocusChange(int focusChange);
void onPause();
void onSeekTo(long arg0);
void onStart();
void onStop();
}

class TransportMediator {
static boolean isMediaKey(int keyCode);
TransportStateListener[] getListeners();
void pushControllerState();
void reportPlayingChanged();
void reportTransportControlsChanged();
}

package android.support.v4.internal.view;
class SupportMenuItem {
 ActionProvider getSupportActionProvider();
 boolean collapseActionView();
 boolean expandActionView();
 boolean isActionViewExpanded();
 MenuItem setActionView(int arg0);
 MenuItem setActionView(View arg0);
 SupportMenuItem setSupportActionProvider(ActionProvider arg0);
 SupportMenuItem setSupportOnActionExpandListener(OnActionExpandListener arg0);
 View getActionView();
 void setShowAsAction(int arg0);
}


package android.support.v4.graphics.drawable;
class DrawableCompat {
static boolean isAutoMirrored(Drawable drawable);
static void setAutoMirrored(Drawable drawable, boolean mirrored);
}
