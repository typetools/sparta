
package java.util;



class Properties {
Enumeration<?> propertyNames();
String getProperty(String arg0, String arg1);
String getProperty(String arg0);
Properties();
void load(InputStream arg0) throws IOException;
}

@PolyFlowReceiver
class AbstractCollection<E> implements Collection<E> {
    protected AbstractCollection();
    Iterator<E> iterator();
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    void clear();
    String toString();
}

@PolyFlowReceiver
class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    protected int modCount;
    protected AbstractList();
    boolean add(E arg0);
    E get(int arg0);
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    E remove(int arg0);
    int indexOf(Object arg0);
    int lastIndexOf(Object arg0);
    void clear();
    boolean addAll(int arg0, Collection<? extends E> arg1);
    Iterator<E> iterator();
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int arg0);
    List<E> subList(int arg0, int arg1);
    boolean equals(Object arg0);
    int hashCode();
    protected void removeRange(int arg0, int arg1);
}
@PolyFlowReceiver
class AbstractMap<K,V>{
            V remove(Object arg0);
            V put(K arg0, V arg1);
            protected AbstractMap();
            Set<Entry<K,V>> entrySet();
            V get(Object arg0);
            void clear();
            boolean containsKey(Object arg0);
            int size();
             String toString();
}

class AbstractSet<E>{
            protected AbstractSet();
}
 
@PolyFlowReceiver
class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable {
//Added by pbsf
    ArrayDeque();
    ArrayDeque(int arg0);
    ArrayDeque(Collection<? extends E> arg0);
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E getFirst();
    E getLast();
    E peekFirst();
    E peekLast();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
    void push(E arg0);
    E pop();
    int size();
    boolean isEmpty();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    void clear();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    ArrayDeque<E> clone();
} 
 
class ArrayList<E> { 
//Added by smillst
    ArrayList(int arg0);
    ArrayList();
    @PolyFlow
    ArrayList(Collection<? extends E> arg0);
 
    void trimToSize();
    void ensureCapacity(int arg0);
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean contains(Object arg0);
    @PolyFlowReceiver
    int indexOf(Object arg0);
    @PolyFlowReceiver
    int lastIndexOf(Object arg0);
    @PolyFlowReceiver
    Object clone();
    @PolyFlowReceiver
    Object[] toArray();
    @PolyFlowReceiver
    <T> T[] toArray(T[] arg0);
    E get(int arg0) ;
    @PolyFlowReceiver
    E set(int arg0, E arg1);
    @PolyFlowReceiver
    boolean add(E arg0);
    @PolyFlowReceiver
    void add(int arg0, E arg1);
    @PolyFlowReceiver
    E remove(int arg0);
    @PolyFlowReceiver
    boolean remove(Object arg0);
    void clear();
    @PolyFlowReceiver
    boolean addAll(Collection<? extends E> arg0);
    @PolyFlowReceiver
    boolean addAll(int arg0, Collection<? extends E> arg1);
    @PolyFlowReceiver
    protected void removeRange(int arg0, int arg1);
    @PolyFlowReceiver
    boolean removeAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean retainAll(Collection<?> arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator(int arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator();
    @PolyFlowReceiver
    Iterator<E> iterator();
    @PolyFlowReceiver
    List<E> subList(int arg0, int arg1);
}

@PolyFlow
class Arrays {
    static void sort(int[] arg0);
    static void sort(int[] arg0, int arg1, int arg2);
    static void sort(long[] arg0);
    static void sort(long[] arg0, int arg1, int arg2);
    static void sort(short[] arg0);
    static void sort(short[] arg0, int arg1, int arg2);
    static void sort(char[] arg0);
    static void sort(char[] arg0, int arg1, int arg2);
    static void sort(byte[] arg0);
    static void sort(byte[] arg0, int arg1, int arg2);
    static void sort(float[] arg0);
    static void sort(float[] arg0, int arg1, int arg2);
    static void sort(double[] arg0);
    static void sort(double[] arg0, int arg1, int arg2);
    static void sort(Object[] arg0);
    static void sort(Object[] arg0, int arg1, int arg2);
    static <T> void sort(T[] arg0, Comparator<? super T> arg1);
    static <T> void sort(T[] arg0, int arg1, int arg2, Comparator<? super T> arg3);
    static int binarySearch(long[] arg0, long arg1);
    static int binarySearch(long[] arg0, int arg1, int arg2, long arg3);
    static int binarySearch(int[] arg0, int arg1);
    static int binarySearch(int[] arg0, int arg1, int arg2, int arg3);
    static int binarySearch(short[] arg0, short arg1);
    static int binarySearch(short[] arg0, int arg1, int arg2, short arg3);
    static int binarySearch(char[] arg0, char arg1);
    static int binarySearch(char[] arg0, int arg1, int arg2, char arg3);
    static int binarySearch(byte[] arg0, byte arg1);
    static int binarySearch(byte[] arg0, int arg1, int arg2, byte arg3);
    static int binarySearch(double[] arg0, double arg1);
    static int binarySearch(double[] arg0, int arg1, int arg2, double arg3);
    static int binarySearch(float[] arg0, float arg1);
    static int binarySearch(float[] arg0, int arg1, int arg2, float arg3);
    static int binarySearch(Object[] arg0, Object arg1);
    static int binarySearch(Object[] arg0, int arg1, int arg2, Object arg3);
    static <T> int binarySearch(T[] arg0, T arg1, Comparator<? super T> arg2);
    static <T> int binarySearch(T[] arg0, int arg1, int arg2, T arg3, Comparator<? super T> arg4);
    static boolean equals(long[] arg0, long[] arg1);
    static boolean equals(int[] arg0, int[] arg1);
    static boolean equals(short[] arg0, short[] arg1);
    static boolean equals(char[] arg0, char[] arg1);
    static boolean equals(byte[] arg0, byte[] arg1);
    static boolean equals(boolean[] arg0, boolean[] arg1);
    static boolean equals(double[] arg0, double[] arg1);
    static boolean equals(float[] arg0, float[] arg1);
    static boolean equals(Object[] arg0, Object[] arg1);
    static void fill(long[] arg0, long arg1);
    static void fill(long[] arg0, int arg1, int arg2, long arg3);
    static void fill(int[] arg0, int arg1);
    static void fill(int[] arg0, int arg1, int arg2, int arg3);
    static void fill(short[] arg0, short arg1);
    static void fill(short[] arg0, int arg1, int arg2, short arg3);
    static void fill(char[] arg0, char arg1);
    static void fill(@PolySource @PolySink char[] arg0, int arg1, int arg2, @PolySource @PolySink char arg3);
    static void fill(@PolySource @PolySink byte[] arg0, @PolySource @PolySink byte arg1);
    static void fill(@PolySource @PolySink byte[] arg0, int arg1, int arg2, @PolySource @PolySink byte arg3);
    static void fill(@PolySource @PolySink boolean[] arg0, @PolySource @PolySink boolean arg1);
    static void fill(boolean[] arg0, int arg1, int arg2, boolean arg3);
    static void fill(double[] arg0, double arg1);
    static void fill(double[] arg0, int arg1, int arg2, double arg3);
    static void fill(float[] arg0, float arg1);
    static void fill(float[] arg0, int arg1, int arg2, float arg3);
    static void fill(Object[] arg0, Object arg1);
    static void fill(Object[] arg0, int arg1, int arg2, Object arg3);
    static <T> T[] copyOf(T[] arg0, int arg1);
    static <T, U> T[] copyOf(U[] arg0, int arg1, Class<? extends T[]> arg2);
    static byte[] copyOf(byte[] arg0, int arg1);
    static short[] copyOf(short[] arg0, int arg1);
    static int[] copyOf(int[] arg0, int arg1);
    static long[] copyOf(long[] arg0, int arg1);
    static char[] copyOf(char[] arg0, int arg1);
    static float[] copyOf(float[] arg0, int arg1);
    static double[] copyOf(double[] arg0, int arg1);
    static boolean[] copyOf(boolean[] arg0, int arg1);
    static <T> T[] copyOfRange(T[] arg0, int arg1, int arg2);
    static <T, U> T[] copyOfRange(U[] arg0, int arg1, int arg2, Class<? extends T[]> arg3);
    static byte[] copyOfRange(byte[] arg0, int arg1, int arg2);
    static short[] copyOfRange(short[] arg0, int arg1, int arg2);
    static int[] copyOfRange(int[] arg0, int arg1, int arg2);
    static long[] copyOfRange(long[] arg0, int arg1, int arg2);
    static char[] copyOfRange(char[] arg0, int arg1, int arg2);
    static float[] copyOfRange(float[] arg0, int arg1, int arg2);
    static double[] copyOfRange(double[] arg0, int arg1, int arg2);
    static boolean[] copyOfRange(boolean[] arg0, int arg1, int arg2);
    static <T> List<T> asList(T[] arg0);
    static int hashCode(long[] arg0);
    static int hashCode(int[] arg0);
    static int hashCode(short[] arg0);
    static int hashCode(char[] arg0);
    static int hashCode(byte[] arg0);
    static int hashCode(boolean[] arg0);
    static int hashCode(float[] arg0);
    static int hashCode(double[] arg0);
    static int hashCode(Object[] arg0);
    static int deepHashCode(Object[] arg0);
    static boolean deepEquals(Object[] arg0, Object[] arg1);
    static String toString(long[] arg0);
    static String toString(int[] arg0);
    static String toString(short[] arg0);
    static String toString(char[] arg0);
    static String toString(byte[] arg0);
    static String toString(boolean[] arg0);
    static String toString(float[] arg0);
    static String toString(double[] arg0);
    static String toString(Object[] arg0);
    static String deepToString(Object[] arg0);
}

@PolyFlowReceiver
class BitSet implements Cloneable, Serializable {
    BitSet();
    BitSet(int arg0);
    static BitSet valueOf(long[] arg0);
    static BitSet valueOf(LongBuffer arg0);
    static BitSet valueOf(byte[] arg0);
    static BitSet valueOf(ByteBuffer arg0);
    byte[] toByteArray();
    long[] toLongArray();
    void flip(int arg0);
    void flip(int arg0, int arg1);
    void set(int arg0);
    void set(int arg0, boolean arg1);
    void set(int arg0, int arg1);
    void set(int arg0, int arg1, boolean arg2);
    void clear(int arg0);
    void clear(int arg0, int arg1);
    void clear();
    boolean get(int arg0);
    BitSet get(int arg0, int arg1);
    int nextSetBit(int arg0);
    int nextClearBit(int arg0);
    int previousSetBit(int arg0);
    int previousClearBit(int arg0);
    int length();
    boolean isEmpty();
    boolean intersects(BitSet arg0);
    int cardinality();
    void and(BitSet arg0);
    void or(BitSet arg0);
    void xor(BitSet arg0);
    void andNot(BitSet arg0);
    int hashCode();
    int size();
    boolean equals(Object arg0);
    Object clone();
    String toString();
}

class Calendar implements Serializable, Cloneable, Comparable<Calendar> {
//Added by pbsf
    static final int DAY_OF_MONTH;
    final  int ERA;
    final  int YEAR;
    final  int MONTH;
    final  int WEEK_OF_YEAR;
    final  int WEEK_OF_MONTH;
    final  int DATE;
    final  int DAY_OF_YEAR;
    final  int DAY_OF_WEEK;
    final  int DAY_OF_WEEK_IN_MONTH;
    final  int AM_PM;
    final  int HOUR;
    final  int HOUR_OF_DAY;
    final  int MINUTE;
    final  int SECOND;
    final  int MILLISECOND;
    final  int ZONE_OFFSET;
    final  int DST_OFFSET;
    final  int FIELD_COUNT;
    final  int SUNDAY;
    final  int MONDAY;
    final  int TUESDAY;
    final  int WEDNESDAY;
    final  int THURSDAY;
    final  int FRIDAY;
    final  int SATURDAY;
    final  int JANUARY;
    final  int FEBRUARY;
    final  int MARCH;
    final  int APRIL;
    final  int MAY;
    final  int JUNE;
    final  int JULY;
    final  int AUGUST;
    final  int SEPTEMBER;
    final  int OCTOBER;
    final  int NOVEMBER;
    final  int DECEMBER;
    final  int UNDECIMBER;
    final  int AM;
    final  int PM;
    final  int ALL_STYLES;
    final  int SHORT;
    final  int LONG;
    protected int[] fields;
    protected boolean[] isSet;
    protected long time;
    protected boolean isTimeSet;
    protected boolean areFieldsSet;
    protected Calendar();
    protected Calendar(TimeZone arg0, Locale arg1);
    static Calendar getInstance();
    static Calendar getInstance(TimeZone arg0);
    static Calendar getInstance(Locale arg0);
    static Calendar getInstance(TimeZone arg0, Locale arg1);
    static Locale[] getAvailableLocales();
    protected void computeTime();
    protected void computeFields();
    Date getTime();
    void setTime(Date arg0);
    long getTimeInMillis();
    void setTimeInMillis(long arg0);
    int get(int arg0);
    protected int internalGet(int arg0);
    void set(int arg0, int arg1);
    void set(int arg0, int arg1, int arg2);
    void set(int arg0, int arg1, int arg2, int arg3, int arg4);
    void set(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    void clear();
    void clear(int arg0);
    boolean isSet(int arg0);
    String getDisplayName(int arg0, int arg1, Locale arg2);
    Map<String,Integer> getDisplayNames(int arg0, int arg1, Locale arg2);
    protected void complete();
    boolean equals(Object arg0);
    int hashCode();
    boolean before(Object arg0);
    boolean after(Object arg0);
    int compareTo(Calendar arg0);
    void add(int arg0, int arg1);
    void roll(int arg0, boolean arg1);
    void roll(int arg0, int arg1);
    void setTimeZone(TimeZone arg0);
    TimeZone getTimeZone();
    void setLenient(boolean arg0);
    boolean isLenient();
    void setFirstDayOfWeek(int arg0);
    int getFirstDayOfWeek();
    void setMinimalDaysInFirstWeek(int arg0);
    int getMinimalDaysInFirstWeek();
    boolean isWeekDateSupported();
    int getWeekYear();
    void setWeekDate(int arg0, int arg1, int arg2);
    int getWeeksInWeekYear();
    int getMinimum(int arg0);
    int getMaximum(int arg0);
    int getGreatestMinimum(int arg0);
    int getLeastMaximum(int arg0);
    int getActualMinimum(int arg0);
    int getActualMaximum(int arg0);
    Object clone();
    String toString();
}
       
@PolyFlowReceiver
interface Collection<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    void clear();
    boolean equals(Object arg0);
    int hashCode();
}

@PolyFlowReceiver
class Collections {
//Added by pbsf
    final Set EMPTY_SET;
    final List EMPTY_LIST;
    final Map EMPTY_MAP;
    static <T> void sort(List<T> arg0);
    static <T> void sort(List<T> arg0, Comparator<? super T> arg1);
    static <T> int binarySearch(List<? extends Comparable<? super T>> arg0, T arg1);
    static <T> int binarySearch(List<? extends T> arg0, T arg1, Comparator<? super T> arg2);
    static void reverse(List<?> arg0);
    static void shuffle(List<?> arg0);
    static void shuffle(List<?> arg0, Random arg1);
    static void swap(List<?> arg0, int arg1, int arg2);
    static <T> void fill(List<? super T> arg0, T arg1);
    static <T> void copy(List<? super T> arg0, List<? extends T> arg1);
    static <T> T min(Collection<? extends T> arg0);
    static <T> T min(Collection<? extends T> arg0, Comparator<? super T> arg1);
    static <T> T max(Collection<? extends T> arg0);
    static <T> T max(Collection<? extends T> arg0, Comparator<? super T> arg1);
    static void rotate(List<?> arg0, int arg1);
    static <T> boolean replaceAll(List<T> arg0, T arg1, T arg2);
    static int indexOfSubList(List<?> arg0, List<?> arg1);
    static int lastIndexOfSubList(List<?> arg0, List<?> arg1);
    static <T> Collection<T> unmodifiableCollection(Collection<? extends T> arg0);
    static <T> Set<T> unmodifiableSet(Set<? extends T> arg0);
    static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> arg0);
    static <T> List<T> unmodifiableList(List<? extends T> arg0);
    static <K, V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> arg0);
    static <K, V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K,? extends V> arg0);
    static <T> Collection<T> synchronizedCollection(Collection<T> arg0);
    static <T> Set<T> synchronizedSet(Set<T> arg0);
    static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> arg0);
    static <T> List<T> synchronizedList(List<T> arg0);
    static <K, V> Map<K,V> synchronizedMap(Map<K,V> arg0);
    static <K, V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> arg0);
    static <E> Collection<E> checkedCollection(Collection<E> arg0, Class<E> arg1);
    static <E> Set<E> checkedSet(Set<E> arg0, Class<E> arg1);
    static <E> SortedSet<E> checkedSortedSet(SortedSet<E> arg0, Class<E> arg1);
    static <E> List<E> checkedList(List<E> arg0, Class<E> arg1);
    static <K, V> Map<K,V> checkedMap(Map<K,V> arg0, Class<K> arg1, Class<V> arg2);
    static <K, V> SortedMap<K,V> checkedSortedMap(SortedMap<K,V> arg0, Class<K> arg1, Class<V> arg2);
    static <T> Iterator<T> emptyIterator();
    static <T> ListIterator<T> emptyListIterator();
    static <T> Enumeration<T> emptyEnumeration();
    static <T> Set<T> emptySet();
    static <T> List<T> emptyList();
    static <K, V> Map<K,V> emptyMap();
    static <T> Set<T> singleton(T arg0);
    static <T> List<T> singletonList(T arg0);
    static <K, V> Map<K,V> singletonMap(K arg0, V arg1);
    static <T> List<T> nCopies(int arg0, T arg1);
    static <T> Comparator<T> reverseOrder();
    static <T> Comparator<T> reverseOrder(Comparator<T> arg0);
    static <T> Enumeration<T> enumeration(Collection<T> arg0);
    static <T> ArrayList<T> list(Enumeration<T> arg0);
    static int frequency(Collection<?> arg0, Object arg1);
    static boolean disjoint(Collection<?> arg0, Collection<?> arg1);
    static <T> boolean addAll(Collection<? super T> arg0, T[] arg1);
    static <E> Set<E> newSetFromMap(Map<E,Boolean> arg0);
    static <T> Queue<T> asLifoQueue(Deque<T> arg0);
        static <T> Set<T> synchronizedSet(Set<T> arg0, Object arg1);
        static <T> List<T> synchronizedList(List<T> arg0, Object arg1);
        static void swap(Object[] arg0, int arg1, int arg2);
}

interface Comparator<T> {
    
    int compare( T arg0,  T arg1);
    boolean equals(Object arg0);
}

@PolyFlowReceiver       
class Date implements Serializable, Cloneable, Comparable<Date> {
    Date();
    Date(long arg0);
    Date(int arg0, int arg1, int arg2);
    Date(int arg0, int arg1, int arg2, int arg3, int arg4);
    Date(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    Date(String arg0);
    Object clone();
    static long UTC(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    static long parse(String arg0);
    int getYear();
    void setYear(int arg0);
    int getMonth();
    void setMonth(int arg0);
    int getDate();
    void setDate(int arg0);
    int getDay();
    int getHours();
    void setHours(int arg0);
    int getMinutes();
    void setMinutes(int arg0);
    int getSeconds();
    void setSeconds(int arg0);
    long getTime();
    void setTime(long arg0);
    boolean before(Date arg0);
    boolean after(Date arg0);
    boolean equals(Object arg0);
    int compareTo(Date arg0);
    int hashCode();
    String toString();
    String toLocaleString();
    String toGMTString();
    int getTimezoneOffset();
}

interface Deque<E> extends Queue<E> {
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E getFirst();
    E getLast();
    E peekFirst();
    E peekLast();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
    void push(E arg0);
    E pop();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int size();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
}

interface Enumeration<E> {
    boolean hasMoreElements();
    E nextElement();
}


class EnumMap<K, V> extends AbstractMap<K,V> implements Serializable, Cloneable {
    EnumMap(Class<K> arg0);
    EnumMap(EnumMap<K,? extends V> arg0);
    EnumMap(Map<K,? extends V> arg0);
    int size();
    boolean containsValue(Object arg0);
    boolean containsKey(Object arg0);
    V get(Object arg0);
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    boolean equals(Object arg0);
    int hashCode();
    EnumMap<K,V> clone();
}

class EnumSet<E> extends AbstractSet<E> implements Cloneable, Serializable {
    static <E> EnumSet<E> noneOf(Class<E> arg0);
    static <E> EnumSet<E> allOf(Class<E> arg0);
    static <E> EnumSet<E> copyOf(EnumSet<E> arg0);
    static <E> EnumSet<E> copyOf(Collection<E> arg0);
    static <E> EnumSet<E> complementOf(EnumSet<E> arg0);
    static <E> EnumSet<E> of(E arg0);
    static <E> EnumSet<E> of(E arg0, E arg1);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2, E arg3);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2, E arg3, E arg4);
    static <E> EnumSet<E> of(E arg0, E[] arg1);
    static <E> EnumSet<E> range(E arg0, E arg1);
    EnumSet<E> clone();
}

@PolyFlowReceiver
class Formatter{
        Formatter format(String arg0, Object[] arg1);
        Formatter(Appendable arg0);
        String toString();
}

@PolyFlowReceiver
class GregorianCalendar extends Calendar {
    final int BC;
    final int AD;
    GregorianCalendar();
    GregorianCalendar(TimeZone arg0);
    GregorianCalendar(Locale arg0);
    GregorianCalendar(TimeZone arg0, Locale arg1);
    GregorianCalendar(int arg0, int arg1, int arg2);
    GregorianCalendar(int arg0, int arg1, int arg2, int arg3, int arg4);
    GregorianCalendar(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    void setGregorianChange(Date arg0);
    Date getGregorianChange();
    boolean isLeapYear(int arg0);
    boolean equals(Object arg0);
    int hashCode();
    void add(int arg0, int arg1);
    void roll(int arg0, boolean arg1);
    void roll(int arg0, int arg1);
    int getMinimum(int arg0);
    int getMaximum(int arg0);
    int getGreatestMinimum(int arg0);
    int getLeastMaximum(int arg0);
    int getActualMinimum(int arg0);
    int getActualMaximum(int arg0);
    Object clone();
    TimeZone getTimeZone();
    void setTimeZone(TimeZone arg0);
    boolean isWeekDateSupported();
    int getWeekYear();
    void setWeekDate(int arg0, int arg1, int arg2);
    int getWeeksInWeekYear();
    protected void computeFields();
    protected void computeTime();
}

class HashMap<K, V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
    HashMap(int arg0, float arg1);
    HashMap(int arg0);
    HashMap();
    HashMap(Map<? extends K,? extends V> arg0);
    int size() ;
    boolean isEmpty();
    V get(Object arg0);
    boolean containsKey(Object arg0);
    V put(K arg0, V arg1);
    void putAll(Map<? extends K,? extends V> arg0);
    V remove(Object arg0);
    void clear();
    boolean containsValue(Object arg0);
    Object clone();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
}

class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable {
    HashSet();
    HashSet(Collection<? extends E> arg0);
    HashSet(int arg0, float arg1);
    HashSet(int arg0);
    Iterator<E> iterator();
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    void clear();
    Object clone();
}

class Hashtable<K, V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, Serializable {
    Hashtable(int arg0, float arg1);
    Hashtable(int arg0);
    Hashtable();
    Hashtable(Map<? extends K,? extends V> arg0);
    int size();
    boolean isEmpty();
    Enumeration<K> keys();
    Enumeration<V> elements();
    boolean contains(Object arg0);
    boolean containsValue(Object arg0);
    boolean containsKey(Object arg0);
    V get(Object arg0);
    protected void rehash();
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    Object clone();
    String toString();
    Set<K> keySet();
    Set<Entry<K,V>> entrySet();
    Collection<V> values();
    boolean equals(Object arg0);
    int hashCode();
}


interface Iterator<E> {
//Added by smillst
    boolean hasNext();
    E next();
    void remove();
}

class LinkedHashMap<K, V> extends HashMap<K,V> implements Map<K,V> {
    LinkedHashMap(int arg0, float arg1);
    LinkedHashMap(int arg0);
    LinkedHashMap();
    LinkedHashMap(Map<? extends K,? extends V> arg0);
    LinkedHashMap(int arg0, float arg1, boolean arg2);
    boolean containsValue(Object arg0);
    V get(Object arg0);
    void clear();
    protected boolean removeEldestEntry(Entry<K,V> arg0);
}

class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, Serializable {
    LinkedHashSet(int arg0, float arg1);
    LinkedHashSet(int arg0);
    LinkedHashSet();
    LinkedHashSet(Collection<? extends E> arg0);
}


class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable {
    LinkedList();
    LinkedList(Collection<? extends E> arg0);
    E getFirst();
    E getLast();
    E removeFirst();
    E removeLast();
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean contains(Object arg0);
    int size();
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean addAll(int arg0, Collection<? extends E> arg1);
    void clear();
    E get(int arg0);
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    E remove(int arg0);
    int indexOf(Object arg0);
    int lastIndexOf(Object arg0);
    E peek();
    E element();
    E poll();
    E remove();
    boolean offer(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E peekFirst();
    E peekLast();
    E pollFirst();
    E pollLast();
    void push(E arg0);
    E pop();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    ListIterator<E> listIterator(int arg0);
    Iterator<E> descendingIterator();
    Object clone();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
}

interface List<E> {
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean contains(Object arg0);
    Iterator<@PolySource @PolySink E> iterator(@PolySource @PolySink List<E> this);
    @PolyFlowReceiver
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    @PolyFlowReceiver
    boolean add(E arg0);
    @PolyFlowReceiver
    boolean remove(Object arg0);
    @PolyFlowReceiver
    boolean containsAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean addAll(Collection<? extends E> arg0);
    @PolyFlowReceiver
    boolean addAll(int arg0, Collection<? extends E> arg1);
    @PolyFlowReceiver
    boolean removeAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean retainAll(Collection<?> arg0);
    void clear();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
    E get(int arg0);
    @PolyFlowReceiver
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    @PolyFlowReceiver
    E remove(int arg0);
    @PolyFlowReceiver
    int indexOf(Object arg0);
    @PolyFlowReceiver
    int lastIndexOf(Object arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator();
    @PolyFlowReceiver
    ListIterator<E> listIterator(int arg0);
    @PolyFlowReceiver
    List<E> subList(int arg0, int arg1);
}

@PolyFlowReceiver
interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E arg0);
    void add(E arg0);
}

@PolyFlowReceiver
class Locale implements Cloneable, Serializable {
//Added by pbsf
    final Locale ENGLISH;
    final Locale FRENCH;
    final Locale GERMAN;
    final Locale ITALIAN;
    final Locale JAPANESE;
    final Locale KOREAN;
    final Locale CHINESE;
    final Locale SIMPLIFIED_CHINESE;
    final Locale TRADITIONAL_CHINESE;
    final Locale FRANCE;
    final Locale GERMANY;
    final Locale ITALY;
    final Locale JAPAN;
    final Locale KOREA;
    final Locale CHINA;
    final Locale PRC;
    final Locale TAIWAN;
    final Locale UK;
    final Locale US;
    final Locale CANADA;
    final Locale CANADA_FRENCH;
    final Locale ROOT;
    final char PRIVATE_USE_EXTENSION;
    final char UNICODE_LOCALE_EXTENSION;
    Locale(String arg0, String arg1, String arg2);
    Locale(String arg0, String arg1);
    Locale(String arg0);
    static Locale getDefault();
    static Locale getDefault(Category arg0);
    static void setDefault(Locale arg0);
    static void setDefault(Category arg0, Locale arg1);
    static Locale[] getAvailableLocales();
    static String[] getISOCountries();
    static String[] getISOLanguages();
    String getLanguage();
    String getScript();
    String getCountry();
    String getVariant();
    String getExtension(char arg0);
    Set<Character> getExtensionKeys();
    Set<String> getUnicodeLocaleAttributes();
    String getUnicodeLocaleType(String arg0);
    Set<String> getUnicodeLocaleKeys();
    String toString();
    String toLanguageTag();
    static Locale forLanguageTag(String arg0);
    String getISO3Language() throws MissingResourceException;
    String getISO3Country() throws MissingResourceException;
    String getDisplayLanguage();
    String getDisplayLanguage(Locale arg0);
    String getDisplayScript();
    String getDisplayScript(Locale arg0);
    String getDisplayCountry();
    String getDisplayCountry(Locale arg0);
    String getDisplayVariant();
    String getDisplayVariant(Locale arg0);
    String getDisplayName();
    String getDisplayName(Locale arg0);
    Object clone();
    int hashCode();
    boolean equals(Object arg0);
}

@PolyFlowReceiver
class Locale$Builder {
//Added by pbsf
    Builder();
    Builder setLocale(Locale arg0);
    Builder setLanguageTag(String arg0);
    Builder setLanguage(String arg0);
    Builder setScript(String arg0);
    Builder setRegion(String arg0);
    Builder setVariant(String arg0);
    Builder setExtension(char arg0, String arg1);
    Builder setUnicodeLocaleKeyword(String arg0, String arg1);
    Builder addUnicodeLocaleAttribute(String arg0);
    Builder removeUnicodeLocaleAttribute(String arg0);
    Builder clear();
    Builder clearExtensions();
    Locale build();
}

interface Map<K, V> {
//Added by smillst
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean containsKey(@PolySource @PolySink Map<K, V> this, @PolySource @PolySink Object arg0);
    @PolyFlowReceiver
    boolean containsValue(Object arg0);
    V get(Object arg0);
    V put(K arg0, V arg1);
    @PolyFlowReceiver
    V remove(Object arg0);
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
}
interface Map$Entry<K, V> {
//Added by smillst
@PolyFlowReceiver
    K getKey();
    @PolyFlowReceiver
    V getValue();
    @PolyFlowReceiver
    V setValue(V arg0);
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
}


interface NavigableMap<K, V> extends SortedMap<K,V> {
//Added by pbsf
@PolyFlowReceiver
    Entry<K,V> lowerEntry(K arg0);
    @PolyFlowReceiver
    K lowerKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> floorEntry(K arg0);
    @PolyFlowReceiver
    K floorKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> ceilingEntry(K arg0);
    @PolyFlowReceiver
    K ceilingKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> higherEntry(K arg0);
    @PolyFlowReceiver
    K higherKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> firstEntry();
    @PolyFlowReceiver
    Entry<K,V> lastEntry();
    @PolyFlowReceiver
    Entry<K,V> pollFirstEntry();
    @PolyFlowReceiver
    Entry<K,V> pollLastEntry();
    @PolyFlowReceiver
    NavigableMap<K,V> descendingMap();
    @PolyFlowReceiver
    NavigableSet<K> navigableKeySet();
    @PolyFlowReceiver
    NavigableSet<K> descendingKeySet();
    @PolyFlowReceiver
    NavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    @PolyFlowReceiver
    NavigableMap<K,V> headMap(K arg0, boolean arg1);
    @PolyFlowReceiver
    NavigableMap<K,V> tailMap(K arg0, boolean arg1);
    @PolyFlowReceiver
    SortedMap<K,V> subMap(K arg0, K arg1);
    @PolyFlowReceiver
    SortedMap<K,V> headMap(K arg0);
    @PolyFlowReceiver
    SortedMap<K,V> tailMap(K arg0);
}

@PolyFlowReceiver
interface NavigableSet<E> extends SortedSet<E> {
    E lower(E arg0);
    E floor(E arg0);
    E ceiling(E arg0);
    E higher(E arg0);
    E pollFirst();
    E pollLast();
    Iterator<E> iterator();
    NavigableSet<E> descendingSet();
    Iterator<E> descendingIterator();
    NavigableSet<E> subSet(E arg0, boolean arg1, E arg2, boolean arg3);
    NavigableSet<E> headSet(E arg0, boolean arg1);
    NavigableSet<E> tailSet(E arg0, boolean arg1);
    SortedSet<E> subSet(E arg0, E arg1);
    SortedSet<E> headSet(E arg0);
    SortedSet<E> tailSet(E arg0);
}

class NoSuchElementException{
            NoSuchElementException();
}

@PolyFlowReceiver
interface Queue<E> extends Collection<E> {
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
}

class Random implements Serializable {
    Random();
    Random(long arg0);
    void setSeed(long arg0);
    protected int next(int arg0);
    void nextBytes(byte[] arg0);
    @Source(RANDOM) int nextInt() ;
   @Source(RANDOM)  int nextInt(int arg0) ;
    @Source(RANDOM) long nextLong() ;
   @Source(RANDOM)  boolean nextBoolean() ;
    @Source(RANDOM) float nextFloat() ;
    @Source(RANDOM) double nextDouble();
    @Source(RANDOM) double nextGaussian();
}

@PolyFlowReceiver
class ResourceBundle {
    protected ResourceBundle parent;
    ResourceBundle();
    String getString(String arg0);
    String[] getStringArray(String arg0);
    Object getObject(String arg0);
    Locale getLocale();
    protected void setParent(ResourceBundle arg0);
    static ResourceBundle getBundle(String arg0);
    static ResourceBundle getBundle(String arg0, Control arg1);
    static ResourceBundle getBundle(String arg0, Locale arg1);
    static ResourceBundle getBundle(String arg0, Locale arg1, Control arg2);
    static ResourceBundle getBundle(String arg0, Locale arg1, ClassLoader arg2);
    static ResourceBundle getBundle(String arg0, Locale arg1, ClassLoader arg2, Control arg3);
    static void clearCache();
    static void clearCache(ClassLoader arg0);
    protected Object handleGetObject(String arg0);
    Enumeration<String> getKeys();
    boolean containsKey(String arg0);
    Set<String> keySet();
    protected Set<String> handleKeySet();
}

@PolyFlowReceiver
class ResourceBundle$Control {
    final List<String> FORMAT_DEFAULT;
    final List<String> FORMAT_CLASS;
    final List<String> FORMAT_PROPERTIES;
    final long TTL_DONT_CACHE;
    final long TTL_NO_EXPIRATION_CONTROL;
    protected Control();
    static Control getControl(List<String> arg0);
    static Control getNoFallbackControl(List<String> arg0);
    List<String> getFormats(String arg0);
    List<Locale> getCandidateLocales(String arg0, Locale arg1);
    Locale getFallbackLocale(String arg0, Locale arg1);
    ResourceBundle newBundle(String arg0, Locale arg1, String arg2, ClassLoader arg3, boolean arg4) throws IllegalAccessException,InstantiationException,IOException;
    long getTimeToLive(String arg0, Locale arg1);
    boolean needsReload(String arg0, Locale arg1, String arg2, ClassLoader arg3, ResourceBundle arg4, long arg5);
    String toBundleName(String arg0, Locale arg1);
    String toResourceName(String arg0, String arg1);
}

@PolyFlowReceiver
class Scanner implements Iterator<String>, Closeable {
    Scanner(Readable arg0);
    Scanner(InputStream arg0);
    Scanner(InputStream arg0, String arg1);
    Scanner(File arg0) throws FileNotFoundException;
    Scanner(File arg0, String arg1) throws FileNotFoundException;
    Scanner(Path arg0) throws IOException;
    Scanner(Path arg0, String arg1) throws IOException;
    Scanner(String arg0);
    Scanner(ReadableByteChannel arg0);
    Scanner(ReadableByteChannel arg0, String arg1);
    void close();
    IOException ioException();
    Pattern delimiter();
    Scanner useDelimiter(Pattern arg0);
    Scanner useDelimiter(String arg0);
    Locale locale();
    Scanner useLocale(Locale arg0);
    int radix();
    Scanner useRadix(int arg0);
    MatchResult match();
    String toString();
    boolean hasNext();
    String next();
    void remove();
    boolean hasNext(String arg0);
    String next(String arg0);
    boolean hasNext(Pattern arg0);
    String next(Pattern arg0);
    boolean hasNextLine();
    String nextLine();
    String findInLine(String arg0);
    String findInLine(Pattern arg0);
    String findWithinHorizon(String arg0, int arg1);
    String findWithinHorizon(Pattern arg0, int arg1);
    Scanner skip(Pattern arg0);
    Scanner skip(String arg0);
    boolean hasNextBoolean();
    boolean nextBoolean();
    boolean hasNextByte();
    boolean hasNextByte(int arg0);
    byte nextByte();
    byte nextByte(int arg0);
    boolean hasNextShort();
    boolean hasNextShort(int arg0);
    short nextShort();
    short nextShort(int arg0);
    boolean hasNextInt();
    boolean hasNextInt(int arg0);
    int nextInt();
    int nextInt(int arg0);
    boolean hasNextLong();
    boolean hasNextLong(int arg0);
    long nextLong();
    long nextLong(int arg0);
    boolean hasNextFloat();
    float nextFloat();
    boolean hasNextDouble();
    double nextDouble();
    boolean hasNextBigInteger();
    boolean hasNextBigInteger(int arg0);
    BigInteger nextBigInteger();
    BigInteger nextBigInteger(int arg0);
    boolean hasNextBigDecimal();
    BigDecimal nextBigDecimal();
    Scanner reset();
}

@PolyFlowReceiver
interface Set<E> extends Collection<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean retainAll(Collection<?> arg0);
    boolean removeAll(Collection<?> arg0);
    void clear();
    boolean equals(Object arg0);
    int hashCode();
}

@PolyFlowReceiver
interface SortedMap<K, V> extends Map<K,V> {
    Comparator<? super K> comparator();
    SortedMap<K,V> subMap(K arg0, K arg1);
    SortedMap<K,V> headMap(K arg0);
    SortedMap<K,V> tailMap(K arg0);
    K firstKey();
    K lastKey();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
}

@PolyFlowReceiver
interface SortedSet<E> extends Set<E> {
    Comparator<? super E> comparator();
    SortedSet<E> subSet(E arg0, E arg1);
    SortedSet<E> headSet(E arg0);
    SortedSet<E> tailSet(E arg0);
    E first();
    E last();
}

@PolyFlowReceiver
class Stack<E> extends Vector<E> {
    Stack();
    E push(E arg0);
    E pop();
    E peek();
    boolean empty();
    int search(Object arg0);
}

@PolyFlowReceiver
class StringTokenizer implements Enumeration<Object> {
//Added by pbsf
    StringTokenizer(String arg0, String arg1, boolean arg2);
    StringTokenizer(String arg0, String arg1);
    StringTokenizer(String arg0);
    boolean hasMoreTokens();
    String nextToken();
    String nextToken(String arg0);
    boolean hasMoreElements();
    Object nextElement();
    int countTokens();
}

class Timer{
        void schedule(TimerTask arg0, long arg1, long arg2);
        Timer();
        void schedule(TimerTask arg0, long arg1);
        void cancel();
        void scheduleAtFixedRate(TimerTask arg0, long arg1, long arg2);
        void schedule(TimerTask arg0, Date arg1, long arg2);
        void schedule(TimerTask arg0, Date arg1);
}

class TimerTask{
        protected TimerTask();
        void run();
        boolean cancel();
}

@PolyFlowReceiver
class TimeZone implements Serializable, Cloneable {
    final int SHORT;
    final int LONG;
    TimeZone();
    int getOffset(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    int getOffset(long arg0);
    void setRawOffset(int arg0);
    int getRawOffset();
    String getID();
    void setID(String arg0);
    String getDisplayName();
    String getDisplayName(Locale arg0);
    String getDisplayName(boolean arg0, int arg1);
    String getDisplayName(boolean arg0, int arg1, Locale arg2);
    int getDSTSavings();
    boolean useDaylightTime();
    boolean observesDaylightTime();
    boolean inDaylightTime(Date arg0);
    static TimeZone getTimeZone(String arg0);
    static String[] getAvailableIDs(int arg0);
    static String[] getAvailableIDs();
    static TimeZone getDefault();
    static void setDefault(TimeZone arg0);
    boolean hasSameRules(TimeZone arg0);
    Object clone();
    static TimeZone getTimeZone(String arg0, boolean arg1);
}

@PolyFlowReceiver
class TreeSet<E> {
TreeSet();
boolean add(E arg0);
boolean remove(Object arg0);
int size();
Iterator<E> iterator();
}

class WeakHashMap<K,V> {
V get(Object arg0);
V put(K arg0, V arg1);
}

@PolyFlowReceiver
class TreeMap<K, V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable {
    TreeMap();
    TreeMap(Comparator<? super K> arg0);
    TreeMap(Map<? extends K,? extends V> arg0);
    TreeMap(SortedMap<K,? extends V> arg0);
    int size();
    boolean containsKey(Object arg0);
    boolean containsValue(Object arg0);
    V get(Object arg0);
    Comparator<? super K> comparator();
    K firstKey();
    K lastKey();
    void putAll(Map<? extends K,? extends V> arg0);
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void clear();
    Object clone();
    Entry<K,V> firstEntry();
    Entry<K,V> lastEntry();
    Entry<K,V> pollFirstEntry();
    Entry<K,V> pollLastEntry();
    Entry<K,V> lowerEntry(K arg0);
    K lowerKey(K arg0);
    Entry<K,V> floorEntry(K arg0);
    K floorKey(K arg0);
    Entry<K,V> ceilingEntry(K arg0);
    K ceilingKey(K arg0);
    Entry<K,V> higherEntry(K arg0);
    K higherKey(K arg0);
    Set<K> keySet();
    NavigableSet<K> navigableKeySet();
    NavigableSet<K> descendingKeySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    NavigableMap<K,V> descendingMap();
    NavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    NavigableMap<K,V> headMap(K arg0, boolean arg1);
    NavigableMap<K,V> tailMap(K arg0, boolean arg1);
    SortedMap<K,V> subMap(K arg0, K arg1);
    SortedMap<K,V> headMap(K arg0);
    SortedMap<K,V> tailMap(K arg0);
}

class UUID{
    static UUID fromString(String arg0);
}

@PolyFlowReceiver
class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    protected Object[] elementData;
    protected int elementCount;
    protected int capacityIncrement;
    Vector(int arg0, int arg1);
    Vector(int arg0);
    Vector();
    Vector(Collection<? extends E> arg0);
    void copyInto(Object[] arg0);
    void trimToSize();
    void ensureCapacity(int arg0);
    void setSize(int arg0);
    int capacity();
    int size();
    boolean isEmpty();
    Enumeration<E> elements();
    boolean contains(Object arg0);
    int indexOf(Object arg0);
    int indexOf(Object arg0, int arg1);
    int lastIndexOf(Object arg0);
    int lastIndexOf(Object arg0, int arg1);
    E elementAt(int arg0);
    E firstElement();
    E lastElement();
    void setElementAt(E arg0, int arg1);
    void removeElementAt(int arg0);
    void insertElementAt(E arg0, int arg1);
    void addElement(E arg0);
    boolean removeElement(Object arg0);
    void removeAllElements();
    Object clone();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    E get(int arg0);
    E set(int arg0, E arg1);
    boolean add(E arg0);
    boolean remove(Object arg0);
    void add(int arg0, E arg1);
    E remove(int arg0);
    void clear();
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    boolean addAll(int arg0, Collection<? extends E> arg1);
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    List<E> subList(int arg0, int arg1);
    protected void removeRange(int arg0, int arg1);
    ListIterator<E> listIterator(int arg0);
    ListIterator<E> listIterator();
    Iterator<E> iterator();
}

package java.util.concurrent;

class Semaphore {
void acquire() throws InterruptedException;
void acquire(int arg0) throws InterruptedException;
void release();
void release(int arg0);
}

class Executors {
static ScheduledExecutorService newSingleThreadScheduledExecutor();
static ExecutorService newFixedThreadPool(int arg0, ThreadFactory arg1);
static ExecutorService newFixedThreadPool(int arg0);
}

class CopyOnWriteArrayList<E> {
boolean add(E arg0);
boolean remove(Object arg0);
E remove(int arg0);
int size();
Iterator<E> iterator();
void add(int arg0, E arg1);
}

class ThreadPoolExecutor{
        ThreadPoolExecutor(int arg0, int arg1, long arg2, TimeUnit arg3, BlockingQueue<Runnable> arg4, ThreadFactory arg5);
        boolean remove(Runnable arg0);
        void execute(Runnable arg0);
        void setCorePoolSize(int arg0);
}
class FutureTask<V> {
        protected void done();
        boolean isCancelled();
        V get() throws InterruptedException,ExecutionException;
        V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
        FutureTask(Callable<V> arg0);
        boolean cancel(boolean arg0);
}
class Callable<V>{
        V call() throws Exception;
}
class ThreadFactory{
        Thread newThread(Runnable arg0);
}

@PolyFlowReceiver
interface BlockingDeque<E> extends BlockingQueue<E>, Deque<E> {
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    void putFirst(E arg0) throws InterruptedException;
    void putLast(E arg0) throws InterruptedException;
    boolean offerFirst(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offerLast(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E takeFirst() throws InterruptedException;
    E takeLast() throws InterruptedException;
    E pollFirst(long arg0, TimeUnit arg1) throws InterruptedException;
    E pollLast(long arg0, TimeUnit arg1) throws InterruptedException;
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E remove();
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E element();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int size();
    Iterator<E> iterator();
    void push(E arg0);
}

@PolyFlowReceiver
interface BlockingQueue<E> extends Queue<E> {
//Added by pbsf
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    int remainingCapacity();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
}

class ConcurrentHashMap<K, V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {
//Added by pbsf
    ConcurrentHashMap(int arg0, float arg1, int arg2);
    ConcurrentHashMap(int arg0, float arg1);
    ConcurrentHashMap(int arg0);
    ConcurrentHashMap();
    ConcurrentHashMap(Map<? extends K,? extends V> arg0);
    boolean isEmpty();
    int size();
    V get(Object arg0);
    boolean containsKey(Object arg0);
    boolean containsValue(Object arg0);
    boolean contains(Object arg0);
    V put(K arg0, V arg1);
    V putIfAbsent(K arg0, V arg1);
    void putAll(Map<? extends K,? extends V> arg0);
    V remove(Object arg0);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
    void clear();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    Enumeration<K> keys();
    Enumeration<V> elements();
}

@PolyFlowReceiver
class ConcurrentLinkedQueue<E> extends AbstractQueue<E> implements Queue<E>, Serializable {
//Added by pbsf
    ConcurrentLinkedQueue();
    ConcurrentLinkedQueue(Collection<? extends E> arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E poll();
    E peek();
    boolean isEmpty();
    int size();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    Iterator<E> iterator();
}

@PolyFlowReceiver
interface ConcurrentMap<K, V> extends Map<K,V> {
//Added by pbsf
    V putIfAbsent(K arg0, V arg1);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
}

@PolyFlowReceiver
class CountDownLatch {
//Added by pbsf
    CountDownLatch(int arg0);
    void await() throws InterruptedException;
    boolean await(long arg0, TimeUnit arg1) throws InterruptedException;
    void countDown();
    long getCount();
    String toString();
}

@PolyFlowReceiver
interface Future<V> {
//Added by pbsf
    boolean cancel(boolean arg0);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException,ExecutionException;
    V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
}
class Executor{
            void execute(Runnable arg0);
}


@PolyFlowReceiver
interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long arg0, TimeUnit arg1) throws InterruptedException;
    <T> Future<T> submit(Callable<T> arg0);
    <T> Future<T> submit(Runnable arg0, T arg1);
    Future<?> submit(Runnable arg0);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0) throws InterruptedException,ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException,ExecutionException,TimeoutException;
}

@PolyFlowReceiver
class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
//Added by pbsf
    LinkedBlockingQueue();
    LinkedBlockingQueue(int arg0);
    LinkedBlockingQueue(Collection<? extends E> arg0);
    int size();
    int remainingCapacity();
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offer(E arg0);
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E poll();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    String toString();
    void clear();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    Iterator<E> iterator();
}

@PolyFlowReceiver
interface ScheduledExecutorService extends ExecutorService {
    ScheduledFuture<?> schedule(Runnable arg0, long arg1, TimeUnit arg2);
    <V> ScheduledFuture<V> schedule(Callable<V> arg0, long arg1, TimeUnit arg2);
    ScheduledFuture<?> scheduleAtFixedRate(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
}

enum TimeUnit {
    DAYS, HOURS, MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS, SECONDS;
        long toMillis(long arg0);
}

package java.util.concurrent.atomic;

class AtomicBoolean{
        AtomicBoolean();
        boolean get();
        void set(boolean arg0);
        AtomicBoolean(boolean arg0);
        @PolySource @PolySink boolean getAndSet(@PolySource @PolySink boolean arg0);
}

@PolyFlowReceiver
class AtomicInteger extends Number implements Serializable {
//Added by pbsf
    AtomicInteger(int arg0);
    AtomicInteger();
    int get();
    void set(int arg0);
    void lazySet(int arg0);
    int getAndSet(int arg0);
    boolean compareAndSet(int arg0, int arg1);
    boolean weakCompareAndSet(int arg0, int arg1);
    int getAndIncrement();
    int getAndDecrement();
    int getAndAdd(int arg0);
    int incrementAndGet();
    int decrementAndGet();
    int addAndGet(int arg0);
    String toString();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
}

@PolyFlowReceiver
class AtomicLong extends Number implements Serializable {
//Added by pbsf
    AtomicLong(long arg0);
    AtomicLong();
    long get();
    void set(long arg0);
    void lazySet(long arg0);
    long getAndSet(long arg0);
    boolean compareAndSet(long arg0, long arg1);
    boolean weakCompareAndSet(long arg0, long arg1);
    long getAndIncrement();
    long getAndDecrement();
    long getAndAdd(long arg0);
    long incrementAndGet();
    long decrementAndGet();
    long addAndGet(long arg0);
    String toString();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
}

@PolyFlowReceiver
class AtomicLongArray implements Serializable {
//Added by pbsf
    AtomicLongArray(int arg0);
    AtomicLongArray(long[] arg0);
    int length();
    long get(int arg0);
    void set(int arg0, long arg1);
    void lazySet(int arg0, long arg1);
    long getAndSet(int arg0, long arg1);
    boolean compareAndSet(int arg0, long arg1, long arg2);
    boolean weakCompareAndSet(int arg0, long arg1, long arg2);
    long getAndIncrement(int arg0);
    long getAndDecrement(int arg0);
    long getAndAdd(int arg0, long arg1);
    long incrementAndGet(int arg0);
    long decrementAndGet(int arg0);
    long addAndGet(int arg0, long arg1);
    String toString();
}

@PolyFlowReceiver
class AtomicReference<V> implements Serializable {
//Added by pbsf
    AtomicReference(V arg0);
    AtomicReference();
    V get();
    void set(V arg0);
    void lazySet(V arg0);
    boolean compareAndSet(V arg0, V arg1);
    boolean weakCompareAndSet(V arg0, V arg1);
    V getAndSet(V arg0);
    String toString();
}

@PolyFlowReceiver
class AtomicReferenceArray<E> implements Serializable {
//Added by pbsf
    AtomicReferenceArray(int arg0);
    AtomicReferenceArray(E[] arg0);
    int length();
    E get(int arg0);
    void set(int arg0, E arg1);
    void lazySet(int arg0, E arg1);
    E getAndSet(int arg0, E arg1);
    boolean compareAndSet(int arg0, E arg1, E arg2);
    boolean weakCompareAndSet(int arg0, E arg1, E arg2);
    String toString();
}

package java.util.concurrent.locks;



@PolyFlowReceiver
class ReentrantLock {
void lock();
void unlock();
}

@PolyFlowReceiver
interface Lock {
//Added by pbsf
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long arg0, TimeUnit arg1) throws InterruptedException;
    void unlock();
    Condition newCondition();
}

package java.util.logging;

@PolyFlowReceiver
class Logger {
//Added by pbsf
    final String GLOBAL_LOGGER_NAME;
    final Logger global;
    static Logger getGlobal();
    protected Logger(String arg0, String arg1);
    static Logger getLogger(String arg0);
    static Logger getLogger(String arg0, String arg1);
    static Logger getAnonymousLogger();
    static Logger getAnonymousLogger(String arg0);
    ResourceBundle getResourceBundle();
    String getResourceBundleName();
    void setFilter(Filter arg0) throws SecurityException;
    Filter getFilter();
    void log(LogRecord arg0);
    void log(Level arg0, String arg1);
    void log(Level arg0, String arg1, Object arg2);
    void log(Level arg0, String arg1, Object[] arg2);
    void log(Level arg0, String arg1, Throwable arg2);
    void logp(Level arg0, String arg1, String arg2, String arg3);
    void logp(Level arg0, String arg1, String arg2, String arg3, Object arg4);
    void logp(Level arg0, String arg1, String arg2, String arg3, Object[] arg4);
    void logp(Level arg0, String arg1, String arg2, String arg3, Throwable arg4);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Object arg5);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Object[] arg5);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Throwable arg5);
    void entering(String arg0, String arg1);
    void entering(String arg0, String arg1, Object arg2);
    void entering(String arg0, String arg1, Object[] arg2);
    void exiting(String arg0, String arg1);
    void exiting(String arg0, String arg1, Object arg2);
    void throwing(String arg0, String arg1, Throwable arg2);
    void severe(String arg0);
    void warning(String arg0);
    void info(String arg0);
    void config(String arg0);
    void fine(String arg0);
    void finer(String arg0);
    void finest(String arg0);
    void setLevel(Level arg0) throws SecurityException;
    Level getLevel();
    boolean isLoggable(Level arg0);
    String getName();
    void addHandler(Handler arg0) throws SecurityException;
    void removeHandler(Handler arg0) throws SecurityException;
    Handler[] getHandlers();
    void setUseParentHandlers(boolean arg0);
    boolean getUseParentHandlers();
    Logger getParent();
    void setParent(Logger arg0);
}

package java.util.regex;
class Matcher{
            Matcher usePattern(Pattern arg0);
            boolean lookingAt();
            int regionStart();
            Matcher region(int arg0, int arg1);
            int regionEnd();
}
class Pattern implements Serializable {
    final int UNIX_LINES;
    final int CASE_INSENSITIVE;
    final int COMMENTS;
    final int MULTILINE;
    final int LITERAL;
    final int DOTALL;
    final int UNICODE_CASE;
    final int CANON_EQ;
    final int UNICODE_CHARACTER_CLASS;
@PolyFlow
    static Pattern compile(String arg0);
@PolyFlow
    static Pattern compile(String arg0, int arg1);
@PolyFlowReceiver
    String pattern();
@PolyFlowReceiver
    String toString();
@PolyFlowReceiver
    Matcher matcher(CharSequence arg0);
    int flags();
@PolyFlow
    static boolean matches(String arg0, CharSequence arg1);
    @PolySource @PolySink String[] split(@PolySource @PolySink CharSequence arg0, int arg1);
    @PolySource @PolySink String[] split(@PolySource @PolySink CharSequence arg0);
@PolyFlow
    static String quote(String arg0);
}

package java.util.zip;

class Deflater {
boolean finished();
int deflate(byte[] arg0, int arg1, int arg2, int arg3);
int deflate(byte[] arg0, int arg1, int arg2);
int deflate(byte[] arg0);
static void end(long arg0);
void end();
void finish();
void setInput(byte[] arg0, int arg1, int arg2);
void setInput(byte[] arg0);
}

class Inflater {
int inflate(byte[] arg0, int arg1, int arg2) throws DataFormatException;
int inflate(byte[] arg0) throws DataFormatException;
void setInput(byte[] arg0, int arg1, int arg2);
void setInput(byte[] arg0);
}
class InflaterInputStream{
        int read(@Source(FILESYSTEM) byte @Source(FILESYSTEM) [] arg0, int arg1, int arg2) throws IOException;
        void close() throws IOException;
        @Source(FILESYSTEM) InflaterInputStream(InputStream arg0);
}

@PolyFlowReceiver
class DeflaterOutputStream{
        void close() throws IOException;
        @Sink(FILESYSTEM) DeflaterOutputStream(OutputStream arg0);
        void write(@Sink(FILESYSTEM) byte @Sink(FILESYSTEM) [] arg0, int arg1, int arg2) throws IOException;
}

@PolyFlowReceiver
class GZIPInputStream{
            GZIPInputStream(InputStream arg0) throws IOException;
            void close() throws IOException;
            int read(byte[] arg0, int arg1, int arg2) throws IOException;
            int read(byte[] arg0, int arg1, int arg2) throws IOException;
void close() throws IOException;
            
}

@PolyFlowReceiver
class GZIPOutputStream{
        void write(byte[] arg0, int arg1, int arg2) throws IOException;
        GZIPOutputStream(OutputStream arg0) throws IOException;
        void write(byte[] arg0, int arg1, int arg2) throws IOException;
}

@PolyFlowReceiver
class ZipOutputStream{
            void putNextEntry(ZipEntry arg0) throws IOException;
            void close() throws IOException;
            ZipOutputStream(OutputStream arg0);
            void closeEntry() throws IOException;
}
class ZipInputStream{
        @PolySource @PolySink ZipInputStream(@PolySource @PolySink InputStream arg0);
        @PolySourceR @PolySinkR ZipEntry getNextEntry(@PolySourceR @PolySinkR ZipInputStream this);
        int read(@PolySourceR @PolySinkR ZipInputStream this, @PolySourceR @PolySinkR byte[] arg0, int arg1, int arg2);
        void close() throws IOException;
}

class ZipEntry{
ZipEntry(String arg0);
boolean isDirectory();
String getName();
long getSize();
}

class ZipFile{
        void close() throws IOException;
        ZipEntry getEntry(String arg0);
        ZipFile(String arg0) throws IOException;
        InputStream getInputStream(ZipEntry arg0) throws IOException;
        Enumeration<? extends ZipEntry> entries();
}
