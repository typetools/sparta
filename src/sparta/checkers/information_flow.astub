import sparta.checkers.quals.*;
import sparta.checkers.quals.FlowPermission;
import static sparta.checkers.quals.FlowPermission.*;

/*
This file is generate by ant merge-stubfiles.
Please put annotations in the correct stub file in flowstubfiles.
*/
package android.accounts;
class AccountManager{
        AuthenticatorDescription[] getAuthenticatorTypes();
        void addOnAccountsUpdatedListener(OnAccountsUpdateListener listener, Handler handler, boolean updateImmediately);
        void removeOnAccountsUpdatedListener(OnAccountsUpdateListener listener);
        static AccountManager get(Context context);
}
public class Account implements Parcelable {
    public final @Source(GET_ACCOUNTS) String name;
}


class OnAccountsUpdateListener{
        void onAccountsUpdated(@Source(GET_ACCOUNTS) Account[] arg0);
}


package android.animation;
class ValueAnimator {

void addUpdateListener(ValueAnimator.AnimatorUpdateListener listener);
//Adds a listener to the set of listeners that are sent update events through the life of an animation.

void cancel();
//Cancels the animation.

ValueAnimator clone();
//Creates and returns a copy of this Object.

void end();
//Ends the animation.

float getAnimatedFraction();
//Returns the current animation fraction, which is the elapsed/interpolated fraction used in the most recent frame update on the animation.

Object getAnimatedValue();
//The most recent value calculated by this ValueAnimator when there is just one property being animated.

Object getAnimatedValue(String propertyName);
//The most recent value calculated by this ValueAnimator for propertyName.

long getCurrentPlayTime();
//Gets the current position of the animation in time, which is equal to the current time minus the time that the animation started.

long getDuration();
//Gets the length of the animation.

static long getFrameDelay();
//The amount of time, in milliseconds, between each frame of the animation.

TimeInterpolator getInterpolator();
//Returns the timing interpolator that this ValueAnimator uses.

int getRepeatCount();
//Defines how many times the animation should repeat.

int getRepeatMode();
//Defines what this animation should do when it reaches the end.

long getStartDelay();
//The amount of time, in milliseconds, to delay starting the animation after start(); is called.

PropertyValuesHolder[] getValues();
//Returns the values that this ValueAnimator animates between.

boolean isRunning();
//Returns whether this Animator is currently running (having been started and gone past any initial startDelay period and not yet ended);.

boolean isStarted();
//Returns whether this Animator has been started and not yet ended.

static ValueAnimator ofFloat(float... values);
//Constructs and returns a ValueAnimator that animates between float values.

static ValueAnimator ofInt(int... values);
//Constructs and returns a ValueAnimator that animates between int values.

static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values);
//Constructs and returns a ValueAnimator that animates between Object values.

static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values);
//Constructs and returns a ValueAnimator that animates between the values specified in the PropertyValuesHolder objects.

void removeAllUpdateListeners();
//Removes all listeners from the set listening to frame updates for this animation.

void removeUpdateListener(ValueAnimator.AnimatorUpdateListener listener);
//Removes a listener from the set listening to frame updates for this animation.

void reverse();
//Plays the ValueAnimator in reverse.

void setCurrentPlayTime(long playTime);
//Sets the position of the animation to the specified point in time.

ValueAnimator setDuration(long duration);
//Sets the length of the animation.

void setEvaluator(TypeEvaluator value);
//The type evaluator to be used when calculating the animated values of this animation.

void setFloatValues(float... values);
//Sets float values that will be animated between.

static void setFrameDelay(long frameDelay);
//The amount of time, in milliseconds, between each frame of the animation.

void setIntValues(int... values);
//Sets int values that will be animated between.

void setInterpolator(TimeInterpolator value);
//The time interpolator used in calculating the elapsed fraction of this animation.

void setObjectValues(Object... values);
//Sets the values to animate between for this animation.

void setRepeatCount(int value);
//Sets how many times the animation should be repeated.

void setRepeatMode(int value);
//Defines what this animation should do when it reaches the end.

void setStartDelay(long startDelay);
//The amount of time, in milliseconds, to delay starting the animation after start(); is called.

void setValues(PropertyValuesHolder... values);
//Sets the values, per property, being animated between.

void start() @Sink(DISPLAY);
//Starts this animation.

String toString();
//Returns a string containing a concise, human-readable description of this object.




}
class TimeInterpolator{
        float getInterpolation(float arg0);
}package android.annotation;
class TargetApi{
        int value();
}

package android.app;

class ActivityGroup{
            protected void onCreate(Bundle savedInstanceState);
}
class ActionBar {
    
abstract void addOnMenuVisibilityListener(ActionBar.OnMenuVisibilityListener listener);
//Add a listener that will respond to menu visibility change events.

abstract void addTab(@Sink(DISPLAY) ActionBar.Tab tab, @Sink(DISPLAY) boolean setSelected);
//Add a tab for use in tabbed navigation mode.

abstract void addTab(@Sink(DISPLAY) ActionBar.Tab tab, @Sink(DISPLAY) int position);
//Add a tab for use in tabbed navigation mode.

abstract void addTab(@Sink(DISPLAY) ActionBar.Tab tab, @Sink(DISPLAY) int position, @Sink(DISPLAY) boolean setSelected);
//Add a tab for use in tabbed navigation mode.

abstract void addTab(@Sink(DISPLAY) ActionBar.Tab tab);
//Add a tab for use in tabbed navigation mode.

abstract View getCustomView();

abstract int getDisplayOptions();

abstract int getHeight();
//Retrieve the current height of the ActionBar.

abstract int getNavigationItemCount();
//Get the number of navigation items present in the current navigation mode.

abstract int getNavigationMode();
//Returns the current navigation mode.

abstract int getSelectedNavigationIndex();
//Get the position of the selected navigation item in list or tabbed navigation modes.

abstract ActionBar.Tab getSelectedTab();
//Returns the currently selected tab if in tabbed navigation mode and there is at least one tab present.

abstract CharSequence getSubtitle();
//Returns the current ActionBar subtitle in standard mode.

abstract ActionBar.Tab getTabAt(int index);
//Returns the tab at the specified index.

abstract int getTabCount();
//Returns the number of tabs currently registered with the action bar.

Context getThemedContext();
//Returns a Context with an appropriate theme for creating views that will appear in the action bar.

abstract CharSequence getTitle();
//Returns the current ActionBar title in standard mode.

abstract void hide();
//Hide the ActionBar if it is currently showing.

abstract boolean isShowing();

abstract ActionBar.Tab newTab();
//Create and return a new ActionBar.Tab.

abstract void removeAllTabs();
//Remove all tabs from the action bar and deselect the current tab.

abstract void removeOnMenuVisibilityListener(ActionBar.OnMenuVisibilityListener listener);
//Remove a menu visibility listener.

abstract void removeTab(ActionBar.Tab tab);
//Remove a tab from the action bar.

abstract void removeTabAt(int position);
//Remove a tab from the action bar.

abstract void selectTab(@Sink(DISPLAY) ActionBar.Tab tab);
//Select the specified tab.

abstract void setBackgroundDrawable(Drawable d);
//Set the ActionBar's background.

abstract void setCustomView(int resId);
//Set the action bar into custom navigation mode, supplying a view for custom navigation.

abstract void setCustomView(@Sink(DISPLAY) View view);
//Set the action bar into custom navigation mode, supplying a view for custom navigation.

abstract void setCustomView(@Sink(DISPLAY) View view, ActionBar.LayoutParams layoutParams);
//Set the action bar into custom navigation mode, supplying a view for custom navigation.

abstract void setDisplayHomeAsUpEnabled(boolean showHomeAsUp);
//Set whether home should be displayed as an "up" affordance.

abstract void setDisplayOptions(int options, int mask);
//Set selected display options.

abstract void setDisplayOptions(int options);
//Set display options.

abstract void setDisplayShowCustomEnabled(boolean showCustom);
//Set whether a custom view should be displayed, if set.

abstract void setDisplayShowHomeEnabled(boolean showHome);
//Set whether to include the application home affordance in the action bar.

abstract void setDisplayShowTitleEnabled(boolean showTitle);
//Set whether an activity title/subtitle should be displayed.

abstract void setDisplayUseLogoEnabled(boolean useLogo);
//Set whether to display the activity logo rather than the activity icon.

void setHomeButtonEnabled(boolean enabled);
//Enable or disable the "home" button in the corner of the action bar.

abstract void setIcon(@Sink(DISPLAY) Drawable icon);
//Set the icon to display in the 'home' section of the action bar.

abstract void setIcon(int resId);
//Set the icon to display in the 'home' section of the action bar.

abstract void setListNavigationCallbacks(SpinnerAdapter adapter, ActionBar.OnNavigationListener callback);
//Set the adapter and navigation callback for list navigation mode.

abstract void setLogo(int resId);
//Set the logo to display in the 'home' section of the action bar.

abstract void setLogo(@Sink(DISPLAY) Drawable logo);
//Set the logo to display in the 'home' section of the action bar.

abstract void setNavigationMode(int mode);
//Set the current navigation mode.

abstract void setSelectedNavigationItem(int position);
//Set the selected navigation item in list or tabbed navigation modes.

void setSplitBackgroundDrawable(@Sink(DISPLAY) Drawable d);
//Set the ActionBar's split background.

void setStackedBackgroundDrawable(@Sink(DISPLAY) Drawable d);
//Set the ActionBar's stacked background.

abstract void setSubtitle(int resId);
//Set the action bar's subtitle.

abstract void setSubtitle(@Sink(DISPLAY) CharSequence subtitle);
//Set the action bar's subtitle.

abstract void setTitle(int resId);
//Set the action bar's title.

abstract void setTitle(@Sink(DISPLAY) CharSequence title);
//Set the action bar's title.

abstract void show() @Sink(DISPLAY);
//Show the ActionBar if it is not currently showing.



}

class ActionBar$Tab {
    
abstract CharSequence getContentDescription();
//Gets a brief description of this tab's content for use in accessibility support.

abstract View getCustomView();
//Retrieve a previously set custom view for this tab.

abstract Drawable getIcon();
//Return the icon associated with this tab.

abstract int getPosition();
//Return the current position of this tab in the action bar.

abstract Object getTag();

abstract CharSequence getText();
//Return the text of this tab.

abstract void select();
//Select this tab.

abstract ActionBar.Tab setContentDescription(int resId);
//Set a description of this tab's content for use in accessibility support.

abstract ActionBar.Tab setContentDescription(CharSequence contentDesc);
//Set a description of this tab's content for use in accessibility support.

abstract ActionBar.Tab setCustomView(int layoutResId);
//Set a custom view to be used for this tab.

abstract ActionBar.Tab setCustomView(@Sink(DISPLAY) View view);
//Set a custom view to be used for this tab.

abstract ActionBar.Tab setIcon(@Sink(DISPLAY) Drawable icon);
//Set the icon displayed on this tab.

abstract ActionBar.Tab setIcon(int resId);
//Set the icon displayed on this tab.

abstract ActionBar.Tab setTabListener(ActionBar.TabListener listener);
//Set the ActionBar.TabListener that will handle switching to and from this tab.

abstract ActionBar.Tab setTag(Object obj);
//Give this Tab an arbitrary object to hold for later use.

abstract ActionBar.Tab setText(int resId);
//Set the text displayed on this tab.

abstract ActionBar.Tab setText(@Sink(DISPLAY) CharSequence text);
//Set the text displayed on this tab.



}

class Activity{

Activity();
//init
void addContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Add an additional content view to the activity.

void closeContextMenu();
//Programmatically closes the most recently opened context menu, if showing.

void closeOptionsMenu();
//Progammatically closes the options menu.

PendingIntent createPendingResult(int requestCode, Intent data, int flags);
//Create a new PendingIntent object which you can hand to others for them to use to send result data back to your onActivityResult(int, int, Intent); callback.

final void dismissDialog(int id);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

boolean dispatchGenericMotionEvent(MotionEvent ev);
//Called to process generic motion events.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Called to process key events.

boolean dispatchKeyShortcutEvent(@Source(USER_INPUT) KeyEvent event);
//Called to process a key shortcut event.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Called to process population of AccessibilityEvents.

boolean dispatchTouchEvent(MotionEvent ev);
//Called to process touch screen events.

boolean dispatchTrackballEvent(MotionEvent ev);
//Called to process trackball events.

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Activity's state into the given stream.

View findViewById(int id);
//Finds a view that was identified by the id attribute from the XML that was processed in onCreate(Bundle);.

void finish();
//Call this when your activity is done and should be closed.

void finishActivity(int requestCode);
//Force finish another activity that you had previously started with startActivityForResult(Intent, int);.

void finishActivityFromChild(Activity child, int requestCode);
//This is called when a child activity of this one calls its finishActivity();.

void finishAffinity();
//Finish this activity as well as all activities immediately below it in the current task that have the same affinity.

void finishFromChild(Activity child);
//This is called when a child activity of this one calls its finish(); method.

ActionBar getActionBar();
//Retrieve a reference to this activity's ActionBar.

final Application getApplication();
//Return the application that owns this activity.

ComponentName getCallingActivity();
//Return the name of the activity that invoked this activity.

@Source(LITERAL) String getCallingPackage();
//Return the name of the package that invoked this activity.

int getChangingConfigurations();
//If this activity is being destroyed because it can not handle a configuration parameter being changed (and thus its onConfigurationChanged(Configuration); method is not being called);, then you can use this method to discover the set of changes that have occurred while in the process of being destroyed.

ComponentName getComponentName();
//Returns complete component name of this activity.

View getCurrentFocus();
//Calls getCurrentFocus(); on the Window of this Activity to return the currently focused view.

FragmentManager getFragmentManager();
//Return the FragmentManager for interacting with fragments associated with this activity.

Intent getIntent();
//Return the intent that started this activity.

Object getLastNonConfigurationInstance();
//This method was deprecated in API level 13. Use the new Fragment API setRetainInstance(boolean); instead; this is also available on older platforms through the Android compatibility package.

LayoutInflater getLayoutInflater();
//Convenience for calling getLayoutInflater();.

LoaderManager getLoaderManager();
//Return the LoaderManager for this fragment, creating it if needed.

@Source(LITERAL) String getLocalClassName();
//Returns class name for this activity with the package prefix removed.

MenuInflater getMenuInflater();
//Returns a MenuInflater with this context.

final Activity getParent();
//Return the parent activity if this view is an embedded child.

Intent getParentActivityIntent();
//Obtain an Intent that will launch an explicit target activity specified by this activity's logical parent.

@Source(SHARED_PREFERENCES) SharedPreferences getPreferences(int mode);
//Retrieve a SharedPreferences object for accessing preferences that are private to this activity.

int getRequestedOrientation();
//Return the current requested orientation of the activity.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolySomething...

int getTaskId();
//Return the identifier of the task this activity is in.

final CharSequence getTitle();

final int getTitleColor();

final int getVolumeControlStream();
//Gets the suggested audio stream whose volume should be changed by the harwdare volume controls.

Window getWindow();
//Retrieve the current Window for the activity.

WindowManager getWindowManager();
//Retrieve the window manager for showing custom windows.

boolean hasWindowFocus();
//Returns true if this activity's main window currently has window focus.

void invalidateOptionsMenu();
//Declare that the options menu has changed, so should be recreated.

boolean isChangingConfigurations();
//Check to see whether this activity is in the process of being destroyed in order to be recreated with a new configuration.

final boolean isChild();
//Is this activity embedded inside of another activity?

boolean isDestroyed();
//Returns true if the final onDestroy(); call has been made on the Activity, so this instance is now dead.

boolean isFinishing();
//Check to see whether this activity is in the process of finishing, either because you called finish(); on it or someone else has requested that it finished.

boolean isTaskRoot();
//Return whether this activity is the root of a task.

final @Source(CONTENT_PROVIDER) Cursor managedQuery(@Sink(CONDITIONAL) Uri uri, @Sink(CONDITIONAL) String[] projection, @Sink(CONDITIONAL) String selection, @Sink(CONDITIONAL) String[] selectionArgs, @Sink(CONDITIONAL) String sortOrder);
//This method was deprecated in API level 11. Use CursorLoader instead.

boolean moveTaskToBack(boolean nonRoot);
//Move the task containing this activity to the back of the activity stack.

boolean navigateUpTo(Intent upIntent);
//Navigate from this activity to the activity specified by upIntent, finishing this activity in the process.

boolean navigateUpToFromChild(Activity child, Intent upIntent);
//This is called when a child activity of this one calls its navigateUpTo(Intent); method.

void onActionModeFinished(ActionMode mode);
//Notifies the activity that an action mode has finished.

void onActionModeStarted(ActionMode mode);
//Notifies the Activity that an action mode has been started.

void onAttachFragment(Fragment fragment);
//Called when a Fragment is being attached to this activity, immediately after the call to its Fragment.onAttach(); method and before Fragment.onCreate();.

void onAttachedToWindow();
//Called when the main window associated with the activity has been attached to the window manager.

void onBackPressed();
//Called when the activity has detected the user's press of the back key.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your activity is running.

void onContentChanged();
//This hook is called whenever the content view of the screen changes (due to a call to Window.setContentView or Window.addContentView);.

boolean onContextItemSelected(MenuItem item);
//This hook is called whenever an item in a context menu is selected.

void onContextMenuClosed(Menu menu);
//This hook is called whenever the context menu is being closed (either by the user canceling the menu with the back/menu button, or when an item is selected);.

void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo);
//Called when a context menu for the view is about to be shown.

CharSequence onCreateDescription();
//Generate a new description for this activity.

void onCreateNavigateUpTaskStack(TaskStackBuilder builder);
//Define the synthetic task stack that will be generated during Up navigation from a different task.

boolean onCreateOptionsMenu(Menu menu);
//Initialize the contents of the Activity's standard options menu.

boolean onCreatePanelMenu(int featureId, Menu menu);
//Default implementation of onCreatePanelMenu(int, Menu); for activities.

View onCreatePanelView(int featureId);
//Default implementation of onCreatePanelView(int); for activities.

boolean onCreateThumbnail(@Sink(DISPLAY) Bitmap outBitmap, Canvas canvas);
//Generate a new thumbnail for this activity.

View onCreateView(View parent, String name, Context context, AttributeSet attrs);
//Standard implementation of onCreateView(View, String, Context, AttributeSet); used when inflating with the LayoutInflater returned by getSystemService(String);.

View onCreateView(String name, Context context, AttributeSet attrs);
//Standard implementation of onCreateView(String, Context, AttributeSet); used when inflating with the LayoutInflater returned by getSystemService(String);.

void onDetachedFromWindow();
//Called when the main window associated with the activity has been detached from the window manager.

boolean onGenericMotionEvent(MotionEvent event);
//Called when a generic motion event was not handled by any of the views inside of the activity.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called when a key was pressed down and not handled by any of the views inside of the activity.

boolean onKeyLongPress(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyLongPress();: always returns false (doesn't handle the event);.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyShortcut(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called when a key shortcut event is not handled by any of the views in the Activity.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called when a key was released and not handled by any of the views inside of the activity.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt.

boolean onMenuItemSelected(int featureId, MenuItem item);
//Default implementation of onMenuItemSelected(int, MenuItem); for activities.

boolean onMenuOpened(int featureId, @Sink(DISPLAY) Menu menu);
//Called when a panel's menu is opened by the user.

boolean onNavigateUp();
//This method is called whenever the user chooses to navigate Up within your application's activity hierarchy from the action bar.

boolean onNavigateUpFromChild(Activity child);
//This is called when a child activity of this one attempts to navigate up.

boolean onOptionsItemSelected(MenuItem item);
//This hook is called whenever an item in your options menu is selected.

void onOptionsMenuClosed(Menu menu);
//This hook is called whenever the options menu is being closed (either by the user canceling the menu with the back/menu button, or when an item is selected);.

void onPanelClosed(int featureId, Menu menu);
//Default implementation of onPanelClosed(int, Menu); for activities.

void onPrepareNavigateUpTaskStack(TaskStackBuilder builder);
//Prepare the synthetic task stack that will be generated during Up navigation from a different task.

boolean onPrepareOptionsMenu(Menu menu);
//Prepare the Screen's standard options menu to be displayed.

boolean onPreparePanel(int featureId, View view, Menu menu);
//Default implementation of onPreparePanel(int, View, Menu); for activities.

Object onRetainNonConfigurationInstance();
//This method was deprecated in API level 13. Use the new Fragment API setRetainInstance(boolean); instead; this is also available on older platforms through the Android compatibility package.

boolean onSearchRequested();
//This hook is called when the user signals the desire to start a search.

boolean onTouchEvent(MotionEvent event);
//Called when a touch screen event was not handled by any of the views under it.

boolean onTrackballEvent(MotionEvent event);
//Called when the trackball was moved and not handled by any of the views inside of the activity.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

void onUserInteraction();
//Called whenever a key, touch, or trackball event is dispatched to the activity.

void onWindowAttributesChanged(WindowManager.LayoutParams params);
//This is called whenever the current window attributes change.

void onWindowFocusChanged(boolean hasFocus);
//Called when the current Window of the activity gains or loses focus.

ActionMode onWindowStartingActionMode(ActionMode.Callback callback);
//Give the Activity a chance to control the UI for an action mode requested by the system.

void openContextMenu(View view);
//Programmatically opens the context menu for a particular view.

void openOptionsMenu();
//Programmatically opens the options menu.

void overridePendingTransition(int enterAnim, int exitAnim);
//Call immediately after one of the flavors of startActivity(Intent); or finish(); to specify an explicit transition animation to perform next.

void recreate();
//Cause this Activity to be recreated with a new instance.

void registerForContextMenu(View view);
//Registers a context menu to be shown for the given view (multiple views can show the context menu);.

final void removeDialog(int id);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

final boolean requestWindowFeature(int featureId);
//Enable extended window features.

final void runOnUiThread(Runnable action);
//Runs the specified action on the UI thread.

void setContentView(int layoutResID);
//Set the activity content from a layout resource.

void setContentView(@Sink(DISPLAY) View view);
//Set the activity content to an explicit view.

void setContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Set the activity content to an explicit view.

final void setDefaultKeyMode(int mode);
//Select the default key handling for this activity.

final void setFeatureDrawable(int featureId, @Sink(DISPLAY) Drawable drawable);
//Convenience for calling setFeatureDrawable(int, Drawable);.

final void setFeatureDrawableAlpha(int featureId, int alpha);
//Convenience for calling setFeatureDrawableAlpha(int, int);.

final void setFeatureDrawableResource(int featureId, int resId);
//Convenience for calling setFeatureDrawableResource(int, int);.

final void setFeatureDrawableUri(int featureId, @Sink(DISPLAY) Uri uri);
//Convenience for calling setFeatureDrawableUri(int, Uri);.

void setFinishOnTouchOutside(boolean finish);
//Sets whether this activity is finished when touched outside its window's bounds.

void setIntent(Intent newIntent);
//Change the intent returned by getIntent();.

final void setProgress(@Sink(DISPLAY) int progress);
//Sets the progress for the progress bars in the title.

final void setProgressBarIndeterminate(boolean indeterminate);
//Sets whether the horizontal progress bar in the title should be indeterminate (the circular is always indeterminate);.

final void setProgressBarIndeterminateVisibility(boolean visible);
//Sets the visibility of the indeterminate progress bar in the title.

final void setProgressBarVisibility(boolean visible);
//Sets the visibility of the progress bar in the title.

void setRequestedOrientation(int requestedOrientation);
//Change the desired orientation of this activity.

final void setResult(int resultCode);
//Call this to set the result that your activity will return to its caller.
//CSH: this gets sent back to the calling app, Sink(ANY)?

final void setResult(int resultCode, Intent data);
//Call this to set the result that your activity will return to its caller.

final void setSecondaryProgress(@Sink(DISPLAY) int secondaryProgress);
//Sets the secondary progress for the progress bar in the title.

void setTitle(int titleId);
//Change the title associated with this activity.

void setTitle(@Sink(DISPLAY) CharSequence title);
//Change the title associated with this activity.

void setTitleColor(int textColor);

void setVisible(boolean visible);
//Control whether this activity's main window is visible.

final void setVolumeControlStream(int streamType);
//Suggests an audio stream whose volume should be changed by the hardware volume controls.

boolean shouldUpRecreateTask(Intent targetIntent);
//Returns true if the app should recreate the task when navigating 'up' from this activity by using targetIntent.

final boolean showDialog(int id, @Sink({BUNDLE, DISPLAY}) Bundle args);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

final void showDialog(int id);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

ActionMode startActionMode(ActionMode.Callback callback);
//Start an action mode.

void startActivities(Intent[] intents, Bundle options);
//Launch a new activity.

void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

void startActivity(Intent intent, Bundle options);
//Launch a new activity.

void startActivityForResult(Intent intent, int requestCode);
//Same as calling startActivityForResult(Intent, int, Bundle); with no options.

void startActivityForResult(Intent intent, int requestCode, Bundle options);
//Launch an activity for which you would like a result when it finished.

void startActivityFromChild(Activity child, Intent intent, int requestCode, Bundle options);
//This is called when a child activity of this one calls its startActivity(Intent); or startActivityForResult(Intent, int); method.

void startActivityFromChild(Activity child, Intent intent, int requestCode);
//Same as calling startActivityFromChild(Activity, Intent, int, Bundle); with no options.

void startActivityFromFragment(Fragment fragment, Intent intent, int requestCode, Bundle options);
//This is called when a Fragment in this activity calls its startActivity(Intent); or startActivityForResult(Intent, int); method.

void startActivityFromFragment(Fragment fragment, Intent intent, int requestCode);
//Same as calling startActivityFromFragment(Fragment, Intent, int, Bundle); with no options.

boolean startActivityIfNeeded(Intent intent, int requestCode, Bundle options);
//A special variation to launch an activity only if a new activity instance is needed to handle the given Intent.

boolean startActivityIfNeeded(Intent intent, int requestCode);
//Same as calling startActivityIfNeeded(Intent, int, Bundle); with no options.

void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start; see startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle); for more information.

void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as calling startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options.

void startIntentSenderForResult(IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivityForResult(Intent, int);, but allowing you to use a IntentSender to describe the activity to be started.

void startIntentSenderForResult(IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as calling startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle); with no options.

void startIntentSenderFromChild(Activity child, IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as calling startIntentSenderFromChild(Activity, IntentSender, int, Intent, int, int, int, Bundle); with no options.

void startIntentSenderFromChild(Activity child, IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivityFromChild(Activity, Intent, int);, but taking a IntentSender; see startIntentSenderForResult(IntentSender, int, Intent, int, int, int); for more information.

void startManagingCursor(Cursor c);
//This method was deprecated in API level 11. Use the new CursorLoader class with LoaderManager instead; this is also available on older platforms through the Android compatibility package.

boolean startNextMatchingActivity(Intent intent);
//Same as calling startNextMatchingActivity(Intent, Bundle); with no options.

boolean startNextMatchingActivity(Intent intent, Bundle options);
//Special version of starting an activity, for use when you are replacing other activity components.

void startSearch(String initialQuery, boolean selectInitialQuery, Bundle appSearchData, boolean globalSearch);
//This hook is called to launch the search UI.
//CSH: should probably create a new SEARCH sink?

void stopManagingCursor(Cursor c);
//This method was deprecated in API level 11. Use the new CursorLoader class with LoaderManager instead; this is also available on older platforms through the Android compatibility package.

void takeKeyEvents(boolean get);
//Request that key events come to this activity.

void triggerSearch(String query, Bundle appSearchData);
//Similar to startSearch(String, boolean, Bundle, boolean);, but actually fires off the search query after invoking the search dialog.

void unregisterForContextMenu(View view);
//Prevents a context menu to be shown for the given view.

//Protected Methods
void onActivityResult(int requestCode, int resultCode, Intent data);
//Called when an activity you launched exits, giving you the requestCode you started it with, the resultCode it returned, and any additional data from it.

void onApplyThemeResource(Resources.Theme theme, int resid, boolean first);
//Called by setTheme(int); and getTheme(); to apply a theme resource to the current Theme object.

void onChildTitleChanged(Activity childActivity, CharSequence title);

void onCreate(Bundle savedInstanceState);
//Called when the activity is starting.

@Sink(DISPLAY) Dialog onCreateDialog(int id);
//This method was deprecated in API level 8. Old no-arguments version of onCreateDialog(int, Bundle);.

@Sink(DISPLAY) Dialog onCreateDialog(int id, Bundle args);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

void onDestroy();
//Perform any final cleanup before an activity is destroyed.

void onNewIntent(Intent intent);
//This is called for activities that set launchMode to "singleTop" in their package, or if a client used the FLAG_ACTIVITY_SINGLE_TOP flag when calling startActivity(Intent);.

void onPause();
//Called as part of the activity lifecycle when an activity is going into the background, but has not (yet); been killed.

void onPostCreate(Bundle savedInstanceState);
//Called when activity start-up is complete (after onStart(); and onRestoreInstanceState(Bundle); have been called);.

void onPostResume();
//Called when activity resume is complete (after onResume(); has been called);.

void onPrepareDialog(int id, Dialog dialog);
//This method was deprecated in API level 8. Old no-arguments version of onPrepareDialog(int, Dialog, Bundle);.

void onPrepareDialog(int id, Dialog dialog, Bundle args);
//This method was deprecated in API level 13. Use the new DialogFragment class with FragmentManager instead; this is also available on older platforms through the Android compatibility package.

void onRestart();
//Called after onStop(); when the current activity is being re-displayed to the user (the user has navigated back to it);.

void onRestoreInstanceState(Bundle savedInstanceState);
//This method is called after onStart(); when the activity is being re-initialized from a previously saved state, given here in savedInstanceState.

void onResume();
//Called after onRestoreInstanceState(Bundle);, onRestart();, or onPause();, for your activity to start interacting with the user.

void onSaveInstanceState(Bundle outState);
//Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle); or onRestoreInstanceState(Bundle); (the Bundle populated by this method will be passed to both);.

void onStart();
//Called after onCreate(Bundle); â€” or after onRestart(); when the activity had been stopped, but is now again being displayed to the user.

void onStop();
//Called when you are no longer visible to the user.

void onTitleChanged(CharSequence title, int color);

void onUserLeaveHint();
//Called as part of the activity lifecycle when an activity is about to go into the background as the result of user choice.
}
class ActivityManager{
                List<RunningServiceInfo> getRunningServices(int maxNum) throws SecurityException;
}

class Application {
    
void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running.

void onCreate();
//Called when the application is starting, before any activity, service, or receiver objects (excluding content providers); have been created.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt.

void onTerminate();
//This method is for use in emulated process environments.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback);

void registerComponentCallbacks(ComponentCallbacks callback);
//Add a new ComponentCallbacks to the base application of the Context, which will be called at the same times as the ComponentCallbacks methods of activities and other components are called.

void unregisterActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback);

void unregisterComponentCallbacks(ComponentCallbacks callback);
//Remove a ComponentCallbacks objec that was previously registered with registerComponentCallbacks(ComponentCallbacks);.



}


class AlarmManager {
    
void cancel(PendingIntent operation);
//Remove any alarms with a matching Intent.

void set(int type, long triggerAtMillis, PendingIntent operation);
//Schedule an alarm.

void setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation);
//Schedule a repeating alarm that has inexact trigger time requirements; for example, an alarm that repeats every hour, but not necessarily at the top of every hour.

void setRepeating(int type, long triggerAtMillis, long intervalMillis, PendingIntent operation);
//Schedule a repeating alarm.

void setTime(@Sink(SET_TIME) long millis);
//Set the system wall clock time.

void setTimeZone(@Sink(SET_TIME_ZONE) String timeZone);
//Set the system default time zone.



}

class AlertDialog {

Button getButton(int whichButton);
//Gets one of the buttons used in the dialog.

ListView getListView();
//Gets the list view used in the dialog.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT)KeyEvent event);
////A key was pressed down.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//A key was released.

void setButton(@Sink(DISPLAY)CharSequence text, Message msg);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, Message); with BUTTON_POSITIVE.

void setButton(int whichButton, @Sink(DISPLAY)CharSequence text, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the positive button of the dialog is pressed.

void setButton(@Sink(DISPLAY)CharSequence text, DialogInterface.OnClickListener listener);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, android.content.DialogInterface.OnClickListener); with BUTTON_POSITIVE

void setButton(int whichButton, @Sink(DISPLAY)CharSequence text, Message msg);
//Set a message to be sent when a button is pressed.

void setButton2(@Sink(DISPLAY)CharSequence text, DialogInterface.OnClickListener listener);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, android.content.DialogInterface.OnClickListener); with BUTTON_NEGATIVE

void setButton2(@Sink(DISPLAY) CharSequence text, Message msg);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, Message); with BUTTON_NEGATIVE.

void setButton3(@Sink(DISPLAY) CharSequence text, DialogInterface.OnClickListener listener);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, android.content.DialogInterface.OnClickListener); with BUTTON_POSITIVE

void setButton3(@Sink(DISPLAY) CharSequence text, Message msg);
//This method was deprecated in API level 3. Use setButton(int, CharSequence, Message); with BUTTON_NEUTRAL.

void setCustomTitle(@Sink(DISPLAY) View customTitleView);

void setIcon(@Sink(DISPLAY) Drawable icon);

void setIcon(int resId);
//Set resId to 0 if you don't want an icon.

void setIconAttribute(int attrId);
//Set an icon as supplied by a theme attribute.

void setInverseBackgroundForced(boolean forceInverseBackground);

void setMessage(@Sink(DISPLAY) CharSequence message);

void setTitle(@Sink(DISPLAY) CharSequence title);
//Set the title text for this dialog's window.

void setView(@Sink(DISPLAY) View view, int viewSpacingLeft, int viewSpacingTop, int viewSpacingRight, int viewSpacingBottom);
//Set the view to display in that dialog, specifying the spacing to appear around that view.

void setView(@Sink(DISPLAY) View view);
//Set the view to display in that dialog.


//PROTECTED
void onCreate(Bundle savedInstanceState);
//Similar to onCreate(Bundle);, you should initialize your dialog in this method, including calling setContentView(View);.
}

class AlertDialog$Builder {
  
AlertDialog create();
//Creates a AlertDialog with the arguments supplied to this builder.

Context getContext();
//Returns a Context with the appropriate theme for dialogs created by this Builder.

AlertDialog.Builder setAdapter(ListAdapter adapter, DialogInterface.OnClickListener listener);
//Set a list of items, which are supplied by the given ListAdapter, to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setCancelable(boolean cancelable);
//Sets whether the dialog is cancelable or not.

AlertDialog.Builder setCursor(Cursor cursor, DialogInterface.OnClickListener listener, String labelColumn);
//Set a list of items, which are supplied by the given Cursor, to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setCustomTitle(@Sink(DISPLAY) View customTitleView);
//Set the title using the custom view customTitleView.

AlertDialog.Builder setIcon(@Sink(DISPLAY) Drawable icon);
//Set the Drawable to be used in the title.

AlertDialog.Builder setIcon(int iconId);
//Set the resource id of the Drawable to be used in the title.

AlertDialog.Builder setIconAttribute(int attrId);
//Set an icon as supplied by a theme attribute.

AlertDialog.Builder setInverseBackgroundForced(boolean useInverseBackground);
//Sets the Dialog to use the inverse background, regardless of what the contents is.

AlertDialog.Builder setItems(int itemsId, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setItems(@Sink(DISPLAY) CharSequence[] items, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setMessage(@Sink(DISPLAY) CharSequence message);
//Set the message to display.

AlertDialog.Builder setMessage(int messageId);
//Set the message to display using the given resource id.

AlertDialog.Builder setMultiChoiceItems(@Sink(DISPLAY) CharSequence[] items, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setMultiChoiceItems(@Sink(DISPLAY) Cursor cursor, String isCheckedColumn, String labelColumn, DialogInterface.OnMultiChoiceClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setMultiChoiceItems(int itemsId, boolean[] checkedItems, DialogInterface.OnMultiChoiceClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setNegativeButton(@Sink(DISPLAY) CharSequence text, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the negative button of the dialog is pressed.

AlertDialog.Builder setNegativeButton(int textId, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the negative button of the dialog is pressed.

AlertDialog.Builder setNeutralButton(int textId, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the neutral button of the dialog is pressed.

AlertDialog.Builder setNeutralButton(@Sink(DISPLAY) CharSequence text, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the neutral button of the dialog is pressed.

AlertDialog.Builder setOnCancelListener(DialogInterface.OnCancelListener onCancelListener);
//Sets the callback that will be called if the dialog is canceled.

AlertDialog.Builder setOnDismissListener(DialogInterface.OnDismissListener onDismissListener);
//Sets the callback that will be called when the dialog is dismissed for any reason.

AlertDialog.Builder setOnItemSelectedListener(AdapterView.OnItemSelectedListener listener);
//Sets a listener to be invoked when an item in the list is selected.

AlertDialog.Builder setOnKeyListener(DialogInterface.OnKeyListener onKeyListener);
//Sets the callback that will be called if a key is dispatched to the dialog.

AlertDialog.Builder setPositiveButton(int textId, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the positive button of the dialog is pressed.

AlertDialog.Builder setPositiveButton(@Sink(DISPLAY) CharSequence text, DialogInterface.OnClickListener listener);
//Set a listener to be invoked when the positive button of the dialog is pressed.

AlertDialog.Builder setSingleChoiceItems(@Sink(DISPLAY) CharSequence[] items, int checkedItem, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setSingleChoiceItems(@Sink(DISPLAY) ListAdapter adapter, int checkedItem, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setSingleChoiceItems(int itemsId, int checkedItem, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setSingleChoiceItems(@Sink(DISPLAY) Cursor cursor, int checkedItem, String labelColumn, DialogInterface.OnClickListener listener);
//Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.

AlertDialog.Builder setTitle(@Sink(DISPLAY) CharSequence title);
//Set the title displayed in the Dialog.

AlertDialog.Builder setTitle(int titleId);
//Set the title using the given resource id.

AlertDialog.Builder setView(@Sink(DISPLAY) View view);
//Set a custom view to be the contents of the Dialog.

AlertDialog show()  @Sink(DISPLAY);
//Creates a AlertDialog with the arguments supplied to this builder and show();'s the dialog.

}


class DatePickerDialog{
            DatePickerDialog(Context context, OnDateSetListener callBack, int year, int monthOfYear, int dayOfMonth);
}

class Dialog {
void addContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Add an additional content view to the screen.

void cancel();
//Cancel the dialog.

void closeOptionsMenu();

void dismiss();
//Dismiss this dialog, removing it from the screen.

boolean dispatchGenericMotionEvent(MotionEvent ev);
//Called to process generic motion events.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Called to process key events.

boolean dispatchKeyShortcutEvent(@Source(USER_INPUT) KeyEvent event);
//Called to process a key shortcut event.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Called to process population of AccessibilityEvents.

boolean dispatchTouchEvent(MotionEvent ev);
//Called to process touch screen events.

boolean dispatchTrackballEvent(MotionEvent ev);
//Called to process trackball events.

View findViewById(int id);
//Finds a view that was identified by the id attribute from the XML that was processed in onStart();.

ActionBar getActionBar();
//Retrieve the ActionBar attached to this dialog, if present.

final Context getContext();
//Retrieve the Context this Dialog is running in.

View getCurrentFocus();
//Call getCurrentFocus(); on the Window if this Activity to return the currently focused view.

LayoutInflater getLayoutInflater();

final Activity getOwnerActivity();
//Returns the Activity that owns this Dialog.

final int getVolumeControlStream();

Window getWindow();
//Retrieve the current Window for the activity.

void hide();
//Hide the dialog, but do not dismiss it.

void invalidateOptionsMenu();

boolean isShowing();

void onActionModeFinished(ActionMode mode);
//Called when an action mode has been finished. Note that if you override this method you should always call through to the superclass implementation by calling super.onActionModeFinished(mode);.

void onActionModeStarted(ActionMode mode);
//Called when an action mode has been started. Note that if you override this method you should always call through to the superclass implementation by calling super.onActionModeStarted(mode);.

void onAttachedToWindow();
//Called when the window has been attached to the window manager.

void onBackPressed();
//Called when the dialog has detected the user's press of the back key.

void onContentChanged();
//This hook is called whenever the content view of the screen changes (due to a call to Window.setContentView or Window.addContentView);.

boolean onContextItemSelected(MenuItem item);

void onContextMenuClosed(Menu menu);

void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo);
//Called when the context menu for this view is being built.

boolean onCreateOptionsMenu(Menu menu);
//It is usually safe to proxy this call to the owner activity's onCreateOptionsMenu(Menu); if the client desires the same menu for this Dialog.

boolean onCreatePanelMenu(int featureId, Menu menu);
//Initialize the contents of the menu for panel 'featureId'.

View onCreatePanelView(int featureId);
//Instantiate the view to display in the panel for 'featureId'.

void onDetachedFromWindow();
//Called when the window has been attached to the window manager.

boolean onGenericMotionEvent(MotionEvent event);
//Called when a generic motion event was not handled by any of the views inside of the dialog.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//A key was pressed down.

boolean onKeyLongPress(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyLongPress();: always returns false (doesn't handle the event);.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyShortcut(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called when a key shortcut event is not handled by any of the views in the Dialog.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//A key was released.

boolean onMenuItemSelected(int featureId, MenuItem item);
//Called when a panel's menu item has been selected by the user.

boolean onMenuOpened(int featureId, Menu menu);
//Called when a panel's menu is opened by the user.

boolean onOptionsItemSelected(MenuItem item);

void onOptionsMenuClosed(Menu menu);

void onPanelClosed(int featureId, Menu menu);
//Called when a panel is being closed.

boolean onPrepareOptionsMenu(Menu menu);
//It is usually safe to proxy this call to the owner activity's onPrepareOptionsMenu(Menu); if the client desires the same menu for this Dialog.

boolean onPreparePanel(int featureId, View view, Menu menu);
//Prepare a panel to be displayed.

void onRestoreInstanceState(Bundle savedInstanceState);
//Restore the state of the dialog from a previously saved bundle.

Bundle onSaveInstanceState();
//Saves the state of the dialog into a bundle.

boolean onSearchRequested();
//This hook is called when the user signals the desire to start a search.

boolean onTouchEvent(MotionEvent event);
//Called when a touch screen event was not handled by any of the views under it.

boolean onTrackballEvent(MotionEvent event);
//Called when the trackball was moved and not handled by any of the views inside of the activity.

void onWindowAttributesChanged(WindowManager.LayoutParams params);
//This is called whenever the current window attributes change.

void onWindowFocusChanged(boolean hasFocus);
//This hook is called whenever the window focus changes.

ActionMode onWindowStartingActionMode(ActionMode.Callback callback);
//Called when an action mode is being started for this window.

void openContextMenu(@Sink(DISPLAY) View view);

void openOptionsMenu();

void registerForContextMenu(@Sink(DISPLAY) View view);

final boolean requestWindowFeature(int featureId);
//Enable extended window features.

void setCancelMessage(@Sink(DISPLAY) Message msg);
//Set a message to be sent when the dialog is canceled.

void setCancelable(boolean flag);
//Sets whether this dialog is cancelable with the BACK key.

void setCanceledOnTouchOutside(boolean cancel);
//Sets whether this dialog is canceled when touched outside the window's bounds.

void setContentView(@Sink(DISPLAY) View view);
//Set the screen content to an explicit view.

void setContentView(int layoutResID);
//Set the screen content from a layout resource.

void setContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Set the screen content to an explicit view.

void setDismissMessage(@Sink(DISPLAY) Message msg);
//Set a message to be sent when the dialog is dismissed.

final void setFeatureDrawable(int featureId, @Sink(DISPLAY) Drawable drawable);
//Convenience for calling setFeatureDrawable(int, Drawable);.

final void setFeatureDrawableAlpha(int featureId, int alpha);
//Convenience for calling setFeatureDrawableAlpha(int, int);.

final void setFeatureDrawableResource(int featureId, int resId);
//Convenience for calling setFeatureDrawableResource(int, int);.

final void setFeatureDrawableUri(int featureId, Uri uri);
//Convenience for calling setFeatureDrawableUri(int, Uri);.

void setOnCancelListener(DialogInterface.OnCancelListener listener);
//Set a listener to be invoked when the dialog is canceled.

void setOnDismissListener(DialogInterface.OnDismissListener listener);
//Set a listener to be invoked when the dialog is dismissed.

void setOnKeyListener(DialogInterface.OnKeyListener onKeyListener);
//Sets the callback that will be called if a key is dispatched to the dialog.

void setOnShowListener(DialogInterface.OnShowListener listener);
//Sets a listener to be invoked when the dialog is shown.

final void setOwnerActivity(Activity activity);
//Sets the Activity that owns this dialog.

void setTitle(int titleId);
//Set the title text for this dialog's window.

void setTitle(@Sink(FlowPermission.DISPLAY) CharSequence title);
//Set the title text for this dialog's window.

final void setVolumeControlStream(int streamType);
//By default, this will use the owner Activity's suggested stream type.

void show()  @Sink(DISPLAY);
//Start the dialog and display it on screen.

void takeKeyEvents(boolean get);
//Request that key events come to this dialog.

void unregisterForContextMenu(View view);

//PROTECTED
void onCreate(Bundle savedInstanceState);
//Similar to onCreate(Bundle);, you should initialize your dialog in this method, including calling setContentView(View);.

void onStart();
//Called when the dialog is starting.

void onStop();
//Called to tell you that you're stopping.
}

class DialogFragment {
    
void dismiss();
//Dismiss the fragment and its dialog.

void dismissAllowingStateLoss();
//Version of dismiss(); that uses FragmentTransaction.commitAllowingStateLoss();.

void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET})FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Fragments's state into the given stream.

Dialog getDialog();

boolean getShowsDialog();
//Return the current value of setShowsDialog(boolean);.

int getTheme();

boolean isCancelable();
//Return the current value of setCancelable(boolean);.

void onActivityCreated(Bundle savedInstanceState);
//Called when the fragment's activity has been created and this fragment's view hierarchy instantiated.

void onAttach(Activity activity);
//Called when a fragment is first attached to its activity.

void onCancel(DialogInterface dialog);
//This method will be invoked when the dialog is canceled.

void onCreate(Bundle savedInstanceState);
//Called to do initial creation of a fragment.

Dialog onCreateDialog(Bundle savedInstanceState);
//Override to build your own custom Dialog container.

void onDestroyView();
//Remove dialog.

void onDetach();
//Called when the fragment is no longer attached to its activity.

void onDismiss(DialogInterface dialog);
//This method will be invoked when the dialog is dismissed.

void onSaveInstanceState(Bundle outState);
//Called to ask the fragment to save its current dynamic state, so it can later be reconstructed in a new instance of its process is restarted.

void onStart();
//Called when the Fragment is visible to the user.

void onStop();
//Called when the Fragment is no longer started.

void setCancelable(boolean cancelable);
//Control whether the shown Dialog is cancelable.

void setShowsDialog(boolean showsDialog);
//Controls whether this fragment should be shown in a dialog.

void setStyle(int style, int theme);
//Call to customize the basic appearance and behavior of the fragment's dialog.

int show(FragmentTransaction transaction, String tag) @Sink(DISPLAY);
//Display the dialog, adding the fragment using an existing transaction and then committing the transaction.

void show(FragmentManager manager, String tag) @Sink(DISPLAY);
//Display the dialog, adding the fragment to the given FragmentManager.



}

class ExpandableListActivity{
        ExpandableListActivity();
        void setListAdapter(ExpandableListAdapter adapter);
        boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id);
        ExpandableListView getExpandableListView();
}

class Fragment {
void dump(String prefix, @Sink({FlowPermission.FILESYSTEM ,FlowPermission.INTERNET, FlowPermission.WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Fragments's state into the given stream.

final boolean equals(Object o);
//Subclasses can not override equals();.

final Activity getActivity();
//Return the Activity this fragment is currently associated with.

final Bundle getArguments();
//Return the arguments supplied when the fragment was instantiated, if any.

final FragmentManager getChildFragmentManager();
//Return a private FragmentManager for placing and managing Fragments inside of this Fragment.

final FragmentManager getFragmentManager();
//Return the FragmentManager for interacting with fragments associated with this fragment's activity.

final int getId();
//Return the identifier this fragment is known by.

LoaderManager getLoaderManager();
//Return the LoaderManager for this fragment, creating it if needed.

final Fragment getParentFragment();
//Returns the parent Fragment containing this Fragment.

final Resources getResources();
//Return getActivity();.getResources();.

final boolean getRetainInstance();

final @Source(LITERAL) String getString(int resId);
//Return a localized string from the application's package's default string table.

final @Source(LITERAL) String getString(int resId, Object... formatArgs);
//Return a localized formatted string from the application's package's default string table, substituting the format arguments as defined in Formatter and format(String, Object...);.

final String getTag();
//Get the tag name of the fragment, if specified.

final Fragment getTargetFragment();
//Return the target fragment set by setTargetFragment(Fragment, int);.

final int getTargetRequestCode();
//Return the target request code set by setTargetFragment(Fragment, int);.

final @Source(LITERAL) CharSequence getText(int resId);
//Return a localized, styled CharSequence from the application's package's default string table.

boolean getUserVisibleHint();

View getView();
//Get the root view for the fragment's layout (the one returned by onCreateView(LayoutInflater, ViewGroup, Bundle););, if provided.

final int hashCode();
//Subclasses can not override hashCode();.

static Fragment instantiate(Context context, String fname);
//Like instantiate(Context, String, Bundle); but with a null argument Bundle.

static Fragment instantiate(Context context, String fname, Bundle args);
//Create a new instance of a Fragment with the given class name.

final boolean isAdded();
//Return true if the fragment is currently added to its activity.

final boolean isDetached();
//Return true if the fragment has been explicitly detached from the UI.

final boolean isHidden();
//Return true if the fragment has been hidden.

final boolean isInLayout();
//Return true if the layout is included as part of an activity view hierarchy via the <fragment> tag.

final boolean isRemoving();
//Return true if this fragment is currently being removed from its activity.

final boolean isResumed();
//Return true if the fragment is in the resumed state.

final boolean isVisible();
//Return true if the fragment is currently visible to the user.

void onActivityCreated(Bundle savedInstanceState);
//Called when the fragment's activity has been created and this fragment's view hierarchy instantiated.

void onActivityResult(int requestCode, int resultCode, Intent data);
//Receive the result from a previous call to startActivityForResult(Intent, int);.

void onAttach(Activity activity);
//Called when a fragment is first attached to its activity.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running.

boolean onContextItemSelected(MenuItem item);
//This hook is called whenever an item in a context menu is selected.

void onCreate(Bundle savedInstanceState);
//Called to do initial creation of a fragment.

Animator onCreateAnimator(int transit, boolean enter, int nextAnim);
//Called when a fragment loads an animation.

void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo);
//Called when a context menu for the view is about to be shown.

void onCreateOptionsMenu(Menu menu, MenuInflater inflater);
//Initialize the contents of the Activity's standard options menu.

View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);
//Called to have the fragment instantiate its user interface view.

void onDestroy();
//Called when the fragment is no longer in use.

void onDestroyOptionsMenu();
//Called when this fragment's option menu items are no longer being included in the overall options menu.

void onDestroyView();
//Called when the view previously created by onCreateView(LayoutInflater, ViewGroup, Bundle); has been detached from the fragment.

void onDetach();
//Called when the fragment is no longer attached to its activity.

void onHiddenChanged(boolean hidden);
//Called when the hidden state (as returned by isHidden(); of the fragment has changed.

void onInflate(AttributeSet attrs, Bundle savedInstanceState);
//This method was deprecated in API level 12. Use onInflate(Activity, AttributeSet, Bundle); instead.

void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState);
//Called when a fragment is being created as part of a view layout inflation, typically from setting the content view of an activity.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt.

boolean onOptionsItemSelected(MenuItem item);
//This hook is called whenever an item in your options menu is selected.

void onOptionsMenuClosed(Menu menu);
//This hook is called whenever the options menu is being closed (either by the user canceling the menu with the back/menu button, or when an item is selected);.

void onPause();
//Called when the Fragment is no longer resumed.

void onPrepareOptionsMenu(Menu menu);
//Prepare the Screen's standard options menu to be displayed.

void onResume();
//Called when the fragment is visible to the user and actively running.

void onSaveInstanceState(Bundle outState);
//Called to ask the fragment to save its current dynamic state, so it can later be reconstructed in a new instance of its process is restarted.

void onStart();
//Called when the Fragment is visible to the user.

void onStop();
//Called when the Fragment is no longer started.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

void onViewCreated(View view, Bundle savedInstanceState);
//Called immediately after onCreateView(LayoutInflater, ViewGroup, Bundle); has returned, but before any saved state has been restored in to the view.

void onViewStateRestored(Bundle savedInstanceState);
//Called when all saved state has been restored into the view hierarchy of the fragment.

void registerForContextMenu(View view);
//Registers a context menu to be shown for the given view (multiple views can show the context menu);.

void setArguments(Bundle args);
//Supply the construction arguments for this fragment.

void setHasOptionsMenu(boolean hasMenu);
//Report that this fragment would like to participate in populating the options menu by receiving a call to onCreateOptionsMenu(Menu, MenuInflater); and related methods.

void setInitialSavedState(Fragment.SavedState state);
//Set the initial saved state that this Fragment should restore itself from when first being constructed, as returned by FragmentManager.saveFragmentInstanceState.

void setMenuVisibility(boolean menuVisible);
//Set a hint for whether this fragment's menu should be visible.

void setRetainInstance(boolean retain);
//Control whether a fragment instance is retained across Activity re-creation (such as from a configuration change);.

void setTargetFragment(Fragment fragment, int requestCode);
//Optional target for this fragment.

void setUserVisibleHint(boolean isVisibleToUser);
//Set a hint to the system about whether this fragment's UI is currently visible to the user.

void startActivity(Intent intent);
//Call startActivity(Intent); from the fragment's containing Activity.

void startActivity(Intent intent, Bundle options);
//Call startActivity(Intent, Bundle); from the fragment's containing Activity.

void startActivityForResult(Intent intent, int requestCode);
//Call startActivityForResult(Intent, int); from the fragment's containing Activity.

void startActivityForResult(Intent intent, int requestCode, Bundle options);
//Call startActivityForResult(Intent, int, Bundle); from the fragment's containing Activity.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void unregisterForContextMenu(View view);
//Prevents a context menu to be shown for the given view.
}

class FragmentManager {
abstract void addOnBackStackChangedListener(FragmentManager.OnBackStackChangedListener listener);
//Add a new listener for changes to the fragment back stack.

abstract FragmentTransaction beginTransaction();
//Start a series of edit operations on the Fragments associated with this FragmentManager.

abstract void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET})FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the FragmentManager's state into the given stream.

static void enableDebugLogging(boolean enabled);
//Control whether the framework's internal fragment manager debugging logs are turned on.

abstract boolean executePendingTransactions();
//After a FragmentTransaction is committed with FragmentTransaction.commit();, it is scheduled to be executed asynchronously on the process's main thread.

abstract Fragment findFragmentById(int id);
//Finds a fragment that was identified by the given id either when inflated from XML or as the container ID when added in a transaction.

abstract Fragment findFragmentByTag(String tag);
//Finds a fragment that was identified by the given tag either when inflated from XML or as supplied when added in a transaction.

abstract FragmentManager.BackStackEntry getBackStackEntryAt(int index);
//Return the BackStackEntry at index index in the back stack; entries start index 0 being the bottom of the stack.

abstract int getBackStackEntryCount();
//Return the number of entries currently in the back stack.

abstract Fragment getFragment(Bundle bundle, String key);
//Retrieve the current Fragment instance for a reference previously placed with putFragment(Bundle, String, Fragment);.

abstract void popBackStack();
//Pop the top state off the back stack.

abstract void popBackStack(String name, int flags);
//Pop the last fragment transition from the manager's fragment back stack.

abstract void popBackStack(int id, int flags);
//Pop all back stack states up to the one with the given identifier.

abstract boolean popBackStackImmediate(int id, int flags);
//Like popBackStack(int, int);, but performs the operation immediately inside of the call.

abstract boolean popBackStackImmediate(String name, int flags);
//Like popBackStack(String, int);, but performs the operation immediately inside of the call.

abstract boolean popBackStackImmediate();
//Like popBackStack();, but performs the operation immediately inside of the call.

abstract void putFragment(Bundle bundle, String key, Fragment fragment);
//Put a reference to a fragment in a Bundle.

abstract void removeOnBackStackChangedListener(FragmentManager.OnBackStackChangedListener listener);
//Remove a listener that was previously added with addOnBackStackChangedListener(OnBackStackChangedListener);.

abstract Fragment.SavedState saveFragmentInstanceState(Fragment f);
//Save the current instance state of the given Fragment.

}

class FragmentTransaction {
FragmentTransaction replace(int arg0, @Sink(DISPLAY) Fragment arg1);

abstract FragmentTransaction add(@Sink(DISPLAY) Fragment fragment, String tag);
//Calls add(int, Fragment, String); with a 0 containerViewId.

abstract FragmentTransaction add(int containerViewId, @Sink(DISPLAY) Fragment fragment);
//Calls add(int, Fragment, String); with a null tag.

abstract FragmentTransaction add(int containerViewId, @Sink(DISPLAY) Fragment fragment, String tag);
//Add a fragment to the activity state.

//abstract FragmentTransaction addToBackStack(String name);
//Add this transaction to the back stack.

abstract FragmentTransaction attach(@Sink(DISPLAY) Fragment fragment);
//Re-attach a fragment after it had previously been deatched from the UI with detach(Fragment);.

abstract int commit();
//Schedules a commit of this transaction.

abstract int commitAllowingStateLoss();
//Like commit(); but allows the commit to be executed after an activity's state is saved.

abstract FragmentTransaction detach(Fragment fragment);
//Detach the given fragment from the UI.

//abstract FragmentTransaction disallowAddToBackStack();
//Disallow calls to addToBackStack(String);.

//abstract FragmentTransaction hide(Fragment fragment);
//Hides an existing fragment.

//abstract boolean isAddToBackStackAllowed();
//Returns true if this FragmentTransaction is allowed to be added to the back stack.

//abstract boolean isEmpty();

abstract FragmentTransaction remove(Fragment fragment);
//Remove an existing fragment.

//abstract FragmentTransaction replace(int containerViewId, Fragment fragment, String tag);
//Replace an existing fragment that was added to a container.

//abstract FragmentTransaction replace(int containerViewId, Fragment fragment);
//Calls replace(int, Fragment, String); with a null tag.

//abstract FragmentTransaction setBreadCrumbShortTitle(int res);
//Set the short title to show as a bread crumb when this transaction is on the back stack.

//abstract FragmentTransaction setBreadCrumbShortTitle(CharSequence text);
//Like setBreadCrumbShortTitle(int); but taking a raw string; this method is not recommended, as the string can not be changed later if the locale changes.

//abstract FragmentTransaction setBreadCrumbTitle(CharSequence text);
//Like setBreadCrumbTitle(int); but taking a raw string; this method is not recommended, as the string can not be changed later if the locale changes.

//abstract FragmentTransaction setBreadCrumbTitle(int res);
//Set the full title to show as a bread crumb when this transaction is on the back stack.

//abstract FragmentTransaction setCustomAnimations(int enter, int exit, int popEnter, int popExit);
//Set specific animation resources to run for the fragments that are entering and exiting in this transaction.

//abstract FragmentTransaction setCustomAnimations(int enter, int exit);
//Set specific animation resources to run for the fragments that are entering and exiting in this transaction.

//abstract FragmentTransaction setTransition(int transit);
//Select a standard transition animation for this transaction.

//abstract FragmentTransaction setTransitionStyle(int styleRes);
//Set a custom style resource that will be used for resolving transit animations.

//abstract FragmentTransaction show(Fragment fragment);
//Shows a previously hidden fragment.

}

class IntentService{
        IntentService(String name);
        protected void onHandleIntent(@Source(FlowPermission.INTENT) Intent arg0);
}

class ListActivity {

ListAdapter getListAdapter();
//Get the ListAdapter associated with this activity's ListView.

ListView getListView();
//Get the activity's list view widget.

long getSelectedItemId();
//Get the cursor row ID of the currently selected list item.

int getSelectedItemPosition();
//Get the position of the currently selected list item.

void onContentChanged();
//Updates the screen state (current list and other views); when the content changes.

void setListAdapter(ListAdapter adapter);
//Provide the cursor for the list view.

void setSelection(int position);
//Set the currently selected list item to the specified position with the adapter's data

//Protected Methods
void onDestroy();
//Perform any final cleanup before an activity is destroyed.

void onListItemClick(ListView l, View v, int position, long id);
//This method will be called when an item in the list is selected.

void onRestoreInstanceState(Bundle state);
//Ensures the list view has been created before Activity restores all of the view states.

    
}

class ListFragment {
    
    
ListAdapter getListAdapter();
//Get the ListAdapter associated with this activity's ListView.

ListView getListView();
//Get the activity's list view widget.

long getSelectedItemId();
//Get the cursor row ID of the currently selected list item.

int getSelectedItemPosition();
//Get the position of the currently selected list item.

View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);
//Provide default implementation to return a simple list view.

void onDestroyView();
//Detach from list view.

void onListItemClick(ListView l, View v, int position, long id);
//This method will be called when an item in the list is selected.

void onViewCreated(View view, Bundle savedInstanceState);
//Attach to list view once the view hierarchy has been created.

void setEmptyText(CharSequence text);
//The default content for a ListFragment has a TextView that can be shown when the list is empty.

void setListAdapter(ListAdapter adapter);
//Provide the cursor for the list view.

void setListShown(boolean shown);
//Control whether the list is being displayed.

void setListShownNoAnimation(boolean shown);
//Like setListShown(boolean);, but no animation is used when transitioning from the previous state.

void setSelection(int position);
//Set the currently selected list item to the specified position with the adapter's data


}

class LoaderManager {
    
abstract void destroyLoader(int id);
//Stops and removes the loader with the given ID.

abstract void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the LoaderManager's state into the given stream.

static void enableDebugLogging(boolean enabled);
//Control whether the framework's internal loader manager debugging logs are turned on.

abstract <D> Loader<D> getLoader(int id);
//Return the Loader with the given id or null if no matching Loader is found.

abstract <D> Loader<D> initLoader(int id, Bundle args, LoaderCallbacks<D> callback);
//Ensures a loader is initialized and active.

abstract <D> Loader<D> restartLoader(int id, Bundle args, LoaderCallbacks<D> callback);
//Starts a new or restarts an existing Loader in this manager, registers the callbacks to it, and (if the activity/fragment is currently started); starts loading it.



}

class Notification {
    
Notification(int icon, CharSequence tickerText, long when);
//This constructor was deprecated in API level 11. Use Notification.Builder instead.

Notification clone();
//Creates and returns a copy of this Object.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void setLatestEventInfo(Context context, @Sink(DISPLAY) CharSequence contentTitle, @Sink(DISPLAY) CharSequence contentText, PendingIntent contentIntent);
//This method was deprecated in API level 11. Use Notification.Builder instead.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel parcel, int flags);
//Flatten this notification from a parcel.



}

class Notification$BigPictureStyle {
    
    
Notification.BigPictureStyle bigLargeIcon(@Sink(DISPLAY) Bitmap b);
//Override the large icon when the big notification is shown.

Notification.BigPictureStyle bigPicture(@Sink(DISPLAY) Bitmap b);
//Provide the bitmap to be used as the payload for the BigPicture notification.

Notification build();

Notification.BigPictureStyle setBigContentTitle(@Sink(DISPLAY) CharSequence title);
//Overrides ContentTitle in the big form of the template.

Notification.BigPictureStyle setSummaryText(@Sink(DISPLAY) CharSequence cs);
//Set the first line of text after the detail section in the big form of the template.



}

class Notification$BigTextStyle {
    
Notification.BigTextStyle bigText(@Sink(DISPLAY) CharSequence cs);
//Provide the longer text to be displayed in the big form of the template in place of the content text.

Notification build();

Notification.BigTextStyle setBigContentTitle(@Sink(DISPLAY) CharSequence title);
//Overrides ContentTitle in the big form of the template.

Notification.BigTextStyle setSummaryText(@Sink(DISPLAY) CharSequence cs);
//Set the first line of text after the detail section in the big form of the template.



}

class Notification$InboxStyle {
    
Notification.InboxStyle addLine(@Sink(DISPLAY) CharSequence cs);
//Append a line to the digest section of the Inbox notification.

Notification build();

Notification.InboxStyle setBigContentTitle(@Sink(DISPLAY) CharSequence title);
//Overrides ContentTitle in the big form of the template.

Notification.InboxStyle setSummaryText(@Sink(DISPLAY) CharSequence cs);
//Set the first line of text after the detail section in the big form of the template.





}


class Notification$Builder {
Notification.Builder addAction(@Sink(DISPLAY) int icon, @Sink(DISPLAY) CharSequence title, PendingIntent intent);
//Add an action to this notification.

Notification build();
//Combine all of the options that have been set and return a new Notification object.

Notification getNotification();
//This method was deprecated in API level 16. Use build(); instead.

Notification.Builder setAutoCancel(boolean autoCancel);
//Make this notification automatically dismissed when the user touches it.

Notification.Builder setContent(@Sink(DISPLAY) RemoteViews views);
//Supply a custom RemoteViews to use instead of the platform template.

Notification.Builder setContentInfo(@Sink(DISPLAY) CharSequence info);
//A small piece of additional information pertaining to this notification.

Notification.Builder setContentIntent(PendingIntent intent);
//Supply a PendingIntent to be sent when the notification is clicked.

Notification.Builder setContentText(@Sink(DISPLAY) CharSequence text);
//Set the second line of text in the platform notification template.

Notification.Builder setContentTitle(@Sink(DISPLAY) CharSequence title);
//Set the first line of text in the platform notification template.

Notification.Builder setDefaults(int defaults);
//Set which notification properties will be inherited from system defaults.

Notification.Builder setDeleteIntent(PendingIntent intent);
//Supply a PendingIntent to send when the notification is cleared explicitly by the user.

Notification.Builder setFullScreenIntent(PendingIntent intent, boolean highPriority);
//An intent to launch instead of posting the notification to the status bar.

Notification.Builder setLargeIcon(@Sink(DISPLAY) Bitmap icon);
//Add a large icon to the notification (and the ticker on some devices);.

Notification.Builder setLights(int argb, int onMs, int offMs);
//Set the desired color for the indicator LED on the device, as well as the blink duty cycle (specified in milliseconds);.

Notification.Builder setNumber(@Sink(DISPLAY) int number);
//Set the large number at the right-hand side of the notification.

Notification.Builder setOngoing(boolean ongoing);
//Set whether this is an "ongoing" notification.

Notification.Builder setOnlyAlertOnce(boolean onlyAlertOnce);
//Set this flag if you would only like the sound, vibrate and ticker to be played if the notification is not already showing.

Notification.Builder setPriority(int pri);
//Set the priority of this notification.

Notification.Builder setProgress(@Sink(DISPLAY) int max, @Sink(DISPLAY) int progress, boolean indeterminate);
//Set the progress this notification represents.

Notification.Builder setShowWhen(boolean show);
//Control whether the timestamp set with setWhen is shown in the content view.

Notification.Builder setSmallIcon(@Sink(DISPLAY) int icon, int level);
//A variant of setSmallIcon(int); that takes an additional level parameter for when the icon is a LevelListDrawable.

Notification.Builder setSmallIcon(@Sink(DISPLAY) int icon);
//Set the small icon resource, which will be used to represent the notification in the status bar.

Notification.Builder setSound(Uri sound);
//Set the sound to play.
//CSH: Do we need an AUDIO sink?

Notification.Builder setSound(Uri sound, int streamType);
//Set the sound to play, along with a specific stream on which to play it.
//CSH: Audio sink?

//Notification.Builder setStyle(Notification.Style style);
//Add a rich notification style to be applied at build time.

Notification.Builder setSubText(@Sink(DISPLAY) CharSequence text);
//Set the third line of text in the platform notification template.

Notification.Builder setTicker(@Sink(DISPLAY) CharSequence tickerText, @Sink(DISPLAY) RemoteViews views);
//Set the text that is displayed in the status bar when the notification first arrives, and also a RemoteViews object that may be displayed instead on some devices.

Notification.Builder setTicker(@Sink(DISPLAY) CharSequence tickerText);
//Set the "ticker" text which is displayed in the status bar when the notification first arrives.

Notification.Builder setUsesChronometer(boolean b);
//Show the when field as a stopwatch.

Notification.Builder setVibrate(@Sink(FlowPermission.VIBRATE) long[] pattern);
//Set the vibration pattern to use.

Notification.Builder setWhen(long when);
//Add a timestamp pertaining to the notification (usually the time the event occurred);.

}

class NotificationManager{
            void cancel(int id);
            void notify(int id, @Sink(DISPLAY) Notification notification);
}

class PendingIntent {
    
void cancel();
//Cancel a currently active PendingIntent.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object otherObj);
//Comparison operator on two PendingIntent objects, such that true is returned then they both represent the same operation from the same package.

static PendingIntent getActivities(Context context, int requestCode, Intent[] intents, int flags);
//Like getActivity(Context, int, Intent, int);, but allows an array of Intents to be supplied.

static PendingIntent getActivities(Context context, int requestCode, Intent[] intents, int flags, Bundle options);
//Like getActivity(Context, int, Intent, int);, but allows an array of Intents to be supplied.

static PendingIntent getActivity(Context context, int requestCode, Intent intent, int flags);
//Retrieve a PendingIntent that will start a new activity, like calling Context.startActivity(Intent);.

static PendingIntent getActivity(Context context, int requestCode, Intent intent, int flags, Bundle options);
//Retrieve a PendingIntent that will start a new activity, like calling Context.startActivity(Intent);.

static PendingIntent getBroadcast(Context context, int requestCode, Intent intent, int flags);
//Retrieve a PendingIntent that will perform a broadcast, like calling Context.sendBroadcast();.

String getCreatorPackage();
//Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.

int getCreatorUid();
//Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent.

UserHandle getCreatorUserHandle();
//Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent.

IntentSender getIntentSender();
//Retrieve a IntentSender object that wraps the existing sender of the PendingIntent

static PendingIntent getService(Context context, int requestCode, Intent intent, int flags);
//Retrieve a PendingIntent that will start a service, like calling Context.startService();.

String getTargetPackage();
//This method was deprecated in API level 17. Renamed to getCreatorPackage();.

int hashCode();
//Returns an integer hash code for this object.

static PendingIntent readPendingIntentOrNullFromParcel(Parcel in);
//Convenience function for reading either a Messenger or null pointer from a Parcel.

void send(int code);
//Perform the operation associated with this PendingIntent.

void send(Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler, String requiredPermission);
//Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed.

void send(int code, PendingIntent.OnFinished onFinished, Handler handler);
//Perform the operation associated with this PendingIntent, allowing the caller to be notified when the send has completed.

void send(Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler);
//Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed.

void send();
//Perform the operation associated with this PendingIntent.

void send(Context context, int code, Intent intent);
//Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use.

String toString();
//Returns a string containing a concise, human-readable description of this object.

static void writePendingIntentOrNullToParcel(@Sink(PARCEL) PendingIntent sender, Parcel out);
//Convenience function for writing either a PendingIntent or null pointer to a Parcel.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

}

class ProgressDialog {

int getMax();

int getProgress();

int getSecondaryProgress();

void incrementProgressBy(@Sink(DISPLAY) int diff);

void incrementSecondaryProgressBy(@Sink(DISPLAY) int diff);

boolean isIndeterminate();

void onStart();
//Called when the dialog is starting.

void setIndeterminate(@Sink(DISPLAY) boolean indeterminate);

void setIndeterminateDrawable(@Sink(DISPLAY) Drawable d);

void setMax(@Sink(DISPLAY) int max);

void setMessage(@Sink(DISPLAY) CharSequence message);

void setProgress(@Sink(DISPLAY) int value);

void setProgressDrawable(@Sink(DISPLAY) Drawable d);

void setProgressNumberFormat(String format);
//Change the format of the small text showing current and maximum units of progress.

void setProgressPercentFormat(NumberFormat format);
//Change the format of the small text showing the percentage of progress.

void setProgressStyle(int style);

void setSecondaryProgress(@Sink(DISPLAY) int secondaryProgress);

static ProgressDialog show(Context context, @Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence message);

static ProgressDialog show(Context context, @Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence message, @Sink(DISPLAY) boolean indeterminate, boolean cancelable);

static ProgressDialog show(Context context, @Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence message, @Sink(DISPLAY) boolean indeterminate, boolean cancelable, DialogInterface.OnCancelListener cancelListener);

static ProgressDialog show(Context context, @Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence message, @Sink(DISPLAY) boolean indeterminate);

//Protected Methods
void onCreate(Bundle savedInstanceState);
//Similar to onCreate(Bundle);, you should initialize your dialog in this method, including calling setContentView(View);.

void onStop();
//Called to tell you that you're stopping.


}

class SearchManager {
    
ComponentName getGlobalSearchActivity();
//Gets the name of the global search activity.

SearchableInfo getSearchableInfo(ComponentName componentName);
//Gets information about a searchable activity.

List<SearchableInfo> getSearchablesInGlobalSearch();
//Returns a list of the searchable activities that can be included in global search.

void onCancel(DialogInterface dialog);
//This method was deprecated in API level 4. This method is an obsolete internal implementation detail. Do not use.

void onDismiss(DialogInterface dialog);
//This method was deprecated in API level 4. This method is an obsolete internal implementation detail. Do not use.

void setOnCancelListener(SearchManager.OnCancelListener listener);
//Set or clear the callback that will be invoked whenever the search UI is canceled.

void setOnDismissListener(SearchManager.OnDismissListener listener);
//Set or clear the callback that will be invoked whenever the search UI is dismissed.

void startSearch(String initialQuery, boolean selectInitialQuery, ComponentName launchActivity, Bundle appSearchData, boolean globalSearch);
//Launch search UI.

void stopSearch();
//Terminate search UI.

void triggerSearch(String query, ComponentName launchActivity, Bundle appSearchData);
//Similar to startSearch(String, boolean, ComponentName, Bundle, boolean); but actually fires off the search query after invoking the search dialog.



}

class Service {

Service();    
//Creates a new Service
    
final Application getApplication();
//Return the application that owns this service.

abstract IBinder onBind(Intent intent);
//Return the communication channel to the service.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running.

void onCreate();
//Called by the system when the service is first created.

void onDestroy();
//Called by the system to notify a Service that it is no longer used and is being removed.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt.

void onRebind(Intent intent);
//Called when new clients have connected to the service, after it had previously been notified that all had disconnected in its onUnbind(Intent);.

void onStart(Intent intent, int startId);
//This method was deprecated in API level 5. Implement onStartCommand(Intent, int, int); instead.

int onStartCommand(Intent intent, int flags, int startId);
//Called by the system every time a client explicitly starts the service by calling startService(Intent);, providing the arguments it supplied and a unique integer token representing the start request.

void onTaskRemoved(Intent rootIntent);
//This is called if the service is currently running and the user has removed a task that comes from the service's application.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

boolean onUnbind(Intent intent);
//Called when all clients have disconnected from a particular interface published by the service.

final void startForeground(int id, Notification notification);
//Make this service run in the foreground, supplying the ongoing notification to be shown to the user while in this state.

final void stopForeground(boolean removeNotification);
//Remove this service from foreground state, allowing it to be killed if more memory is needed.

final void stopSelf();
//Stop the service, if it was previously started.

final void stopSelf(int startId);
//Old version of stopSelfResult(int); that doesn't return a result.

final boolean stopSelfResult(int startId);
//Stop the service if the most recent time it was started was startId.

//Protected Methods
void dump(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Service's state into the given stream.



}

class TabActivity {
    
    
TabHost getTabHost();
//Returns the TabHost the activity is using to host its tabs.

TabWidget getTabWidget();
//Returns the TabWidget the activity is using to draw the actual tabs.

void onContentChanged();
//Updates the screen state (current list and other views); when the content changes.

void setDefaultTab(String tag);
//Sets the default tab that is the first tab highlighted.

void setDefaultTab(int index);
//Sets the default tab that is the first tab highlighted.

//Protected Methods
void onChildTitleChanged(Activity childActivity, CharSequence title);

void onPostCreate(Bundle icicle);
//Called when activity start-up is complete (after onStart(); and onRestoreInstanceState(Bundle); have been called);.

void onRestoreInstanceState(Bundle state);
//This method is called after onStart(); when the activity is being re-initialized from a previously saved state, given here in savedInstanceState.

void onSaveInstanceState(Bundle outState);
//Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle); or onRestoreInstanceState(Bundle); (the Bundle populated by this method will be passed to both);.

    
    
}

package android.app.backup;

class BackupAgentHelper {
    
void addHelper(String keyPrefix, BackupHelper helper);
//Add a helper for a given data subset to the agent's configuration.

void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState);
//Run the backup process on each of the configured handlers.

void onRestore(BackupDataInput data, int appVersionCode, ParcelFileDescriptor newState);
//Run the restore process on each of the configured handlers.



}

class BackupManager {
    
    void dataChanged();
//Notifies the Android backup system that your application wishes to back up new changes to its data.

static void dataChanged(String packageName);
//Convenience method for callers who need to indicate that some other package needs a backup pass.
//CSH:  This method requires that the application hold the "android.permission.BACKUP" permission if the package named in the argument does not run under the same uid as the caller.
//BACKUP doesn't exist in the list

int requestRestore(RestoreObserver observer);
//Restore the calling application from backup.



}

class FileBackupHelper {
    
void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState);
//Based on oldState, determine which of the files from the application's data directory need to be backed up, write them to the data stream, and fill in newState with the state as it exists now.

void restoreEntity(BackupDataInputStream data);
//Restore one record [representing a single file] from the restore dataset.

void writeNewStateDescription(ParcelFileDescriptor fd);
//Called by BackupAgentHelper after a restore operation to write the backup state file corresponding to the data as processed by the helper.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.



}

class SharedPreferencesBackupHelper {
    
    
void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState);
//Backs up the configured SharedPreferences groups.

void restoreEntity(BackupDataInputStream data);
//Restores one entity from the restore data stream to its proper shared preferences file store.

void writeNewStateDescription(ParcelFileDescriptor fd);
//Called by BackupAgentHelper after a restore operation to write the backup state file corresponding to the data as processed by the helper.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.



}
package android.bluetooth;
class BluetoothAdapter{
        static BluetoothAdapter getDefaultAdapter();
        boolean enable();
        boolean disable();
}
package android.content;

class AsyncTaskLoader {
    
    
void cancelLoadInBackground();
//Called on the main thread to abort a load in progress.

void dump(String prefix, @Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

boolean isLoadInBackgroundCanceled();
//Returns true if the current invocation of loadInBackground(); is being canceled.

abstract D loadInBackground();
//Called on a worker thread to perform the actual load and to return the result of the load operation.

void onCanceled(D data);
//Called if the task was canceled before it was completed.

void setUpdateThrottle(long delayMS);
//Set amount to throttle updates by.

//Protected Methods
boolean onCancelLoad();
//Subclasses must implement this to take care of requests to cancelLoad();.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

D onLoadInBackground();
//Calls loadInBackground();.



}
class BroadcastReceiver {
    
//CSH:  Not sure how to do this class.  It's probably ANY/ANY, since you sometimes need permissions to use this...  

BroadcastReceiver();
//New BraodcastReceiver

final void abortBroadcast();
//Sets the flag indicating that this receiver should abort the current broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void clearAbortBroadcast();
//Clears the flag indicating that this receiver should abort the current broadcast.

final boolean getAbortBroadcast();
//Returns the flag indicating whether or not this receiver should abort the current broadcast.

final boolean getDebugUnregister();
//Return the last value given to setDebugUnregister(boolean);.

final int getResultCode();
//Retrieve the current result code, as set by the previous receiver.

final String getResultData();
//Retrieve the current result data, as set by the previous receiver.

final Bundle getResultExtras(boolean makeMap);
//Retrieve the current result extra data, as set by the previous receiver.

final BroadcastReceiver.PendingResult goAsync();
//This can be called by an application in onReceive(Context, Intent); to allow it to keep the broadcast active after returning from that function.

final boolean isInitialStickyBroadcast();
//Returns true if the receiver is currently processing the initial value of a sticky broadcast -- that is, the value that was last broadcast and is currently held in the sticky cache, so this is not directly the result of a broadcast right now.

final boolean isOrderedBroadcast();
//Returns true if the receiver is currently processing an ordered broadcast.

abstract void onReceive(Context context, Intent intent);
//This method is called when the BroadcastReceiver is receiving an Intent broadcast.

IBinder peekService(Context myContext, Intent service);
//Provide a binder to an already-running service.

final void setDebugUnregister(boolean debug);
//Control inclusion of debugging help for mismatched calls to Context.registerReceiver();.

final void setOrderedHint(boolean isOrdered);
//For internal use, sets the hint about whether this BroadcastReceiver is running in ordered mode.

final void setResult(int code, String data, Bundle extras);
//Change all of the result data returned from this broadcasts; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultCode(int code);
//Change the current result code of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultData(String data);
//Change the current result data of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.

final void setResultExtras(Bundle extras);
//Change the current result extras of this broadcast; only works with broadcasts sent through Context.sendOrderedBroadcast.



}
class ClipData{
        static ClipData newPlainText(CharSequence label, CharSequence text);
}

class ClipboardManager extends ClipboardManager {
//ClipData objects not annotated, because the class itself is annoated
//SOM
    void setPrimaryClip(ClipData arg0);
    ClipData getPrimaryClip();
    ClipDescription getPrimaryClipDescription();
    boolean hasPrimaryClip();
    void addPrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    void removePrimaryClipChangedListener(OnPrimaryClipChangedListener arg0);
    @Source(READ_CLIPBOARD) CharSequence getText();
    void setText(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    boolean hasText();
}
class ClipData implements Parcelable {
    ClipData(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) String @Sink(WRITE_CLIPBOARD) [] arg1, @Sink(WRITE_CLIPBOARD) Item arg2);
    ClipData(ClipDescription arg0, @Sink(WRITE_CLIPBOARD)  Item arg1);
    static ClipData newPlainText(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1);
    static ClipData newIntent(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1);
    static ClipData newUri(@Sink(WRITE_CLIPBOARD) ContentResolver arg0, @Sink(WRITE_CLIPBOARD) CharSequence arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    static ClipData newRawUri(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Uri arg1);
    @Source(READ_CLIPBOARD) ClipDescription getDescription();
    void addItem(@Sink(WRITE_CLIPBOARD) Item arg0);
    int getItemCount();
    @Source(READ_CLIPBOARD) Item getItemAt(@Sink(WRITE_CLIPBOARD) int arg0);
    int describeContents();
    void writeToParcel(@Source(READ_CLIPBOARD) Parcel arg0, int arg1);
}
class ClipData$Item {
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
    Item(@Sink(WRITE_CLIPBOARD) Intent arg0);
    Item(@Sink(WRITE_CLIPBOARD) Uri arg0);
    Item(@Sink(WRITE_CLIPBOARD) CharSequence arg0, @Sink(WRITE_CLIPBOARD) Intent arg1, @Sink(WRITE_CLIPBOARD) Uri arg2);
    @Source(READ_CLIPBOARD) CharSequence getText();
    @Source(READ_CLIPBOARD) Intent getIntent();
    @Source(READ_CLIPBOARD) Uri getUri();
    @Source(READ_CLIPBOARD) CharSequence coerceToText(@Sink(WRITE_CLIPBOARD) Context arg0);
}

class ComponentName {
    
ComponentName clone();
//Creates and returns a copy of this Object.

int compareTo(ComponentName that);

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object obj);
//Compares this instance with the specified object and indicates if they are equal.

String flattenToShortString();
//The same as flattenToString();, but abbreviates the class name if it is a suffix of the package.

String flattenToString();
//Return a String that unambiguously describes both the package and class names contained in the ComponentName.

String getClassName();
//Return the class name of this component.

String getPackageName();
//Return the package name of this component.

String getShortClassName();
//Return the class name, either fully qualified or in a shortened form (with a leading '.'); if it is a suffix of the package.

int hashCode();
//Returns an integer hash code for this object.

static @Source(PARCEL) ComponentName readFromParcel(Parcel in);
//Read a ComponentName from a Parcel that was previously written with writeToParcel(ComponentName, Parcel);, returning either a null or new object as appropriate.

String toShortString();
//Return string representation of this class without the class's name as a prefix.

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ComponentName unflattenFromString(String str);
//Recover a ComponentName from a String that was previously created with flattenToString();.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

static void writeToParcel(@Sink(PARCEL) ComponentName c, Parcel out);
//Write a ComponentName to a Parcel, handling null pointers.

    
}

class ComponentCallbacks{
            void onLowMemory();
            void onConfigurationChanged(Configuration arg0);
}
class ComponentName{
            ComponentName(Context pkg, String cls);
            String getPackageName();
}

class ContentProvider {

//CSH: content providers are tricky because they look like SQL queries, but can be implemented with anything, files, in-memory objects, databases, etc... not quite sure what to do here
    
ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations);
//Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call apply(ContentProvider, ContentProviderResult[], int); on each of them.

void attachInfo(Context context, ProviderInfo info);
//After being instantiated, this is called to tell the content provider about itself.

int bulkInsert(Uri uri, ContentValues[] values);
//Override this to handle requests to insert a set of new rows, or the default implementation will iterate over the values and call insert(Uri, ContentValues); on each of them.

Bundle call(String method, String arg, Bundle extras);
//Call a provider-defined method.

abstract int delete(Uri uri, String selection, String[] selectionArgs);
//Implement this to handle requests to delete one or more rows.

final Context getContext();
//Retrieves the Context this provider is running in.

final PathPermission[] getPathPermissions();
//Return the path-based permissions required for read and/or write access to this content provider.

final String getReadPermission();
//Return the name of the permission required for read-only access to this content provider.

String[] getStreamTypes(Uri uri, String mimeTypeFilter);
//Called by a client to determine the types of data streams that this content provider supports for the given URI.

abstract String getType(Uri uri);
//Implement this to handle requests for the MIME type of the data at the given URI.

final String getWritePermission();
//Return the name of the permission required for read/write access to this content provider.

abstract Uri insert(Uri uri, ContentValues values);
//Implement this to handle requests to insert a new row.

void onConfigurationChanged(Configuration newConfig);
//Called by the system when the device configuration changes while your component is running. This method is always called on the application main thread, and must not perform lengthy operations.

abstract boolean onCreate();
//Implement this to initialize your content provider on startup.

void onLowMemory();
//This is called when the overall system is running low on memory, and would like actively running process to try to tighten their belt. This method is always called on the application main thread, and must not perform lengthy operations.

void onTrimMemory(int level);
//Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process.

AssetFileDescriptor openAssetFile(Uri uri, String mode);
//This is like openFile(Uri, String);, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk.

ParcelFileDescriptor openFile(Uri uri, String mode);
//Override this to handle requests to open a file blob.

<T> ParcelFileDescriptor openPipeHelper(Uri uri, String mimeType, Bundle opts, T args, PipeDataWriter<T> func);
//A helper function for implementing openTypedAssetFile(Uri, String, Bundle);, for creating a data pipe and background thread allowing you to stream generated data back to the client.

AssetFileDescriptor openTypedAssetFile(Uri uri, String mimeTypeFilter, Bundle opts);
//Called by a client to open a read-only stream containing data of a particular MIME type.

@PolyFlowReceiver
abstract Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Implement this to handle query requests from clients.

@PolyFlowReceiver
Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Implement this to handle query requests from clients with support for cancellation.

void shutdown();
//Implement this to shut down the ContentProvider instance.

abstract int update(@PolySink @PolySource Uri uri, @PolySink @PolySource ContentValues values, String selection, String[] selectionArgs);
//Implement this to handle requests to update one or more rows.

//Protected Methods
boolean isTemporary();
//Returns true if this instance is a temporary content provider.

final ParcelFileDescriptor openFileHelper(Uri uri, String mode);
//Convenience for subclasses that wish to implement openFile(Uri, String); by looking up a column named "_data" at the given URI.

final void setPathPermissions(PathPermission[] permissions);
//Change the path-based permission required to read and/or write data in the content provider.

final void setReadPermission(String permission);
//Change the permission required to read data from the content provider.

final void setWritePermission(String permission);
//Change the permission required to read and write data in the content provider.

}

class ContentResolver {
    
final ContentProviderClient acquireContentProviderClient(Uri uri);
//Returns a ContentProviderClient that is associated with the ContentProvider that services the content at uri, starting the provider if necessary.

final ContentProviderClient acquireContentProviderClient(String name);
//Returns a ContentProviderClient that is associated with the ContentProvider with the authority of name, starting the provider if necessary.

final ContentProviderClient acquireUnstableContentProviderClient(Uri uri);
//Like acquireContentProviderClient(Uri);, but for use when you do not trust the stability of the target content provider.

final ContentProviderClient acquireUnstableContentProviderClient(String name);
//Like acquireContentProviderClient(String);, but for use when you do not trust the stability of the target content provider.

static void addPeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras, @Sink(WRITE_SYNC_SETTINGS) long pollFrequency);
//Specifies that a sync should be requested with the specified the account, authority, and extras at the given frequency.

static Object addStatusChangeListener(int mask, SyncStatusObserver callback);
//Request notifications when the different aspects of the SyncManager change.

ContentProviderResult[] applyBatch(String authority, ArrayList<ContentProviderOperation> operations);
//Applies each of the ContentProviderOperation objects and returns an array of their results.

final int bulkInsert(Uri url, ContentValues[] values);
//Inserts multiple rows into a table at the given URL.

final Bundle call(Uri uri, String method, String arg, Bundle extras);
//Call a provider-defined method.

static void cancelSync(Account account, String authority);
//Cancel any active or pending syncs that match account and authority.

void cancelSync(Uri uri);
//This method was deprecated in API level 5. instead use cancelSync(android.accounts.Account, String);

final int delete(Uri url, String where, String[] selectionArgs);
//Deletes row(s); specified by a content URI.

static @Source(READ_SYNC_STATS) SyncInfo getCurrentSync();
//This method was deprecated in API level 11. Since multiple concurrent syncs are now supported you should use getCurrentSyncs(); to get the accurate list of current syncs. This method returns the first item from the list of current syncs or null if there are none.

static @Source(READ_SYNC_STATS) List<SyncInfo> getCurrentSyncs();
//Returns a list with information about all the active syncs.

static @Source(READ_SYNC_SETTINGS) int getIsSyncable(Account account, String authority);
//Check if this account/provider is syncable.

static  @Source(READ_SYNC_SETTINGS) boolean getMasterSyncAutomatically();
//Gets the master auto-sync setting that applies to all the providers and accounts.

static  @Source(READ_SYNC_SETTINGS) List<PeriodicSync> getPeriodicSyncs(Account account, String authority);
//Get the list of information about the periodic syncs for the given account and authority.

String[] getStreamTypes(Uri url, String mimeTypeFilter);
//Query for the possible MIME types for the representations the given content URL can be returned when opened as as stream with openTypedAssetFileDescriptor(Uri, String, Bundle);.

static SyncAdapterType[] getSyncAdapterTypes();
//Get information about the SyncAdapters that are known to the system.

static @Source(READ_SYNC_SETTINGS) boolean getSyncAutomatically(Account account, String authority);
//Check if the provider should be synced when a network tickle is received
//This method requires the caller to hold the permission READ_SYNC_SETTINGS.

final String getType(Uri url);
//Return the MIME type of the given content URL.

final Uri insert(Uri url, ContentValues values);
//Inserts a row into a table at the given URL.

static @Source(READ_SYNC_STATS) boolean isSyncActive(Account account, String authority);
//Returns true if there is currently a sync operation for the given account or authority in the pending list, or actively being processed.

static @Source(READ_SYNC_STATS) boolean isSyncPending(Account account, String authority);
//Return true if the pending status is true of any matching authorities.

void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork);
//Notify registered observers that a row was updated.

void notifyChange(Uri uri, ContentObserver observer);
//Notify registered observers that a row was updated and attempt to sync changes to the network.

final AssetFileDescriptor openAssetFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final ParcelFileDescriptor openFileDescriptor(Uri uri, String mode);
//Open a raw file descriptor to access data under a URI.

final InputStream openInputStream(Uri uri);
//Open a stream on to the content associated with a content URI.

final OutputStream openOutputStream(Uri uri);
//Synonym for openOutputStream(uri, "w");.

final OutputStream openOutputStream(Uri uri, String mode);
//Open a stream on to the content associated with a content URI.

final AssetFileDescriptor openTypedAssetFileDescriptor(Uri uri, String mimeType, Bundle opts);
//Open a raw file descriptor to access (potentially type transformed); data from a "content:" URI.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
//Query the given URI, returning a Cursor over the result set.

final @PolySource @PolySink Cursor query(@PolySource @PolySink Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal);
//Query the given URI, returning a Cursor over the result set.

final void registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer);
//Register an observer class that gets callbacks when data identified by a given content URI changes.

static void removePeriodicSync(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) Bundle extras);
//Remove a periodic sync.

static void removeStatusChangeListener(Object handle);
//Remove a previously registered status change listener.

static void requestSync(Account account, String authority, Bundle extras);
//Start an asynchronous sync operation.

static void setIsSyncable(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) int syncable);
//Set whether this account/provider is syncable.

static void setMasterSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Sets the master auto-sync setting that applies to all the providers and accounts.

static void setSyncAutomatically(@Sink(WRITE_SYNC_SETTINGS) Account account, @Sink(WRITE_SYNC_SETTINGS) String authority, @Sink(WRITE_SYNC_SETTINGS) boolean sync);
//Set whether or not the provider is synced when it receives a network tickle.

void startSync(Uri uri, Bundle extras);
//This method was deprecated in API level 5. instead use requestSync(android.accounts.Account, String, android.os.Bundle);

final void unregisterContentObserver(ContentObserver observer);
//Unregisters a change observer.

final int update(@PolySource @PolySink Uri uri, @PolySource @PolySink ContentValues values, String where, String[] selectionArgs);
//Update row(s); in a content URI.

static void validateSyncExtrasBundle(Bundle extras);
//Check that only values of the following types are in the Bundle:
//Integer
//Long
//Boolean
//Float
//Double
//String
//Account
//null


}

class ContentUris {
    
static Uri.Builder appendId(Uri.Builder builder, long id);
//Appends the given ID to the end of the path.

static long parseId(Uri contentUri);
//Converts the last path segment to a long.

static Uri withAppendedId(Uri contentUri, long id);
//Appends the given ID to the end of the path.



}

@PolyFlowReceiver
class ContentValues {
    
void clear();
//Removes all values.

boolean containsKey(String key);
//Returns true if this object has the named value.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object object);
//Compares this instance with the specified object and indicates if they are equal.

Object get(String key);
//Gets a value.

Boolean getAsBoolean(String key);
//Gets a value and converts it to a Boolean.

Byte getAsByte(String key);
//Gets a value and converts it to a Byte.

byte[] getAsByteArray(String key);
//Gets a value that is a byte array.

Double getAsDouble(String key);
//Gets a value and converts it to a Double.

Float getAsFloat(String key);
//Gets a value and converts it to a Float.

Integer getAsInteger(String key);
//Gets a value and converts it to an Integer.

Long getAsLong(String key);
//Gets a value and converts it to a Long.

Short getAsShort(String key);
//Gets a value and converts it to a Short.

String getAsString(String key);
//Gets a value and converts it to a String.

int hashCode();
//Returns an integer hash code for this object.

Set<String> keySet();
//Returns a set of all of the keys
void put(String key, Byte value);
//Adds a value to the set.

void put(String key, Integer value);
//Adds a value to the set.

void put(String key, Float value);
//Adds a value to the set.

void put(String key, Short value);
//Adds a value to the set.

void put(String key, byte[] value);
//Adds a value to the set.

void put(String key, String value);
//Adds a value to the set.

void put(String key, Double value);
//Adds a value to the set.

void put(String key, Long value);
//Adds a value to the set.

void put(String key, Boolean value);
//Adds a value to the set.

void putAll(ContentValues other);
//Adds all values from the passed in ContentValues.

void putNull(String key);
//Adds a null value to the set.

void remove(String key);
//Remove a single value.

int size();
//Returns the number of values.

String toString();
//Returns a string containing a concise, human-readable description of this object.

Set<Entry<String, Object>> valueSet();
//Returns a set of all of the keys and values

void writeToParcel(Parcel parcel, int flags);
//Flatten this object in to a Parcel.

}


class ContentProviderOperation {
    
ContentProviderResult apply(ContentProvider provider, ContentProviderResult[] backRefs, int numBackRefs);
//Applies this operation using the given provider.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

Uri getUri();

boolean isReadOperation();

boolean isWriteOperation();

boolean isYieldAllowed();

static ContentProviderOperation.Builder newAssertQuery(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a ContentProviderOperation to assert a set of values as provided through withValues(ContentValues);.

static ContentProviderOperation.Builder newDelete(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building a delete ContentProviderOperation.

static ContentProviderOperation.Builder newInsert(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an insert ContentProviderOperation.

static ContentProviderOperation.Builder newUpdate(Uri uri);
//Create a ContentProviderOperation.Builder suitable for building an update ContentProviderOperation.

String[] resolveSelectionArgsBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The Selection Arguments back references are represented as a Map of Integer->Integer where the key is an index into the selection argument array (see withSelection(String, String[]);); and the value is the index of the previous result that should be used for that selection argument array slot.

ContentValues resolveValueBackReferences(ContentProviderResult[] backRefs, int numBackRefs);
//The ContentValues back references are represented as a ContentValues object where the key refers to a column and the 
//value is an index of the back reference whose valued should be associated with the column.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.



    
    
}

class ContentProviderOperation$Builder {
    
    
ContentProviderOperation build();
//Create a ContentProviderOperation from this ContentProviderOperation.Builder.

ContentProviderOperation.Builder withExpectedCount(int count);
//If set then if the number of rows affected by this operation do not match this count OperationApplicationException will be throw.

ContentProviderOperation.Builder withSelection(String selection, String[] selectionArgs);
//The selection and arguments to use.

ContentProviderOperation.Builder withSelectionBackReference(int selectionArgIndex, int previousResult);
//Add a back references as a selection arg.

ContentProviderOperation.Builder withValue(String key, @Sink(CONTENT_PROVIDER) Object value);
//A value to insert or update.

ContentProviderOperation.Builder withValueBackReference(String key, int previousResult);
//Add a ContentValues back reference.

ContentProviderOperation.Builder withValueBackReferences(@Sink(CONTENT_PROVIDER) ContentValues backReferences);
//Add a ContentValues of back references.

ContentProviderOperation.Builder withValues(@Sink(CONTENT_PROVIDER) ContentValues values);
//The ContentValues to use.

ContentProviderOperation.Builder withYieldAllowed(boolean yieldAllowed);
//


}


class ContentResolver{
        //Uri insert(Uri url, ContentValues values);
        //int delete(Uri url, String where, String[] selectionArgs);
        ContentProviderResult[] applyBatch(String authority, ArrayList<ContentProviderOperation> operations) throws RemoteException,OperationApplicationException;
        //Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder);
        //int update(Uri uri, ContentValues values, String where, String[] selectionArgs);
                  int delete(@Sink(DATABASE) Uri url, @Sink(DATABASE) String where, @Sink(DATABASE) String[] selectionArgs);
            int update(@Sink(DATABASE) Uri uri, @Sink(DATABASE) ContentValues values, @Sink(DATABASE) String where, @Sink(DATABASE) String[] selectionArgs);
            void notifyChange(Uri uri, ContentObserver observer);
            @Source(DATABASE) Uri insert(@Sink(DATABASE) Uri url, @Sink(DATABASE) ContentValues values);
            @Source(DATABASE) Cursor query(@Sink(DATABASE) Uri uri, @Sink(DATABASE) String[] projection, @Sink(DATABASE) String selection, @Sink(DATABASE) String[] selectionArgs, @Sink(DATABASE) String sortOrder);
}

class Context {
abstract boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

abstract int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

abstract int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

abstract int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

abstract int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

abstract int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

abstract int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

abstract int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

abstract void clearWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

abstract Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

abstract Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

abstract @Source(DATABASE) String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

abstract boolean deleteDatabase(@Sink(DATABASE) String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

abstract boolean deleteFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Delete the given private file associated with this Context's application package.

abstract void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

abstract void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

abstract void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

abstract void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

abstract void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

abstract Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

abstract ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

abstract AssetManager getAssets();
//Return an AssetManager instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE})File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

abstract ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

abstract ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getDatabasePath(@Sink(DATABASE) String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

abstract @Source({FILESYSTEM}) File getDir(@Sink({FILESYSTEM}) String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

abstract @Source({READ_EXTERNAL_STORAGE}) File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

abstract @Source({READ_EXTERNAL_STORAGE}) File getExternalFilesDir(@Sink(WRITE_EXTERNAL_STORAGE) String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getFileStreamPath(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

abstract Looper getMainLooper();
//Return the Looper for the main thread of the current process.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

abstract String getPackageCodePath();
//Return the full path to this context's primary Android package.

abstract PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

abstract @Source(LITERAL) String getPackageName();
//Return the name of this application's package.

abstract @Source(LITERAL)String getPackageResourcePath();
//Return the full path to this context's primary Android package.

abstract Resources getResources();
//Return a Resources instance for your application's package.

abstract @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(@Sink(SHARED_PREFERENCES) String name, @Sink(SHARED_PREFERENCES) int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

final @Source(LITERAL) String getString(int resId);
//Return a localized string from the application's package's default string table.

final @Source(LITERAL) String getString(int resId, Object... formatArgs);
//Return a localized formatted string from the application's package's default string table, substituting the format arguments as defined in Formatter and format(String, Object...);.

abstract Object getSystemService(String name);
//Return the handle to a system-level service by name.

final @Source(LITERAL) CharSequence getText(int resId);
//Return a localized, styled CharSequence from the application's package's default string table.

abstract Resources.Theme getTheme();
//Return the Theme object associated with this Context.

abstract Drawable getWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.get(); instead.

abstract int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumHeight(); instead.

abstract int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level 5. Use WallpaperManager.getDesiredMinimumWidth(); instead.

abstract void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

boolean isRestricted();
//Indicates whether this Context is restricted.

final TypedArray obtainStyledAttributes(int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(int resid, int[] attrs);
//Retrieve styled attribute information in this Context's theme.

final TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes);
//Retrieve styled attribute information in this Context's theme.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) FileInputStream openFileInput(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name);
//Open a private file associated with this Context's application package for reading.

abstract @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) FileOutputStream openFileOutput(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String name, int mode);
//Open a private file associated with this Context's application package for writing.

abstract @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(SQLITE_DATABASE) String name, @Sink(SQLITE_DATABASE) int mode, @Sink(SQLITE_DATABASE) SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink(SQLITE_DATABASE) String name, @Sink(SQLITE_DATABASE) int mode, @Sink(SQLITE_DATABASE) SQLiteDatabase.CursorFactory factory, @Sink(SQLITE_DATABASE) DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

abstract Drawable peekWallpaper();
//This method was deprecated in API level 5. Use WallpaperManager.peek(); instead.

void registerComponentCallbacks(ComponentCallbacks callback);
//Add a new ComponentCallbacks to the base application of the Context, which will be called at the same times as the ComponentCallbacks methods of activities and other components are called.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

abstract void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

abstract void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

abstract void sendBroadcast(Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

abstract void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

abstract void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

abstract void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

abstract void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

abstract void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

abstract void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

abstract void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

abstract void setTheme(int resid);
//Set the base theme for this context.

abstract void setWallpaper(@Sink(SET_WALLPAPER) Bitmap bitmap);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void setWallpaper(@Sink(SET_WALLPAPER) InputStream data);
//This method was deprecated in API level 5. Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

abstract void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

abstract void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

abstract void startActivity(Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

abstract void startActivity(Intent intent, Bundle options);
//Launch a new activity.

abstract boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

abstract void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

abstract ComponentName startService(Intent service);
//Request that a given application service be started.

abstract boolean stopService(Intent service);
//Request that a given application service be stopped.

abstract void unbindService(ServiceConnection conn);
//Disconnect from an application service.

void unregisterComponentCallbacks(ComponentCallbacks callback);
//Remove a ComponentCallbacks objec that was previously registered with registerComponentCallbacks(ComponentCallbacks);.

abstract void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

}

class ComponentName{
            String getClassName();
      ComponentName(Context pkg, Class<?> cls);

}

class ContextWrapper {
            File getDir(String name, int mode);
            ContextWrapper(Context base);
             Context createPackageContext(String packageName, int flags) throws NameNotFoundException;            
                        String getPackageName();
            ComponentName startService(Intent service);
            PackageManager getPackageManager();
            @Source(FILESYSTEM) File getFilesDir();
            AssetManager getAssets();
            Context getApplicationContext();
            Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
            Context getBaseContext();
            void sendBroadcast(Intent intent);
            @Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences(String name, int mode);
                        ContentResolver getContentResolver();

void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

boolean stopService(Intent name);
//Request that a given application service be stopped.

boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//boolean bindService(Intent service, ServiceConnection conn, int flags);
//Connect to an application service, creating it if needed.

//int checkCallingOrSelfPermission(String permission);
//Determine whether the calling process of an IPC or you have been granted a particular permission.

//int checkCallingOrSelfUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process of an IPC or you has been granted permission to access a specific URI.

//int checkCallingPermission(String permission);
//Determine whether the calling process of an IPC you are handling has been granted a particular permission.

//int checkCallingUriPermission(Uri uri, int modeFlags);
//Determine whether the calling process and user ID has been granted permission to access a specific URI.

//int checkPermission(String permission, int pid, int uid);
//Determine whether the given permission is allowed for a particular process and user ID running in the system.

//int checkUriPermission(Uri uri, int pid, int uid, int modeFlags);
//Determine whether a particular process and user ID has been granted permission to access a specific URI.

//int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags);
//Check both a Uri and normal permission.

//void clearWallpaper();
//This method was deprecated in API level . Use WallpaperManager.clear(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//Context createConfigurationContext(Configuration overrideConfiguration);
//Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration.

//Context createDisplayContext(Display display);
//Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display.

//Context createPackageContext(String packageName, int flags);
//Return a new Context object for the given application name.

//String[] databaseList();
//Returns an array of strings naming the private databases associated with this Context's application package.

//boolean deleteDatabase(String name);
//Delete an existing private SQLiteDatabase associated with this Context's application package.

//boolean deleteFile(String name);
//Delete the given private file associated with this Context's application package.

//void enforceCallingOrSelfPermission(String permission, String message);
//If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a SecurityException.

//void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message);
//If the calling process of an IPC or you has not been granted permission to access a specific URI, throw SecurityException.

//void enforceCallingPermission(String permission, String message);
//If the calling process of an IPC you are handling has not been granted a particular permission, throw a SecurityException.

//void enforceCallingUriPermission(Uri uri, int modeFlags, String message);
//If the calling process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforcePermission(String permission, int pid, int uid, String message);
//If the given permission is not allowed for a particular process and user ID running in the system, throw a SecurityException.

//void enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message);
//If a particular process and user ID has not been granted permission to access a specific URI, throw SecurityException.

//void enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message);
//Enforce both a Uri and normal permission.

//String[] fileList();
//Returns an array of strings naming the private files associated with this Context's application package.

Context getApplicationContext();
//Return the context of the single, global Application object of the current process.

//ApplicationInfo getApplicationInfo();
//Return the full application info for this context's package.

AssetManager getAssets();
//Return an AssetManager instance for your application's package.

Context getBaseContext();

//File getCacheDir();
//Returns the absolute path to the application specific cache directory on the filesystem.

ClassLoader getClassLoader();
//Return a class loader you can use to retrieve classes in this package.

//ContentResolver getContentResolver();
//Return a ContentResolver instance for your application's package.

//File getDatabasePath(String name);
//Returns the absolute path on the filesystem where a database created with openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory); is stored.

//File getDir(String name, int mode);
//Retrieve, creating if needed, a new directory in which the application can place its own custom data files.

//File getExternalCacheDir();
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory(); where the application can place cache files it owns.

//File getExternalFilesDir(String type);
//Returns the absolute path to the directory on the external filesystem (that is somewhere on Environment.getExternalStorageDirectory();); where the application can place persistent files it owns.

//File getFileStreamPath(String name);
//Returns the absolute path on the filesystem where a file created with openFileOutput(String, int); is stored.

//File getFilesDir();
//Returns the absolute path to the directory on the filesystem where files created with openFileOutput(String, int); are stored.

//Looper getMainLooper();
//Return the Looper for the main thread of the current process.

//File getObbDir();
//Return the directory where this application's OBB files (if there are any); can be found.

//String getPackageCodePath();
//Return the full path to this context's primary Android package.

//PackageManager getPackageManager();
//Return PackageManager instance to find global package information.

//String getPackageName();
//Return the name of this application's package.

//String getPackageResourcePath();
//Return the full path to this context's primary Android package.

Resources getResources();
//Return a Resources instance for your application's package.

//SharedPreferences getSharedPreferences(String name, int mode);
//Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//Drawable getWallpaper();
//This method was deprecated in API level . Use WallpaperManager.get(); instead.

//int getWallpaperDesiredMinimumHeight();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumHeight(); instead.

//int getWallpaperDesiredMinimumWidth();
//This method was deprecated in API level . Use WallpaperManager.getDesiredMinimumWidth(); instead.

//void grantUriPermission(String toPackage, Uri uri, int modeFlags);
//Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider.

//boolean isRestricted();
//Indicates whether this Context is restricted.

//FileInputStream openFileInput(String name);
//Open a private file associated with this Context's application package for reading.

//FileOutputStream openFileOutput(String name, int mode);
//Open a private file associated with this Context's application package for writing.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory);
//Open a new private SQLiteDatabase associated with this Context's application package.

//SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler);
//Open a new private SQLiteDatabase associated with this Context's application package.

//Drawable peekWallpaper();
//This method was deprecated in API level . Use WallpaperManager.peek(); instead.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
//Register a BroadcastReceiver to be run in the main activity thread.

//Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler);
//Register to receive intent broadcasts, to run in the context of scheduler.

//void removeStickyBroadcast(Intent intent);
//Remove the data previously sent with sendStickyBroadcast(Intent);, so that it is as if the sticky broadcast had never happened.

//void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of removeStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void revokeUriPermission(Uri uri, int modeFlags);
//Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int);.

void sendBroadcast(@Source(FlowPermission.INTENT) Intent intent);
//Broadcast the given intent to all interested BroadcastReceivers.

//void sendBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced.

//void sendBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);
//Version of sendBroadcast(Intent, String); that allows you to specify the user the broadcast will be sent to.

//void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendOrderedBroadcast(Intent intent, String receiverPermission);
//Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers.

//void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void sendStickyBroadcast(Intent intent);
//Perform a sendBroadcast(Intent); that is "sticky," meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter);.

//void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
//Version of sendStickyBroadcast(Intent); that allows you to specify the user the broadcast will be sent to.

//void sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyBroadcast(Intent); that allows you to receive data back from the broadcast.

//void sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras);
//Version of sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle); that allows you to specify the user the broadcast will be sent to.

//void setTheme(int resid);
//Set the base theme for this context.

//void setWallpaper(Bitmap bitmap);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void setWallpaper(InputStream data);
//This method was deprecated in API level . Use WallpaperManager.set(); instead.
//This method requires the caller to hold the permission SET_WALLPAPER.

//void startActivities(Intent[] intents);
//Same as startActivities(Intent[], Bundle); with no options specified.

//void startActivities(Intent[] intents, Bundle options);
//Launch multiple new activities.

void startActivity(@Source(FlowPermission.INTENT) Intent intent);
//Same as startActivity(Intent, Bundle); with no options specified.

//void startActivity(Intent intent, Bundle options);
//Launch a new activity.

//boolean startInstrumentation(ComponentName className, String profileFile, Bundle arguments);
//Start executing an Instrumentation class.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options);
//Like startActivity(Intent, Bundle);, but taking a IntentSender to start.

//void startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags);
//Same as startIntentSender(IntentSender, Intent, int, int, int, Bundle); with no options specified.

ComponentName startService(@Source(FlowPermission.INTENT) Intent service);
//Request that a given application service be started.

//boolean stopService(Intent name);
//Request that a given application service be stopped.

//void unbindService(ServiceConnection conn);
//Disconnect from an application service.

//void unregisterReceiver(BroadcastReceiver receiver);
//Unregister a previously registered BroadcastReceiver.

//Protected Methods
//void attachBaseContext(Context base);
//Set the base context for this ContextWrapper.

}


class CursorLoader {
    
//CSH: found in spreadsheet, not in API:
//registerContentObserver


void deliverResult(Cursor cursor);
//Sends the result of the load to the registered listener.

//void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.

//String[] getProjection();

//String getSelection();

//String[] getSelectionArgs();

//String getSortOrder();

//Uri getUri();

Cursor loadInBackground();

void onCanceled(Cursor cursor);
//Called if the task was canceled before it was completed.

//void setProjection(String[] projection);

//void setSelection(String selection);

//void setSelectionArgs(String[] selectionArgs);

//void setSortOrder(String sortOrder);

//void setUri(Uri uri);

//Protected Methods
//void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

//void onStartLoading();
//Starts an asynchronous load of the contacts list data.

void onStopLoading();
//Must be called from the UI thread
}

class DialogInterface {
    
abstract void cancel();

abstract void dismiss();




}

class DialogInterface$OnClickListener{
        void onClick(DialogInterface arg0, int arg1);
}
class DialogInterface$OnKeyListener{
        boolean onKey(DialogInterface arg0, int arg1, KeyEvent arg2);
}

class DialogInterface$OnCancelListener{
            void onCancel(DialogInterface arg0);
}
class DialogInterface$OnMultiChoiceClickListener{
            void onClick(DialogInterface arg0, int arg1, boolean arg2);
}
class DialogInterface$OnDismissListener{
            void onDismiss(DialogInterface arg0);
}


class IntentFilter {

IntentFilter(String action);
//New IntentFilter that matches a single action with no data.

final Iterator<String> actionsIterator();
//Return an iterator over the filter's actions.

final void addAction(String action);
//Add a new Intent action to match against.

final void addCategory(String category);
//Add a new Intent category to match against.

final void addDataAuthority(String host, String port);
//Add a new Intent data authority to match against.

final void addDataPath(String path, int type);
//Add a new Intent data path to match against.

final void addDataScheme(String scheme);
//Add a new Intent data scheme to match against.

final void addDataType(String type);
//Add a new Intent data type to match against.

final Iterator<IntentFilter.AuthorityEntry> authoritiesIterator();
//Return an iterator over the filter's data authorities.

final Iterator<String> categoriesIterator();
//Return an iterator over the filter's categories.

final int countActions();
//Return the number of actions in the filter.

final int countCategories();
//Return the number of categories in the filter.

final int countDataAuthorities();
//Return the number of data authorities in the filter.

final int countDataPaths();
//Return the number of data paths in the filter.

final int countDataSchemes();
//Return the number of data schemes in the filter.

final int countDataTypes();
//Return the number of data types in the filter.

static IntentFilter create(String action, String dataType);
//Create a new IntentFilter instance with a specified action and MIME type, where you know the MIME type is correctly formatted.

final int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(Printer du, String prefix);

final String getAction(int index);
//Return an action in the filter.

final String getCategory(int index);
//Return a category in the filter.

final IntentFilter.AuthorityEntry getDataAuthority(int index);
//Return a data authority in the filter.

final PatternMatcher getDataPath(int index);
//Return a data path in the filter.

final String getDataScheme(int index);
//Return a data scheme in the filter.

final String getDataType(int index);
//Return a data type in the filter.

final int getPriority();
//Return the priority of this filter.

final boolean hasAction(String action);
//Is the given action included in the filter? Note that if the filter does not include any actions, false will always be returned.

final boolean hasCategory(String category);
//Is the given category included in the filter?

final boolean hasDataAuthority(Uri data);
//Is the given data authority included in the filter? Note that if the filter does not include any authorities, false will always be returned.

final boolean hasDataPath(String data);
//Is the given data path included in the filter? Note that if the filter does not include any paths, false will always be returned.

final boolean hasDataScheme(String scheme);
//Is the given data scheme included in the filter? Note that if the filter does not include any scheme, false will always be returned.

final boolean hasDataType(String type);
//Is the given data type included in the filter? Note that if the filter does not include any type, false will always be returned.

final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag);
//Test whether this filter matches the given intent.

final int match(String action, String type, String scheme, Uri data, Set<String> categories, String logTag);
//Test whether this filter matches the given intent data.

final boolean matchAction(String action);
//Match this filter against an Intent's action.

final String matchCategories(Set<String> categories);
//Match this filter against an Intent's categories.

final int matchData(String type, String scheme, Uri data);
//Match this filter against an Intent's data (type, scheme and path);.

final int matchDataAuthority(Uri data);
//Match this intent filter against the given Intent data.

final Iterator<PatternMatcher> pathsIterator();
//Return an iterator over the filter's data paths.

void readFromXml(XmlPullParser parser);

final Iterator<String> schemesIterator();
//Return an iterator over the filter's data schemes.

final void setPriority(int priority);
//Modify priority of this filter.

final Iterator<String> typesIterator();
//Return an iterator over the filter's data types.

final void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.

void writeToXml(XmlSerializer serializer);
//Write the contents of the IntentFilter as an XML stream.

    
}


class Intent implements Parcelable, Cloneable {
//SOM, We have a special FlowPermission for INTENTS
  
    Intent();
    Intent(@Sink(INTENT) Intent arg0);
    Intent(@Sink(INTENT)  String arg0);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT)  Uri arg1);
    Intent(@Source(ANY) @Sink Context arg0, Class<?> arg1);
    Intent(@Sink(INTENT) String arg0, @Sink(INTENT) Uri arg1, @Sink(INTENT)  Context arg2,@Sink(INTENT)  Class<?> arg3);
   @Source(INTENT) static Intent createChooser(@Sink(INTENT) Intent arg0, @Sink(INTENT) CharSequence arg1);
    Object clone();
   @Source(INTENT)  Intent cloneFilter();
    static Intent makeMainActivity(@Sink(INTENT) ComponentName arg0);
    static Intent makeMainSelectorActivity(@Sink(INTENT) String arg0,@Sink(INTENT)  String arg1);
    static Intent makeRestartActivityTask(@Sink(INTENT) ComponentName arg0);
    static Intent getIntent(@Sink(INTENT) String arg0) throws URISyntaxException;
    static Intent parseUri(@Sink(INTENT) String arg0, int arg1) throws URISyntaxException;
    static Intent getIntentOld(@Sink(INTENT) String arg0) throws URISyntaxException;
    @Source(INTENT) String getAction();
     @Source(INTENT) Uri getData();
     @Source(INTENT) String getDataString();
    @Source(INTENT) String getScheme();
    @Source(INTENT) String getType();
    @Source(INTENT) String resolveType(@Sink(INTENT) Context arg0);
    @Source(INTENT) String resolveType(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) String resolveTypeIfNeeded(@Sink(INTENT) ContentResolver arg0);
    @Source(INTENT) boolean hasCategory(@Sink(INTENT) String arg0);
    @Source(INTENT) Set<@Source(INTENT) String> getCategories();
    Intent getSelector();
    void setExtrasClassLoader(@Sink(INTENT) ClassLoader arg0);
    @Source(INTENT) boolean hasExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)  boolean hasFileDescriptors();
    @Source(INTENT) boolean getBooleanExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    @Source(INTENT) byte getByteExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    @Source(INTENT) short getShortExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    @Source(INTENT) char getCharExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
   @Source(INTENT)  int getIntExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    @Source(INTENT) long getLongExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    @Source(INTENT) float getFloatExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    @Source(INTENT) double getDoubleExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    @Source(INTENT) String getStringExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) CharSequence getCharSequenceExtra(@Sink(INTENT) String arg0);
    <T> T getParcelableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) Parcelable[] getParcelableArrayExtra(@Sink(INTENT) String arg0);
    <T> ArrayList<T> getParcelableArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) Serializable getSerializableExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) Integer> getIntegerArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) ArrayList< @Source(INTENT) String> getStringArrayListExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) ArrayList< @Source(INTENT) CharSequence> getCharSequenceArrayListExtra(@Sink(INTENT) String arg0);
    @Source(INTENT) boolean @Source(INTENT) [] getBooleanArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) byte @Source(INTENT) [] getByteArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) short @Source(INTENT) [] getShortArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  char @Source(INTENT) [] getCharArrayExtra(@Sink(INTENT) String arg0);
     @Source(INTENT) int @Source(INTENT) [] getIntArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  long @Source(INTENT) [] getLongArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  float @Source(INTENT) [] getFloatArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  double @Source(INTENT) [] getDoubleArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  String @Source(INTENT) [] getStringArrayExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   CharSequence @Source(INTENT) [] getCharSequenceArrayExtra(@Sink(INTENT) String arg0);
    @Source(INTENT)  Bundle getBundleExtra(@Sink(INTENT) String arg0);
   @Source(INTENT)   Bundle getExtras();
    @Source(INTENT)  int getFlags();
    @Source(INTENT)  String getPackage();
    @Source(INTENT)  ComponentName getComponent();
    @Source(INTENT)  Rect getSourceBounds();
    @Source(INTENT)  ComponentName resolveActivity(@Sink(INTENT) PackageManager arg0);
    @Source(INTENT)  ActivityInfo resolveActivityInfo(@Sink(INTENT) PackageManager arg0, int arg1);
    Intent setAction(String arg0);
    Intent setData(Uri arg0);
    Intent setType(String arg0);
    Intent setDataAndType(Uri arg0, String arg1);
    Intent addCategory(String arg0);
    void removeCategory( String arg0);
    void setSelector(@Sink(INTENT) Intent arg0);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) char arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  CharSequence arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Parcelable[] arg1);
    Intent putParcelableArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<? extends Parcelable> arg1);
    Intent putIntegerArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) Integer> arg1);
    Intent putStringArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) String> arg1);
    Intent putCharSequenceArrayListExtra(@Sink(INTENT) String arg0, @Sink(INTENT) ArrayList<@Sink(INTENT) CharSequence> arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Serializable arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) boolean @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) byte @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) short @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0,@Sink(INTENT)  char @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) int @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) long @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) float @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) double @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) String @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) CharSequence @Sink(INTENT) [] arg1);
    Intent putExtra(@Sink(INTENT) String arg0, @Sink(INTENT) Bundle arg1);
    Intent putExtras(@Sink(INTENT) Intent arg0);
    Intent putExtras( @Sink(INTENT) Bundle arg0);
    Intent replaceExtras( @Sink(INTENT) Intent arg0);
    Intent replaceExtras( @Sink(INTENT) Bundle arg0);
    void removeExtra( @Sink(INTENT) String arg0);
    Intent setFlags( @Sink(INTENT) int arg0);
    Intent addFlags( @Sink(INTENT) int arg0);
    Intent setPackage( @Sink(INTENT) String arg0);
    Intent setComponent( @Sink(INTENT) ComponentName arg0);
    Intent setClassName( @Sink(INTENT) Context arg0,  @Sink(INTENT) String arg1);
    Intent setClassName( @Sink(INTENT) String arg0,  @Sink(INTENT) String arg1);
    Intent setClass( @Sink(INTENT) Context arg0,  @Sink(INTENT) Class<?> arg1);
    void setSourceBounds( @Sink(INTENT) Rect arg0);
    @Source(INTENT)  int fillIn( @Sink(INTENT) Intent arg0,  @Sink(INTENT) int arg1);
    @Source(INTENT)  boolean filterEquals( @Sink(INTENT) Intent arg0);
     @Source(INTENT) int filterHashCode();
    @Source(INTENT)  String toString();
     @Source(INTENT) String toURI();
    @Source(INTENT)  String toUri( @Sink(INTENT) int arg0);
    @Source(INTENT)  int describeContents();
    void writeToParcel( @Sink(INTENT) Parcel arg0,  @Sink(INTENT) int arg1);
    void readFromParcel( @Sink(INTENT) Parcel arg0);
    static Intent parseIntent( @Sink(INTENT) Resources arg0, @Sink(INTENT)  XmlPullParser arg1,  @Sink(INTENT) AttributeSet arg2) throws XmlPullParserException,IOException;
}

class Loader {
    
void abandon();
//Tell the Loader that it is being abandoned.

String dataToString(D data);
//For debugging, converts an instance of the Loader's data class to a string that can be printed.

void deliverResult(D data);
//Sends the result of the load to the registered listener.

void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Loader's state into the given stream.
//CSH: filedescriptor

void forceLoad();
//Force an asynchronous load.

Context getContext();

//int getId();

boolean isAbandoned();
//Return whether this loader has been abandoned.

boolean isReset();
//Return whether this load has been reset.

boolean isStarted();
//Return whether this load has been started.

void onContentChanged();
//Called when Loader.ForceLoadContentObserver detects a change.

void registerListener(int id, OnLoadCompleteListener<D> listener);
//Registers a class that will receive callbacks when a load is complete.

void reset();
//Resets the state of the Loader.

final void startLoading();
//Starts an asynchronous load of the Loader's data.

void stopLoading();
//Stops delivery of updates until the next time startLoading(); is called.

boolean takeContentChanged();
//Take the current flag indicating whether the loader's content had changed while it was stopped.

//String toString();
//Returns a string containing a concise, human-readable description of this object.

void unregisterListener(OnLoadCompleteListener<D> listener);
//Remove a listener that was previously added with registerListener(int, Loader.OnLoadCompleteListener);.


//Protected Methods
void onAbandon();
//Subclasses implement this to take care of being abandoned.

void onForceLoad();
//Subclasses must implement this to take care of requests to forceLoad();.

void onReset();
//Subclasses must implement this to take care of resetting their loader, as per reset();.

void onStartLoading();
//Subclasses must implement this to take care of loading their data, as per startLoading();.

void onStopLoading();
//Subclasses must implement this to take care of stopping their loader, as per stopLoading();.



}

class ServiceConnection {
    void onServiceDisconnected(ComponentName arg0);
    //Called when a connection to the Service has been lost.

    void onServiceConnected(ComponentName arg0, IBinder arg1);
    //Called when a connection to the Service has been established, with the IBinder of the communication channel to the Service.
}

class UriMatcher {
    void addURI(@PolySource @PolySink String authority, @PolySource @PolySink String path, @PolySource @PolySink int code) @PolySource @PolySink;
    @PolyFlow int match(Uri uri);
    @Source(FlowPermission.INTENT) UriMatcher(@Source(FlowPermission.LITERAL) @Sink({}) int code);
}


class SharedPreferences {
    
abstract @Source(SHARED_PREFERENCES) boolean contains(@Sink(SHARED_PREFERENCES) String key);
//Checks whether the preferences contains a preference.

abstract @Source(SHARED_PREFERENCES) SharedPreferences.Editor edit();
//Create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.

abstract @Source(SHARED_PREFERENCES) Map<String, ?> getAll();
//Retrieve all values from the preferences.

abstract @Source(SHARED_PREFERENCES) boolean getBoolean(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) boolean defValue);
//Retrieve a boolean value from the preferences.

abstract @Source(SHARED_PREFERENCES) float getFloat(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) float defValue);
//Retrieve a float value from the preferences.

abstract @Source(SHARED_PREFERENCES) int getInt(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) int defValue);
//Retrieve an int value from the preferences.

abstract @Source(SHARED_PREFERENCES) long getLong(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) long defValue);
//Retrieve a long value from the preferences.

abstract @Source(SHARED_PREFERENCES) String getString(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) String defValue);
//Retrieve a String value from the preferences.

abstract @Source(SHARED_PREFERENCES) Set<String> getStringSet(@Sink(SHARED_PREFERENCES) String key, @Sink(SHARED_PREFERENCES) Set<String> defValues);
//Retrieve a set of String values from the preferences.

abstract void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Registers a callback to be invoked when a change happens to a preference.

abstract void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener listener);
//Unregisters a previous callback.

}

class SharedPreferences$Editor {
//CSH: I think this is the right way to annotate this.  The put* methods don't actually send the data until commit() or apply() is called, so those are the methods that should be annotated.?

abstract void apply() @Sink(SHARED_PREFERENCES);
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor clear() @Sink(SHARED_PREFERENCES);
//Mark in the editor to remove all values from the preferences.

abstract boolean commit() @Sink(SHARED_PREFERENCES);
//Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.

abstract SharedPreferences.Editor putBoolean(String key, @Sink(SHARED_PREFERENCES) boolean value);
//Set a boolean value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putFloat(String key, @Sink(SHARED_PREFERENCES) float value);
//Set a float value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putInt(String key, @Sink(SHARED_PREFERENCES) int value);
//Set an int value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putLong(String key, long value);
//Set a long value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putString(String key, String value);
//Set a String value in the preferences editor, to be written back once commit(); or apply(); are called.

abstract SharedPreferences.Editor putStringSet(String key, Set<String> values);
//Set a set of String values in the preferences editor, to be written back once commit(); is called.

abstract SharedPreferences.Editor remove(String key);
//Mark in the editor that a preference value should be removed, which will be done in the actual preferences once commit(); is called.



}

package android.content.pm;
class PackageManager {
    
abstract void addPackageToPreferred(String packageName);
//This method was deprecated in API level 7. This function no longer does anything; it was an old approach to managing preferred activities, which has been superceeded (and conflicts with); the modern activity-based preferences.

abstract boolean addPermission(PermissionInfo info);
//Add a new dynamic permission to the system.

abstract boolean addPermissionAsync(PermissionInfo info);
//Like addPermission(PermissionInfo); but asynchronously persists the package manager state after returning from the call, allowing it to return quicker and batch a series of adds at the expense of no guarantee the added permission will be retained if the device is rebooted before it is written.

abstract void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity);
//This method was deprecated in API level 8. This is a protected API that should not have been available to third party applications. It is the platform's responsibility for assigning preferred activities and this can not be directly modified. Add a new preferred activity mapping to the system. This will be used to automatically select the given activity component when Context.startActivity(); finds multiple matching activities and also matches the given filter.

abstract String[] canonicalToCurrentPackageNames(String[] names);
//Map from a packages canonical name to the current name in use on the device.

abstract int checkPermission(String permName, String pkgName);
//Check whether a particular package has been granted a particular permission.

abstract int checkSignatures(int uid1, int uid2);
//Like checkSignatures(String, String);, but takes UIDs of the two packages to be checked.

abstract int checkSignatures(String pkg1, String pkg2);
//Compare the signatures of two packages to determine if the same signature appears in both of them.

abstract void clearPackagePreferredActivities(String packageName);
//Remove all preferred activity mappings, previously added with addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName);, from the system whose activities are implemented in the given package name.

abstract String[] currentToCanonicalPackageNames(String[] names);
//Map from the current package names in use on the device to whatever the current canonical name of that package is.

abstract void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay);
//Allows a package listening to the package verification broadcast to extend the default timeout for a response and declare what action to perform after the timeout occurs.

abstract Drawable getActivityIcon(Intent intent);
//Retrieve the icon associated with an Intent.

abstract Drawable getActivityIcon(ComponentName activityName);
//Retrieve the icon associated with an activity.

abstract ActivityInfo getActivityInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular activity class.

abstract Drawable getActivityLogo(Intent intent);
//Retrieve the logo associated with an Intent.

abstract Drawable getActivityLogo(ComponentName activityName);
//Retrieve the logo associated with an activity.

abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);
//Retrieve all of the known permission groups in the system.

abstract int getApplicationEnabledSetting(String packageName);
//Return the the enabled setting for an application.

abstract Drawable getApplicationIcon(String packageName);
//Retrieve the icon associated with an application.

abstract Drawable getApplicationIcon(ApplicationInfo info);
//Retrieve the icon associated with an application.

abstract ApplicationInfo getApplicationInfo(String packageName, int flags);
//Retrieve all of the information we know about a particular package/application.

abstract CharSequence getApplicationLabel(ApplicationInfo info);
//Return the label to use for this application.

abstract Drawable getApplicationLogo(String packageName);
//Retrieve the logo associated with an application.

abstract Drawable getApplicationLogo(ApplicationInfo info);
//Retrieve the logo associated with an application.

abstract int getComponentEnabledSetting(ComponentName componentName);
//Return the the enabled setting for a package component (activity, receiver, service, provider);.

abstract Drawable getDefaultActivityIcon();
//Return the generic icon for an activity that is used when no specific icon is defined.

abstract Drawable getDrawable(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve an image from a package.

abstract List<ApplicationInfo> getInstalledApplications(int flags);
//Return a List of all application packages that are installed on the device.

abstract List<PackageInfo> getInstalledPackages(int flags);
//Return a List of all packages that are installed on the device.

abstract String getInstallerPackageName(String packageName);
//Retrieve the package name of the application that installed a package.

abstract InstrumentationInfo getInstrumentationInfo(ComponentName className, int flags);
//Retrieve all of the information we know about a particular instrumentation class.

abstract Intent getLaunchIntentForPackage(String packageName);
//Return a "good" intent to launch a front-door activity in a package, for use for example to implement an "open" button when browsing through packages.

abstract String getNameForUid(int uid);
//Retrieve the official name associated with a user id.

PackageInfo getPackageArchiveInfo(String archiveFilePath, int flags);
//Retrieve overall information about an application package defined in a package archive file

abstract int[] getPackageGids(String packageName);
//Return an array of all of the secondary group-ids that have been assigned to a package.

abstract PackageInfo getPackageInfo(String packageName, int flags);
//Retrieve overall information about an application package that is installed on the system.

abstract String[] getPackagesForUid(int uid);
//Retrieve the names of all packages that are associated with a particular user id.

abstract PermissionGroupInfo getPermissionGroupInfo(String name, int flags);
//Retrieve all of the information we know about a particular group of permissions.

abstract PermissionInfo getPermissionInfo(String name, int flags);
//Retrieve all of the information we know about a particular permission.

abstract int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName);
//Retrieve all preferred activities, previously added with addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName);, that are currently registered with the system.

abstract List<PackageInfo> getPreferredPackages(int flags);
//Retrieve the list of all currently configured preferred packages.

abstract ProviderInfo getProviderInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular content provider class.

abstract ActivityInfo getReceiverInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular receiver class.

abstract Resources getResourcesForActivity(ComponentName activityName);
//Retrieve the resources associated with an activity.

abstract Resources getResourcesForApplication(String appPackageName);
//Retrieve the resources associated with an application.

abstract Resources getResourcesForApplication(ApplicationInfo app);
//Retrieve the resources for an application.

abstract ServiceInfo getServiceInfo(ComponentName component, int flags);
//Retrieve all of the information we know about a particular service class.

abstract FeatureInfo[] getSystemAvailableFeatures();
//Get a list of features that are available on the system.

abstract String[] getSystemSharedLibraryNames();
//Get a list of shared libraries that are available on the system.

abstract CharSequence getText(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve text from a package.

abstract XmlResourceParser getXml(String packageName, int resid, ApplicationInfo appInfo);
//Retrieve an XML file from a package.

abstract boolean hasSystemFeature(String name);
//Check whether the given feature name is one of the available features as returned by getSystemAvailableFeatures();.

abstract boolean isSafeMode();
//Return whether the device has been booted into safe mode.

abstract List<ResolveInfo> queryBroadcastReceivers(Intent intent, int flags);
//Retrieve all receivers that can handle a broadcast of the given intent.

abstract List<ProviderInfo> queryContentProviders(String processName, int uid, int flags);
//Retrieve content provider information.

abstract List<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags);
//Retrieve information about available instrumentation code.

abstract List<ResolveInfo> queryIntentActivities(Intent intent, int flags);
//Retrieve all activities that can be performed for the given intent.

abstract List<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, Intent intent, int flags);
//Retrieve a set of activities that should be presented to the user as similar options.

abstract List<ResolveInfo> queryIntentServices(Intent intent, int flags);
//Retrieve all services that can match the given intent.

abstract List<PermissionInfo> queryPermissionsByGroup(String group, int flags);
//Query for all of the permissions associated with a particular group.

abstract void removePackageFromPreferred(String packageName);
//This method was deprecated in API level 7. This function no longer does anything; it was an old approach to managing preferred activities, which has been superceeded (and conflicts with); the modern activity-based preferences.

abstract void removePermission(String name);
//Removes a permission that was previously added with addPermission(PermissionInfo);.

abstract ResolveInfo resolveActivity(Intent intent, int flags);
//Determine the best action to perform for a given Intent.

abstract ProviderInfo resolveContentProvider(String name, int flags);
//Find a single content provider by its base path name.

abstract ResolveInfo resolveService(Intent intent, int flags);
//Determine the best service to handle for a given Intent.

abstract void setApplicationEnabledSetting(String packageName, int newState, int flags);
//Set the enabled setting for an application This setting will override any enabled state which may have been set by the application in its manifest.

abstract void setComponentEnabledSetting(ComponentName componentName, int newState, int flags);
//Set the enabled setting for a package component (activity, receiver, service, provider);.

abstract void setInstallerPackageName(String targetPackage, String installerPackageName);
//Change the installer associated with a given package.

abstract void verifyPendingInstall(int id, int verificationCode);
//Allows a package listening to the package verification broadcast to respond to the package manager.



}

class ResolveInfo {

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

void dump(@PolyFlowReceiver Printer pw, String prefix);

final int getIconResource();
//Return the icon resource identifier to use for this match.

Drawable loadIcon(PackageManager pm);
//Retrieve the current graphical icon associated with this resolution.

CharSequence loadLabel(PackageManager pm);
//Retrieve the current textual label associated with this resolution.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int parcelableFlags);
//Flatten this object in to a Parcel.

}

package android.content.res;

class AssetManager {
//CSH: maybe Filesystem permission here...
    
void close();
//Close this asset manager.

final String[] getLocales();
//Get the locales that this asset manager contains data for.

final String[] list(String path);
//Return a String array of all the assets at the given path.

final InputStream open(String fileName);
//Open an asset using ACCESS_STREAMING mode.

final InputStream open(String fileName, int accessMode);
//Open an asset using an explicit access mode, returning an InputStream to read its contents.

final AssetFileDescriptor openFd(String fileName);

final AssetFileDescriptor openNonAssetFd(String fileName);

final AssetFileDescriptor openNonAssetFd(int cookie, String fileName);

final XmlResourceParser openXmlResourceParser(String fileName);
//Retrieve a parser for a compiled XML file.

final XmlResourceParser openXmlResourceParser(int cookie, String fileName);
//Retrieve a parser for a compiled XML file.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.




}

class ColorStateList {
    
    
static ColorStateList createFromXml(Resources r, XmlPullParser parser);
//Create a ColorStateList from an XML document, given a set of Resources.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

int getColorForState(int[] stateSet, int defaultColor);
//Return the color associated with the given set of View states.

int getDefaultColor();
//Return the default color in this ColorStateList.

boolean isStateful();

String toString();
//Returns a string containing a concise, human-readable description of this object.

static ColorStateList valueOf(int color);
//Creates or retrieves a ColorStateList that always returns a single color.

ColorStateList withAlpha(int alpha);
//Creates a new ColorStateList that has the same states and colors as this one but where each color has the specified alpha value (0-255);.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.




}

class Resources {
final void finishPreloading();
//Called by zygote when it is done preloading resources, to change back to normal Resources operation.

final void flushLayoutCache();
//Call this to remove all cached loaded layout resources from the Resources object.

XmlResourceParser getAnimation(int id);
//Return an XmlResourceParser through which you can read an animation description for the given resource ID.

final AssetManager getAssets();
//Retrieve underlying AssetManager storage for these resources.

@Source(LITERAL) boolean getBoolean(int id);
//Return a boolean associated with a particular resource ID.

@Source(LITERAL) int getColor(int id);
//Return a color integer associated with a particular resource ID.

ColorStateList getColorStateList(int id);
//Return a color state list associated with a particular resource ID.

Configuration getConfiguration();
//Return the current configuration that is in effect for this resource object.

@Source(LITERAL) float getDimension(int id);
//Retrieve a dimensional for a particular resource ID.

@Source(LITERAL) int getDimensionPixelOffset(int id);
//Retrieve a dimensional for a particular resource ID for use as an offset in raw pixels.

@Source(LITERAL) int getDimensionPixelSize(int id);
//Retrieve a dimensional for a particular resource ID for use as a size in raw pixels.

DisplayMetrics getDisplayMetrics();
//Return the current display metrics that are in effect for this resource object.

@Source(LITERAL) Drawable getDrawable(int id);
//Return a drawable object associated with a particular resource ID.

@Source(LITERAL) Drawable getDrawableForDensity(int id, int density);
//Return a drawable object associated with a particular resource ID for the given screen density in DPI.

@Source(LITERAL) float getFraction(int id, int base, int pbase);
//Retrieve a fractional unit for a particular resource ID.

@Source(LITERAL) int getIdentifier(String name, String defType, String defPackage);
//Return a resource identifier for the given resource name.

@Source(LITERAL) int[] getIntArray(int id);
//Return the int array associated with a particular resource ID.

@Source(LITERAL) int getInteger(int id);
//Return an integer associated with a particular resource ID.

XmlResourceParser getLayout(int id);
//Return an XmlResourceParser through which you can read a view layout description for the given resource ID.

@Source(LITERAL) Movie getMovie(int id);
//Return a movie object associated with the particular resource ID.

@Source(LITERAL) String getQuantityString(int id, int quantity);
//Return the string value associated with a particular resource ID for a particular numerical quantity.

@Source(LITERAL) String getQuantityString(int id, int quantity, Object... formatArgs);
//Return the string value associated with a particular resource ID for a particular numerical quantity, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

@Source(LITERAL) CharSequence getQuantityText(int id, int quantity);
//Return the character sequence associated with a particular resource ID for a particular numerical quantity.

@Source(LITERAL) String getResourceEntryName(int resid);
//Return the entry name for a given resource identifier.

@Source(LITERAL) String getResourceName(int resid);
//Return the full name for a given resource identifier.

@Source(LITERAL) String getResourcePackageName(int resid);
//Return the package name for a given resource identifier.

@Source(LITERAL) String getResourceTypeName(int resid);
//Return the type name for a given resource identifier.

@Source(LITERAL) String getString(int id);
//Return the string value associated with a particular resource ID. It will be stripped of any styled text information.

@Source(LITERAL) String getString(int id, Object... formatArgs);
//Return the string value associated with a particular resource ID, substituting the format arguments as defined in Formatter and format(String, Object...);. It will be stripped of any styled text information.

@Source(LITERAL) String[] getStringArray(int id);
//Return the string array associated with a particular resource ID.

static Resources getSystem();
//Return a global shared Resources object that provides access to only system resources (no application resources);, and is not configured for the current screen (can not use dimension units, does not change based on orientation, etc);.

@Source(LITERAL) CharSequence getText(int id, CharSequence def);
//Return the string value associated with a particular resource ID.

@Source(LITERAL) CharSequence getText(int id);
//Return the string value associated with a particular resource ID. The returned object will be a String if this is a plain string; it will be some other type of CharSequence if it is styled.

@Source(LITERAL) CharSequence[] getTextArray(int id);
//Return the styled text array associated with a particular resource ID.

void getValue(String name, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValue(int id, TypedValue outValue, boolean resolveRefs);
//Return the raw data associated with a particular resource ID.

void getValueForDensity(int id, int density, TypedValue outValue, boolean resolveRefs);
//Get the raw value associated with a resource with associated density.

XmlResourceParser getXml(int id);
//Return an XmlResourceParser through which you can read a generic XML resource for the given resource ID.

final Resources.Theme newTheme();
//Generate a new Theme object for this set of Resources.

TypedArray obtainAttributes(AttributeSet set, int[] attrs);
//Retrieve a set of basic attribute values from an AttributeSet, not performing styling of them using a theme and/or style resources.

TypedArray obtainTypedArray(int id);
//Return an array of heterogeneous values.

InputStream openRawResource(int id, TypedValue value);
//Open a data stream for reading a raw resource.

InputStream openRawResource(int id);
//Open a data stream for reading a raw resource.

@Source({FILESYSTEM, READ_EXTERNAL_STORAGE})AssetFileDescriptor openRawResourceFd(int id);
//Open a file descriptor for reading a raw resource.

void parseBundleExtra(String tagName, AttributeSet attrs, Bundle outBundle);
//Parse a name/value pair out of an XML tag holding that data.

void parseBundleExtras(XmlResourceParser parser, Bundle outBundle);
//Parse a series of <extra> tags from an XML file.

void updateConfiguration(Configuration config, DisplayMetrics metrics);
//Store the newly updated configuration.
}

class TypedArray {
    
boolean getBoolean(int index, boolean defValue);
//Retrieve the boolean value for the attribute at index.

int getColor(int index, int defValue);
//Retrieve the color value for the attribute at index.

ColorStateList getColorStateList(int index);
//Retrieve the ColorStateList for the attribute at index.

float getDimension(int index, float defValue);
//Retrieve a dimensional unit attribute at index.

int getDimensionPixelOffset(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as an offset in raw pixels.

int getDimensionPixelSize(int index, int defValue);
//Retrieve a dimensional unit attribute at index for use as a size in raw pixels.

Drawable getDrawable(int index);
//Retrieve the Drawable for the attribute at index.

float getFloat(int index, float defValue);
//Retrieve the float value for the attribute at index.

float getFraction(int index, int base, int pbase, float defValue);
//Retrieve a fractional unit attribute at index.

int getIndex(int at);
//Return an index in the array that has data.

int getIndexCount();
//Return the number of indices in the array that actually have data.

int getInt(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getInteger(int index, int defValue);
//Retrieve the integer value for the attribute at index.

int getLayoutDimension(int index, String name);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

int getLayoutDimension(int index, int defValue);
//Special version of getDimensionPixelSize(int, int); for retrieving ViewGroup's layout_width and layout_height attributes.

String getNonResourceString(int index);
//Retrieve the string value for the attribute at index, but only if that string comes from an immediate value in an XML file.

String getPositionDescription();
//Returns a message about the parser state suitable for printing error messages.

int getResourceId(int index, int defValue);
//Retrieve the resource identifier for the attribute at index.

Resources getResources();
//Return the Resources object this array was loaded from.

String getString(int index);
//Retrieve the string value for the attribute at index.

CharSequence getText(int index);
//Retrieve the styled string value for the attribute at index.

CharSequence[] getTextArray(int index);
//Retrieve the CharSequence[] for the attribute at index.

boolean getValue(int index, TypedValue outValue);
//Retrieve the raw TypedValue for the attribute at index.

boolean hasValue(int index);
//Determines whether there is an attribute at index.

int length();
//Return the number of values in this array.

TypedValue peekValue(int index);
//Retrieve the raw TypedValue for the attribute at index and return a temporary object holding its data.

void recycle();
//Give back a previously retrieved array, for later re-use.

String toString();
//Returns a string containing a concise, human-readable description of this object.



}


package android.content.pm;
class PackageManager{
            CharSequence getApplicationLabel(ApplicationInfo arg0);
            ActivityInfo getActivityInfo(ComponentName arg0, int arg1) throws NameNotFoundException;
            Drawable getApplicationIcon(String arg0) throws NameNotFoundException;
            ApplicationInfo getApplicationInfo(String arg0, int arg1) throws NameNotFoundException;
            Drawable getActivityIcon(ComponentName arg0) throws NameNotFoundException;
            PackageInfo getPackageInfo(String arg0, int arg1) throws NameNotFoundException;
            List<ResolveInfo> queryIntentActivities(Intent arg0, int arg1);
            boolean hasSystemFeature(String arg0);
            ResolveInfo resolveActivity(Intent arg0, int arg1);
}
class Signature{
            String toCharsString();
}



package android.database;

class ContentObserver {
    
boolean deliverSelfNotifications();
//Returns true if this observer is interested receiving self-change notifications.

final void dispatchChange(boolean selfChange, Uri uri);
//Dispatches a change notification to the observer.

final void dispatchChange(boolean selfChange);
//This method was deprecated in API level 16. Use dispatchChange(boolean, Uri); instead.

void onChange(boolean selfChange, Uri uri);
//This method is called when a content change occurs.

void onChange(boolean selfChange);
//This method is called when a content change occurs.

    
    
}


class Cursor {
abstract void close();
//Closes the Cursor, releasing all of its resources and making it completely invalid.

abstract void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer);
//Retrieves the requested column text and stores it in the buffer provided.

abstract void deactivate();
//This method was deprecated in API level 16. Since requery(); is deprecated, so too is this.

abstract byte[] getBlob(int columnIndex);
//Returns the value of the requested column as a byte array.

abstract @Source(DATABASE) int getColumnCount();
//Return total number of columns

abstract @Source(DATABASE) int getColumnIndex(@Sink(DATABASE) String columnName);
//Returns the zero-based index for the given column name, or -1 if the column doesn't exist.

abstract @Source(DATABASE) int getColumnIndexOrThrow(@Sink(DATABASE) String columnName);
//Returns the zero-based index for the given column name, or throws IllegalArgumentException if the column doesn't exist.

abstract @Source(DATABASE) String getColumnName(@Sink(DATABASE) int columnIndex);
//Returns the column name at the given zero-based column index.

abstract @Source(DATABASE) String[] getColumnNames();
//Returns a string array holding the names of all of the columns in the result set in the order in which they were listed in the result.

abstract @Source(DATABASE) int getCount();
//Returns the numbers of rows in the cursor.

abstract @Source(DATABASE) double getDouble(int columnIndex);
//Returns the value of the requested column as a double.

abstract Bundle getExtras();
//Returns a bundle of extra values.

abstract @Source(DATABASE) float getFloat(@Sink(DATABASE) int columnIndex);
//Returns the value of the requested column as a float.

abstract @Source(DATABASE) int getInt(@Sink(DATABASE) int columnIndex);
//Returns the value of the requested column as an int.

abstract @Source(DATABASE) long getLong(@Sink(DATABASE) int columnIndex);
//Returns the value of the requested column as a long.

abstract @Source(DATABASE) int getPosition();
//Returns the current position of the cursor in the row set.

abstract @Source(DATABASE) short getShort(@Sink(DATABASE) int columnIndex);
//Returns the value of the requested column as a short.

abstract @Source(DATABASE) String getString(@Sink(DATABASE) int columnIndex);
//Returns the value of the requested column as a String.

abstract @Source(DATABASE) int getType(@Sink(DATABASE) int columnIndex);
//Returns data type of the given column's value.

abstract boolean getWantsAllOnMoveCalls();
//onMove(); will only be called across processes if this method returns true.

abstract boolean isAfterLast();
//Returns whether the cursor is pointing to the position after the last row.

abstract boolean isBeforeFirst();
//Returns whether the cursor is pointing to the position before the first row.

abstract boolean isClosed();
//return true if the cursor is closed

abstract boolean isFirst();
//Returns whether the cursor is pointing to the first row.

abstract boolean isLast();
//Returns whether the cursor is pointing to the last row.

abstract @Source(DATABASE) boolean isNull(@Sink(DATABASE) int columnIndex);
//Returns true if the value in the indicated column is null.

abstract boolean move(int offset);
//Move the cursor by a relative amount, forward or backward, from the current position.

abstract boolean moveToFirst();
//Move the cursor to the first row.

abstract boolean moveToLast();
//Move the cursor to the last row.

abstract boolean moveToNext();
//Move the cursor to the next row.

abstract boolean moveToPosition(int position);
//Move the cursor to an absolute position.

abstract boolean moveToPrevious();
//Move the cursor to the previous row.

abstract void registerContentObserver(ContentObserver observer);
//Register an observer that is called when changes happen to the content backing this cursor.

abstract void registerDataSetObserver(DataSetObserver observer);
//Register an observer that is called when changes happen to the contents of the this cursors data set, for example, when the data set is changed via requery();, deactivate();, or close();.

abstract boolean requery();
//This method was deprecated in API level 11. Don't use this. Just request a new cursor, so you can do this asynchronously and update your list view once the new cursor comes back.

abstract Bundle respond(Bundle extras);
//This is an out-of-band way for the the user of a cursor to communicate with the cursor.

abstract void setNotificationUri(ContentResolver cr, Uri uri);
//Register to watch a content URI for changes.

abstract void unregisterContentObserver(ContentObserver observer);
//Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver);.

abstract void unregisterDataSetObserver(DataSetObserver observer);
//Unregister an observer that has previously been registered with this cursor via registerContentObserver(ContentObserver);.

}

class DataSetObserver{
            void onInvalidated();
            void onChanged();
            DataSetObserver();
}
class DataSetObservable {
    
void notifyChanged();
//Invokes onChanged(); on each observer.

void notifyInvalidated();
//Invokes onInvalidated(); on each observer.


}

class MatrixCursor {
    
void addRow(Iterable<?> columnValues);
//Adds a new row to the end with the given column values.

void addRow(Object[] columnValues);
//Adds a new row to the end with the given column values.

byte[] getBlob(int column);
//Returns the value of the requested column as a byte array.

String[] getColumnNames();
//Returns a string array holding the names of all of the columns in the result set in the order in which they were listed in the result.

int getCount();
//Returns the numbers of rows in the cursor.

double getDouble(int column);
//Returns the value of the requested column as a double.

float getFloat(int column);
//Returns the value of the requested column as a float.

int getInt(int column);
//Returns the value of the requested column as an int.

long getLong(int column);
//Returns the value of the requested column as a long.

short getShort(int column);
//Returns the value of the requested column as a short.

String getString(int column);
//Returns the value of the requested column as a String.

int getType(int column);
//Returns data type of the given column's value.

boolean isNull(int column);
//Returns true if the value in the indicated column is null.

MatrixCursor.RowBuilder newRow();
//Adds a new row to the end and returns a builder for that row.



}

class Observable{
            void unregisterObserver(T observer);
            void registerObserver(T observer);
}

package android.database.sqlite;

class SQLiteClosable {
//void acquireReference();
//Acquires a reference to the object.

void close();
//Releases a reference to the object, closing the object if the last reference was released.

//void releaseReference();
//Releases a reference to the object, closing the object if the last reference was released.

//void releaseReferenceFromContainer();
//This method was deprecated in API level 16. Do not use.


//PROTECTED
//abstract void onAllReferencesReleased();
//Called when the last reference to the object was released by a call to releaseReference(); or close();.

//void onAllReferencesReleasedFromContainer();
//This method was deprecated in API level 16. Do not use.

}

class SQLiteDatabase {
  
void beginTransaction();
//Begins a transaction in EXCLUSIVE mode.

void beginTransactionNonExclusive();
//Begins a transaction in IMMEDIATE mode.

void beginTransactionWithListener(SQLiteTransactionListener transactionListener);
//Begins a transaction in EXCLUSIVE mode.

void beginTransactionWithListenerNonExclusive(SQLiteTransactionListener transactionListener);
//Begins a transaction in IMMEDIATE mode.

SQLiteStatement compileStatement(String sql);
//Compiles an SQL statement into a reusable pre-compiled statement object.

static SQLiteDatabase create(SQLiteDatabase.CursorFactory factory);
//Create a memory backed SQLite database.

int delete(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String whereClause, @Sink(SQLITE_DATABASE) String[] whereArgs);
//Convenience method for deleting rows in the database.

static @Source(SQLITE_DATABASE) boolean deleteDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) File file);
//Deletes a database including its journal file and other auxiliary files that may have been created by the database engine.

void disableWriteAheadLogging();
//This method disables the features enabled by enableWriteAheadLogging();.

boolean enableWriteAheadLogging();
//This method enables parallel execution of queries from multiple threads on the same database.

void endTransaction();
//End a transaction.

void execSQL(@Sink(SQLITE_DATABASE) String sql);
//Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data.

void execSQL(@Sink(SQLITE_DATABASE) String sql, @Sink(SQLITE_DATABASE) Object[] bindArgs);
//Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.

static String findEditTable(@Sink(SQLITE_DATABASE) String tables);
//Finds the name of the first table, which is editable.

List<Pair<String, String>> getAttachedDbs();
//Returns list of full pathnames of all attached databases including the main database by executing 'pragma database_list' on the database.

@Source(SQLITE_DATABASE) long getMaximumSize();
//Returns the maximum size the database may grow to.

@Source(SQLITE_DATABASE) long getPageSize();
//Returns the current database page size, in bytes.

@Source({SQLITE_DATABASE, FILESYSTEM, READ_EXTERNAL_STORAGE}) final String getPath();
//Gets the path to the database file.

Map<String, String> getSyncedTables();
//This method was deprecated in API level 11. This method no longer serves any useful purpose and has been deprecated.

@Source(SQLITE_DATABASE) int getVersion();
//Gets the database version.

boolean inTransaction();
//Returns true if the current thread has a transaction pending.

long insert(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String nullColumnHack, @Sink(SQLITE_DATABASE) ContentValues values);
//Convenience method for inserting a row into the database.

long insertOrThrow(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String nullColumnHack, @Sink(SQLITE_DATABASE) ContentValues values);
//Convenience method for inserting a row into the database.

long insertWithOnConflict(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String nullColumnHack, @Sink(SQLITE_DATABASE) ContentValues initialValues, @Sink(SQLITE_DATABASE) int conflictAlgorithm);
//General method for inserting a row into the database.

@Source(SQLITE_DATABASE) boolean isDatabaseIntegrityOk();
//Runs 'pragma integrity_check' on the given database (and all the attached databases); and returns true if the given database (and all its attached databases); pass integrity_check, false otherwise.

@Source(SQLITE_DATABASE) boolean isDbLockedByCurrentThread();
//Returns true if the current thread is holding an active connection to the database.

@Source(SQLITE_DATABASE) boolean isDbLockedByOtherThreads();
//This method was deprecated in API level 16. Always returns false. Do not use this method.

@Source(SQLITE_DATABASE) boolean isOpen();
//Returns true if the database is currently open.

@Source(SQLITE_DATABASE) boolean isReadOnly();
//Returns true if the database is opened as read only.

@Source(SQLITE_DATABASE) boolean isWriteAheadLoggingEnabled();
//Returns true if write-ahead logging has been enabled for this database.

void markTableSyncable(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String foreignKey, @Sink(SQLITE_DATABASE) String updateTable);
//This method was deprecated in API level 11. This method no longer serves any useful purpose and has been deprecated.

void markTableSyncable(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String deletedTable);
//This method was deprecated in API level 11. This method no longer serves any useful purpose and has been deprecated.

@Source(SQLITE_DATABASE) boolean needUpgrade(@Sink(SQLITE_DATABASE) int newVersion);
//Returns true if the new version code is greater than the current database version.

static @Source(SQLITE_DATABASE) SQLiteDatabase openDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String path, SQLiteDatabase.CursorFactory factory, @Sink(SQLITE_DATABASE) int flags, DatabaseErrorHandler errorHandler);
//Open the database according to the flags OPEN_READWRITE OPEN_READONLY CREATE_IF_NECESSARY and/or NO_LOCALIZED_COLLATORS.

static @Source(SQLITE_DATABASE) SQLiteDatabase openDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String path, SQLiteDatabase.CursorFactory factory, @Sink(SQLITE_DATABASE) int flags);
//Open the database according to the flags OPEN_READWRITE OPEN_READONLY CREATE_IF_NECESSARY and/or NO_LOCALIZED_COLLATORS.

static @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String path, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler);
//Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler);.

static @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String path, SQLiteDatabase.CursorFactory factory);
//Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY);.

static @Source(SQLITE_DATABASE) SQLiteDatabase openOrCreateDatabase(@Sink({SQLITE_DATABASE, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) File file, SQLiteDatabase.CursorFactory factory);
//Equivalent to openDatabase(file.getPath();, factory, CREATE_IF_NECESSARY);.

@Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy, @Sink(SQLITE_DATABASE) String limit);
//Query the given table, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE)boolean distinct, @Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy, @Sink(SQLITE_DATABASE) String limit, CancellationSignal cancellationSignal);
//Query the given URL, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy);
//Query the given table, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE)boolean distinct, @Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE)String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy, @Sink(SQLITE_DATABASE) String limit);
//Query the given URL, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor queryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, @Sink(SQLITE_DATABASE)boolean distinct, @Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy, @Sink(SQLITE_DATABASE) String limit, CancellationSignal cancellationSignal);
//Query the given URL, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor queryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, @Sink(SQLITE_DATABASE)boolean distinct, @Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String[] columns, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String orderBy, @Sink(SQLITE_DATABASE) String limit);
//Query the given URL, returning a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor rawQuery(@Sink(SQLITE_DATABASE) String sql, @Sink(SQLITE_DATABASE) String[] selectionArgs, CancellationSignal cancellationSignal);
//Runs the provided SQL and returns a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor rawQuery(@Sink(SQLITE_DATABASE) String sql, @Sink(SQLITE_DATABASE) String[] selectionArgs);
//Runs the provided SQL and returns a Cursor over the result set.

@Source(SQLITE_DATABASE) Cursor rawQueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, @Sink(SQLITE_DATABASE) String sql, @Sink(SQLITE_DATABASE) String[] selectionArgs, String editTable);
//Runs the provided SQL and returns a cursor over the result set.

@Source(SQLITE_DATABASE) Cursor rawQueryWithFactory(SQLiteDatabase.CursorFactory cursorFactory, @Sink(SQLITE_DATABASE) String sql, @Sink(SQLITE_DATABASE) String[] selectionArgs, String editTable, CancellationSignal cancellationSignal);
//Runs the provided SQL and returns a cursor over the result set.

static int releaseMemory();
//Attempts to release memory that SQLite holds but does not require to operate properly.

@Source(SQLITE_DATABASE) long replace(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String nullColumnHack, @Sink(SQLITE_DATABASE) ContentValues initialValues);
//Convenience method for replacing a row in the database.

@Source(SQLITE_DATABASE) long replaceOrThrow(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) String nullColumnHack, @Sink(SQLITE_DATABASE) ContentValues initialValues);
//Convenience method for replacing a row in the database.

@Source(SQLITE_DATABASE) void setForeignKeyConstraintsEnabled(@Sink(SQLITE_DATABASE) boolean enable);
//Sets whether foreign key constraints are enabled for the database.

@Source(SQLITE_DATABASE) void setLocale(@Sink(SQLITE_DATABASE) Locale locale);
//Sets the locale for this database.

@Source(SQLITE_DATABASE) void setLockingEnabled(@Sink(SQLITE_DATABASE) boolean lockingEnabled);
//This method was deprecated in API level 16. This method now does nothing. Do not use.

@Source(SQLITE_DATABASE) void setMaxSqlCacheSize(@Sink(SQLITE_DATABASE) int cacheSize);
//Sets the maximum size of the prepared-statement cache for this database.

@Source(SQLITE_DATABASE) long setMaximumSize(@Sink(SQLITE_DATABASE) long numBytes);
//Sets the maximum size the database will grow to.

@Source(SQLITE_DATABASE) void setPageSize(@Sink(SQLITE_DATABASE) long numBytes);
//Sets the database page size.

@Source(SQLITE_DATABASE) void setTransactionSuccessful();
//Marks the current transaction as successful.

@Source(SQLITE_DATABASE) void setVersion(@Sink(SQLITE_DATABASE) int version);
//Sets the database version.

@Source(SQLITE_DATABASE) String toString();
//Returns a string containing a concise, human-readable description of this object.

@Source(SQLITE_DATABASE) int update(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) ContentValues values, @Sink(SQLITE_DATABASE) String whereClause, @Sink(SQLITE_DATABASE) String[] whereArgs);
//Convenience method for updating rows in the database.

@Source(SQLITE_DATABASE) int updateWithOnConflict(@Sink(SQLITE_DATABASE) String table, @Sink(SQLITE_DATABASE) ContentValues values, @Sink(SQLITE_DATABASE) String whereClause, @Sink(SQLITE_DATABASE) String[] whereArgs, @Sink(SQLITE_DATABASE) int conflictAlgorithm);
//Convenience method for updating rows in the database.

@Source(SQLITE_DATABASE) boolean yieldIfContended();
//This method was deprecated in API level 3. if the db is locked more than once (becuase of nested transactions); then the lock will not be yielded. Use yieldIfContendedSafely instead.

@Source(SQLITE_DATABASE) boolean yieldIfContendedSafely(long sleepAfterYieldDelay);
//Temporarily end the transaction to let other threads run.

@Source(SQLITE_DATABASE) boolean yieldIfContendedSafely();
//Temporarily end the transaction to let other threads run.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

void onAllReferencesReleased();
//Called when the last reference to the object was released by a call to releaseReference(); or close();.

}

class SQLiteException {
    
    
}

class SQLiteOpenHelper {
    
synchronized void close();
//Close any open database object.

@Source(SQLITE_DATABASE) String getDatabaseName();
//Return the name of the SQLite database being opened, as given to the constructor.

@Source(SQLITE_DATABASE) SQLiteDatabase getReadableDatabase();
//Create and/or open a database.

@Source(SQLITE_DATABASE) SQLiteDatabase getWritableDatabase();
//Create and/or open a database that will be used for reading and writing.

void onConfigure(SQLiteDatabase db);
//Called when the database connection is being configured, to enable features such as write-ahead logging or foreign key support.

abstract void onCreate(SQLiteDatabase db);
//Called when the database is created for the first time.

void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion);
//Called when the database needs to be downgraded.

void onOpen(SQLiteDatabase db);
//Called when the database has been opened.

abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);
//Called when the database needs to be upgraded.

void setWriteAheadLoggingEnabled(boolean enabled);
//Enables or disables the use of write-ahead logging for the database.


}

class SQLiteQueryBuilder {

 @Source(SQLITE_DATABASE) Cursor query(@Sink(SQLITE_DATABASE) SQLiteDatabase db, @Sink(SQLITE_DATABASE) String[] projectionIn, @Sink(SQLITE_DATABASE) String selection, @Sink(SQLITE_DATABASE) String[] selectionArgs, @Sink(SQLITE_DATABASE) String groupBy, @Sink(SQLITE_DATABASE) String having, @Sink(SQLITE_DATABASE) String sortOrder);
            void setProjectionMap(Map<String,String> columnMap);
            
//Added by Philip
    void appendWhere(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) CharSequence inWhere) @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) Cursor query(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) SQLiteDatabase db, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] projectionIn, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String selection, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) [] selectionArgs, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String groupBy, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String having, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String sortOrder, @Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String limit) @Source(FlowPermission.ANY) @Sink({});
    void setTables(@Source(FlowPermission.ANY) @Sink(FlowPermission.SQLITE_DATABASE) String inTables) @Source(FlowPermission.ANY) @Sink({});
    @Source(FlowPermission.SQLITE_DATABASE) SQLiteQueryBuilder();
}

class SQLiteStatement {

void execute();
//CSH: need a receiver annotation?
//Execute this SQL statement, if it is not a SELECT / INSERT / DELETE / UPDATE, for example CREATE / DROP table, view, trigger, index etc.

@Source(SQLITE_DATABASE) long executeInsert();
//Execute this SQL statement and return the ID of the row inserted due to this call.

@Source(SQLITE_DATABASE) int executeUpdateDelete();
//Execute this SQL statement, if the the number of rows affected by execution of this SQL statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.

@Source(SQLITE_DATABASE) ParcelFileDescriptor simpleQueryForBlobFileDescriptor();
//Executes a statement that returns a 1 by 1 table with a blob value.

@Source(SQLITE_DATABASE) long simpleQueryForLong();
//Execute a statement that returns a 1 by 1 table with a numeric value.

@Source(SQLITE_DATABASE) String simpleQueryForString();
//Execute a statement that returns a 1 by 1 table with a text value.

String toString();
//Returns a string containing a concise, human-readable description of this object.



    
}
package android.graphics;




class Bitmap {

boolean compress(Bitmap.CompressFormat format, int quality, @PolySource @PolySink OutputStream stream) @PolySource @PolySink;
//Write a compressed version of the bitmap to the specified outputstream.

Bitmap copy(Bitmap.Config config, boolean isMutable);
//Tries to make a new bitmap based on the dimensions of this bitmap, setting the new bitmap's config to the one specified, and then copying this bitmap's pixels into the new bitmap.

void copyPixelsFromBuffer(Buffer src);
//Copy the pixels from the buffer, beginning at the current position, overwriting the bitmap's pixels.

void copyPixelsToBuffer(Buffer dst);
//Copy the bitmap's pixels into the specified buffer (allocated by the caller);.

static Bitmap createBitmap(DisplayMetrics display, int width, int height, Bitmap.Config config);
//Returns a mutable bitmap with the specified width and height.

static Bitmap createBitmap(DisplayMetrics display, int[] colors, int width, int height, Bitmap.Config config);
//Returns a immutable bitmap with the specified width and height, with each pixel value set to the corresponding value in the colors array.

static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter);
//Returns an immutable bitmap from subset of the source bitmap, transformed by the optional matrix.

static Bitmap createBitmap(int width, int height, Bitmap.Config config);
//Returns a mutable bitmap with the specified width and height.

static Bitmap createBitmap(DisplayMetrics display, int[] colors, int offset, int stride, int width, int height, Bitmap.Config config);
//Returns a immutable bitmap with the specified width and height, with each pixel value set to the corresponding value in the colors array.

static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height);
//Returns an immutable bitmap from the specified subset of the source bitmap.

static Bitmap createBitmap(int[] colors, int offset, int stride, int width, int height, Bitmap.Config config);
//Returns a immutable bitmap with the specified width and height, with each pixel value set to the corresponding value in the colors array.

static Bitmap createBitmap(Bitmap src);
//Returns an immutable bitmap from the source bitmap.

static Bitmap createBitmap(int[] colors, int width, int height, Bitmap.Config config);
//Returns a immutable bitmap with the specified width and height, with each pixel value set to the corresponding value in the colors array.

static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter);
//Creates a new bitmap, scaled from an existing bitmap, when possible.

int describeContents();
//No special parcel contents.

void eraseColor(int c);
//Fills the bitmap's pixels with the specified Color.

Bitmap extractAlpha();
//Returns a new bitmap that captures the alpha values of the original.

Bitmap extractAlpha(Paint paint, int[] offsetXY);
//Returns a new bitmap that captures the alpha values of the original.

final int getByteCount();
//Returns the number of bytes used to store this bitmap's pixels.

final Bitmap.Config getConfig();
//If the bitmap's internal config is in one of the public formats, return that config, otherwise return null.

int getDensity();
//Returns the density for this bitmap.

int getGenerationId();
//Returns the generation ID of this bitmap.

final int getHeight();
//Returns the bitmap's height

byte[] getNinePatchChunk();
//Returns an optional array of private data, used by the UI system for some bitmaps.

int getPixel(int x, int y);
//Returns the Color at the specified location.

void getPixels(int[] pixels, int offset, int stride, int x, int y, int width, int height);
//Returns in pixels[] a copy of the data in the bitmap.

final int getRowBytes();
//Return the number of bytes between rows in the bitmap's pixels.

int getScaledHeight(int targetDensity);
//Convenience method that returns the height of this bitmap divided by the density scale factor.

int getScaledHeight(DisplayMetrics metrics);
//Convenience for calling getScaledHeight(int); with the target density of the given DisplayMetrics.

int getScaledHeight(Canvas canvas);
//Convenience for calling getScaledHeight(int); with the target density of the given Canvas.

int getScaledWidth(int targetDensity);
//Convenience method that returns the width of this bitmap divided by the density scale factor.

int getScaledWidth(DisplayMetrics metrics);
//Convenience for calling getScaledWidth(int); with the target density of the given DisplayMetrics.

int getScaledWidth(Canvas canvas);
//Convenience for calling getScaledWidth(int); with the target density of the given Canvas.

final int getWidth();
//Returns the bitmap's width

final boolean hasAlpha();
//Returns true if the bitmap's config supports per-pixel alpha, and if the pixels may contain non-opaque alpha values.

final boolean hasMipMap();
//Indicates whether the renderer responsible for drawing this bitmap should attempt to use mipmaps when this bitmap is drawn scaled down.

final boolean isMutable();
//Returns true if the bitmap is marked as mutable (i.e.

final boolean isPremultiplied();
//Indicates whether pixels stored in this bitmaps are stored pre-multiplied.

final boolean isRecycled();
//Returns true if this bitmap has been recycled.

void prepareToDraw();
//Rebuilds any caches associated with the bitmap that are used for drawing it.

void recycle();
//Free the native object associated with this bitmap, and clear the reference to the pixel data.

boolean sameAs(Bitmap other);
//Given another bitmap, return true if it has the same dimensions, config, and pixel data as this bitmap.

void setDensity(int density);
//Specifies the density for this bitmap.

void setHasAlpha(boolean hasAlpha);
//Tell the bitmap if all of the pixels are known to be opaque (false); or if some of the pixels may contain non-opaque alpha values (true);.

final void setHasMipMap(boolean hasMipMap);
//Set a hint for the renderer responsible for drawing this bitmap indicating that it should attempt to use mipmaps when this bitmap is drawn scaled down.

void setPixel(int x, int y, int color);
//Write the specified Color into the bitmap (assuming it is mutable); at the x,y coordinate.

void setPixels(int[] pixels, int offset, int stride, int x, int y, int width, int height);
//Replace pixels in the bitmap with the colors in the array.

void writeToParcel(Parcel p, int flags);
//Write the bitmap and its pixels to the parcel.

}

class BitmapFactory {
static @PolySource @PolySink Bitmap decodeByteArray(@PolySource @PolySink byte @PolySource @PolySink [] data, int offset, int length, BitmapFactory.Options opts);
//Decode an immutable bitmap from the specified byte array.

static @PolySource @PolySink  Bitmap decodeByteArray(@PolySource @PolySink  byte @PolySource @PolySink [] data, int offset, int length);
//Decode an immutable bitmap from the specified byte array.

static @Source({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) Bitmap decodeFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String pathName);
//Decode a file path into a bitmap.

static @Source({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) Bitmap decodeFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String pathName, BitmapFactory.Options opts);
//Decode a file path into a bitmap.

static @Source({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) Bitmap decodeFileDescriptor(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd);
//Decode a bitmap from the file descriptor.

static @Source({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) Bitmap decodeFileDescriptor(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, Rect outPadding, BitmapFactory.Options opts);
//Decode a bitmap from the file descriptor.

static Bitmap decodeResource(Resources res, int id, BitmapFactory.Options opts);
//Synonym for opening the given resource and calling decodeResourceStream(Resources, TypedValue, InputStream, Rect, BitmapFactory.Options);.

static Bitmap decodeResource(Resources res, int id);
//Synonym for decodeResource(Resources, int, android.graphics.BitmapFactory.Options); will null Options.

static Bitmap decodeResourceStream(Resources res, TypedValue value, InputStream is, Rect pad, BitmapFactory.Options opts);
//Decode a new Bitmap from an InputStream.

static Bitmap decodeStream(InputStream is);
//Decode an input stream into a bitmap.

static Bitmap decodeStream(InputStream is, Rect outPadding, BitmapFactory.Options opts);
//Decode an input stream into a bitmap.

}

class BitmapFactory$Options {
    
void requestCancelDecode();
//This can be called from another thread while this options object is inside a decode...



}

class Canvas {
//CSH: This class draws a lot of objets on the screen, lines, and squares, and circles and whatnot.
// In general if the square/circle/object was specified I put a Sink of DISPLAY on it, but if the method had only only points or coordinates
// I didn't annotate them because the value of the point isn't output, per se, but it does represent a location on the screen.

boolean clipPath(Path path);
//Intersect the current clip with the specified path.

boolean clipPath(Path path, Region.Op op);
//Modify the current clip with the specified path.

boolean clipRect(Rect rect, Region.Op op);
//Modify the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRect(RectF rect, Region.Op op);
//Modify the current clip with the specified rectangle.

boolean clipRect(int left, int top, int right, int bottom);
//Intersect the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRect(float left, float top, float right, float bottom);
//Intersect the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRect(RectF rect);
//Intersect the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRect(float left, float top, float right, float bottom, Region.Op op);
//Modify the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRect(Rect rect);
//Intersect the current clip with the specified rectangle, which is expressed in local coordinates.

boolean clipRegion(Region region);
//Intersect the current clip with the specified region.

boolean clipRegion(Region region, Region.Op op);
//Modify the current clip with the specified region.

void concat(Matrix matrix);
//Preconcat the current matrix with the specified matrix.

void drawARGB(int a, int r, int g, int b);
//Fill the entire canvas' bitmap (restricted to the current clip); with the specified ARGB color, using srcover porterduff mode.

void drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint);
//Draw the specified arc, which will be scaled to fit inside the specified oval.

void drawBitmap(@Sink(DISPLAY) int[] colors, int offset, int stride, float x, float y, int width, int height, boolean hasAlpha, Paint paint);
//Treat the specified array of colors as a bitmap, and draw it.

void drawBitmap(@Sink(DISPLAY) Bitmap bitmap, Matrix matrix, Paint paint);
//Draw the bitmap using the specified matrix.

void drawBitmap(@Sink(DISPLAY) int[] colors, int offset, int stride, int x, int y, int width, int height, boolean hasAlpha, Paint paint);
//Legacy version of drawBitmap(int[] colors, ...); that took ints for x,y

void drawBitmap(@Sink(DISPLAY) Bitmap bitmap, Rect src, RectF dst, Paint paint);
//Draw the specified bitmap, scaling/translating automatically to fill the destination rectangle.

void drawBitmap(@Sink(DISPLAY) Bitmap bitmap, float left, float top, Paint paint);
//Draw the specified bitmap, with its top/left corner at (x,y);, using the specified paint, transformed by the current matrix.

void drawBitmap(@Sink(DISPLAY) Bitmap bitmap, Rect src, Rect dst, Paint paint);
//Draw the specified bitmap, scaling/translating automatically to fill the destination rectangle.

void drawBitmapMesh(@Sink(DISPLAY) Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint);
//Draw the bitmap through the mesh, where mesh vertices are evenly distributed across the bitmap.

void drawCircle(float cx, float cy, float radius, Paint paint);
//Draw the specified circle using the specified paint.

void drawColor(int color);
//Fill the entire canvas' bitmap (restricted to the current clip); with the specified color, using srcover porterduff mode.

void drawColor(int color, PorterDuff.Mode mode);
//Fill the entire canvas' bitmap (restricted to the current clip); with the specified color and porter-duff xfermode.

void drawLine(float startX, float startY, float stopX, float stopY, Paint paint);
//Draw a line segment with the specified start and stop x,y coordinates, using the specified paint.

void drawLines(float[] pts, Paint paint);

void drawLines(float[] pts, int offset, int count, Paint paint);
//Draw a series of lines.

void drawOval(RectF oval, Paint paint);
//Draw the specified oval using the specified paint.

void drawPaint(Paint paint);
//Fill the entire canvas' bitmap (restricted to the current clip); with the specified paint.

void drawPath(@Sink(DISPLAY) Path path, Paint paint);
//Draw the specified path using the specified paint.

void drawPicture(@Sink(DISPLAY) Picture picture, RectF dst);
//Draw the picture, stretched to fit into the dst rectangle.

void drawPicture(@Sink(DISPLAY) Picture picture);
//Save the canvas state, draw the picture, and restore the canvas state.

void drawPicture(@Sink(DISPLAY) Picture picture, Rect dst);
//Draw the picture, stretched to fit into the dst rectangle.

void drawPoint(float x, float y, Paint paint);
//Helper for drawPoints(); for drawing a single point.

void drawPoints(float[] pts, int offset, int count, Paint paint);
//Draw a series of points.

void drawPoints(float[] pts, Paint paint);
//Helper for drawPoints(); that assumes you want to draw the entire array

void drawPosText(@Sink(DISPLAY) char[] text, int index, int count, float[] pos, Paint paint);
//Draw the text in the array, with each character's origin specified by the pos array.

void drawPosText(@Sink(DISPLAY) String text, float[] pos, Paint paint);
//Draw the text in the array, with each character's origin specified by the pos array.

void drawRGB(int r, int g, int b);
//Fill the entire canvas' bitmap (restricted to the current clip); with the specified RGB color, using srcover porterduff mode.

void drawRect(float left, float top, float right, float bottom, Paint paint);
//Draw the specified Rect using the specified paint.

void drawRect(@Sink(DISPLAY) RectF rect, Paint paint);
//Draw the specified Rect using the specified paint.

void drawRect(@Sink(DISPLAY) Rect r, Paint paint);
//Draw the specified Rect using the specified Paint.

void drawRoundRect(@Sink(DISPLAY) RectF rect, float rx, float ry, Paint paint);
//Draw the specified round-rect using the specified paint.

void drawText(@Sink(DISPLAY) String text, float x, float y, Paint paint);
//Draw the text, with origin at (x,y);, using the specified paint.

void drawText(@Sink(DISPLAY) CharSequence text, int start, int end, float x, float y, Paint paint);
//Draw the specified range of text, specified by start/end, with its origin at (x,y);, in the specified Paint.

void drawText(@Sink(DISPLAY) char[] text, int index, int count, float x, float y, Paint paint);
//Draw the text, with origin at (x,y);, using the specified paint.

void drawText(@Sink(DISPLAY) String text, int start, int end, float x, float y, Paint paint);
//Draw the text, with origin at (x,y);, using the specified paint.

void drawTextOnPath(@Sink(DISPLAY) String text, Path path, float hOffset, float vOffset, Paint paint);
//Draw the text, with origin at (x,y);, using the specified paint, along the specified path.

void drawTextOnPath(@Sink(DISPLAY) char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint);
//Draw the text, with origin at (x,y);, using the specified paint, along the specified path.

void drawVertices(Canvas.VertexMode mode, int vertexCount, float[] verts, int vertOffset, float[] texs, int texOffset, int[] colors, int colorOffset, short[] indices, int indexOffset, int indexCount, Paint paint);
//Draw the array of vertices, interpreted as triangles (based on mode);.

final Rect getClipBounds();
//Retrieve the clip bounds.

boolean getClipBounds(Rect bounds);
//Retrieve the clip bounds, returning true if they are non-empty.

int getDensity();
//Returns the target density of the canvas.

DrawFilter getDrawFilter();

int getHeight();
//Returns the height of the current drawing layer

void getMatrix(Matrix ctm);
//Return, in ctm, the current transformation matrix.

final Matrix getMatrix();
//Return a new matrix with a copy of the canvas' current transformation matrix.

int getMaximumBitmapHeight();
//Returns the maximum allowed height for bitmaps drawn with this canvas.

int getMaximumBitmapWidth();
//Returns the maximum allowed width for bitmaps drawn with this canvas.

int getSaveCount();
//Returns the number of matrix/clip states on the Canvas' private stack.

int getWidth();
//Returns the width of the current drawing layer

boolean isHardwareAccelerated();
//Indicates whether this Canvas uses hardware acceleration.

boolean isOpaque();
//Return true if the device that the current layer draws into is opaque (i.e.

boolean quickReject(Path path, Canvas.EdgeType type);
//Return true if the specified path, after being transformed by the current matrix, would lie completely outside of the current clip.

boolean quickReject(float left, float top, float right, float bottom, Canvas.EdgeType type);
//Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip.

boolean quickReject(RectF rect, Canvas.EdgeType type);
//Return true if the specified rectangle, after being transformed by the current matrix, would lie completely outside of the current clip.

void restore();
//This call balances a previous call to save();, and is used to remove all modifications to the matrix/clip state since the last save call.

void restoreToCount(int saveCount);
//Efficient way to pop any calls to save(); that happened after the save count reached saveCount.

void rotate(float degrees);
//Preconcat the current matrix with the specified rotation.

final void rotate(float degrees, float px, float py);
//Preconcat the current matrix with the specified rotation.

int save();
//Saves the current matrix and clip onto a private stack.

int save(int saveFlags);
//Based on saveFlags, can save the current matrix and clip onto a private stack.

int saveLayer(RectF bounds, Paint paint, int saveFlags);
//This behaves the same as save();, but in addition it allocates an offscreen bitmap.

int saveLayer(float left, float top, float right, float bottom, Paint paint, int saveFlags);
//Helper version of saveLayer(); that takes 4 values rather than a RectF.

int saveLayerAlpha(RectF bounds, int alpha, int saveFlags);
//This behaves the same as save();, but in addition it allocates an offscreen bitmap.

int saveLayerAlpha(float left, float top, float right, float bottom, int alpha, int saveFlags);
//Helper for saveLayerAlpha(); that takes 4 values instead of a RectF.

void scale(float sx, float sy);
//Preconcat the current matrix with the specified scale.

final void scale(float sx, float sy, float px, float py);
//Preconcat the current matrix with the specified scale.

void setBitmap(@Sink(DISPLAY) Bitmap bitmap);
//Specify a bitmap for the canvas to draw into.

void setDensity(int density);
//Specifies the density for this Canvas' backing bitmap.

void setDrawFilter(DrawFilter filter);

void setMatrix(Matrix matrix);
//Completely replace the current matrix with the specified matrix.

void skew(float sx, float sy);
//Preconcat the current matrix with the specified skew.

void translate(float dx, float dy);
//Preconcat the current matrix with the specified translation

}

class Matrix {
    
    
boolean equals(Object obj);
//Returns true iff obj is a Matrix and its values equal our values.

void getValues(float[] values);
//Copy 9 values from the matrix into the array.

boolean invert(Matrix inverse);
//If this matrix can be inverted, return true and if inverse is not null, set inverse to be the inverse of this matrix.

boolean isIdentity();
//Returns true if the matrix is identity.

void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex, int pointCount);
//Apply this matrix to the array of 2D points specified by src, and write the transformed points into the array of points specified by dst.

void mapPoints(float[] pts);
//Apply this matrix to the array of 2D points, and write the transformed points back into the array

void mapPoints(float[] dst, float[] src);
//Apply this matrix to the array of 2D points specified by src, and write the transformed points into the array of points specified by dst.

float mapRadius(float radius);
//Return the mean radius of a circle after it has been mapped by this matrix.

boolean mapRect(RectF dst, RectF src);
//Apply this matrix to the src rectangle, and write the transformed rectangle into dst.

boolean mapRect(RectF rect);
//Apply this matrix to the rectangle, and write the transformed rectangle back into it.

void mapVectors(float[] dst, float[] src);
//Apply this matrix to the array of 2D vectors specified by src, and write the transformed vectors into the array of vectors specified by dst.

void mapVectors(float[] vecs);
//Apply this matrix to the array of 2D vectors, and write the transformed vectors back into the array.

void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount);
//Apply this matrix to the array of 2D vectors specified by src, and write the transformed vectors into the array of vectors specified by dst.

boolean postConcat(Matrix other);
//Postconcats the matrix with the specified matrix.

boolean postRotate(float degrees);
//Postconcats the matrix with the specified rotation.

boolean postRotate(float degrees, float px, float py);
//Postconcats the matrix with the specified rotation.

boolean postScale(float sx, float sy);
//Postconcats the matrix with the specified scale.

boolean postScale(float sx, float sy, float px, float py);
//Postconcats the matrix with the specified scale.

boolean postSkew(float kx, float ky);
//Postconcats the matrix with the specified skew.

boolean postSkew(float kx, float ky, float px, float py);
//Postconcats the matrix with the specified skew.

boolean postTranslate(float dx, float dy);
//Postconcats the matrix with the specified translation.

boolean preConcat(Matrix other);
//Preconcats the matrix with the specified matrix.

boolean preRotate(float degrees);
//Preconcats the matrix with the specified rotation.

boolean preRotate(float degrees, float px, float py);
//Preconcats the matrix with the specified rotation.

boolean preScale(float sx, float sy);
//Preconcats the matrix with the specified scale.

boolean preScale(float sx, float sy, float px, float py);
//Preconcats the matrix with the specified scale.

boolean preSkew(float kx, float ky);
//Preconcats the matrix with the specified skew.

boolean preSkew(float kx, float ky, float px, float py);
//Preconcats the matrix with the specified skew.

boolean preTranslate(float dx, float dy);
//Preconcats the matrix with the specified translation.

boolean rectStaysRect();
//Returns true if will map a rectangle to another rectangle.

void reset();
//Set the matrix to identity
void set(Matrix src);
//(deep); copy the src matrix into this matrix.

boolean setConcat(Matrix a, Matrix b);
//Set the matrix to the concatenation of the two specified matrices, returning true if the the result can be represented.

boolean setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount);
//Set the matrix such that the specified src points would map to the specified dst points.

boolean setRectToRect(RectF src, RectF dst, Matrix.ScaleToFit stf);
//Set the matrix to the scale and translate values that map the source rectangle to the destination rectangle, returning true if the the result can be represented.

void setRotate(float degrees);
//Set the matrix to rotate about (0,0); by the specified number of degrees.

void setRotate(float degrees, float px, float py);
//Set the matrix to rotate by the specified number of degrees, with a pivot point at (px, py);.

void setScale(float sx, float sy, float px, float py);
//Set the matrix to scale by sx and sy, with a pivot point at (px, py);.

void setScale(float sx, float sy);
//Set the matrix to scale by sx and sy.

void setSinCos(float sinValue, float cosValue);
//Set the matrix to rotate by the specified sine and cosine values.

void setSinCos(float sinValue, float cosValue, float px, float py);
//Set the matrix to rotate by the specified sine and cosine values, with a pivot point at (px, py);.

void setSkew(float kx, float ky, float px, float py);
//Set the matrix to skew by sx and sy, with a pivot point at (px, py);.

void setSkew(float kx, float ky);
//Set the matrix to skew by sx and sy.

void setTranslate(float dx, float dy);
//Set the matrix to translate by (dx, dy);.

void setValues(float[] values);
//Copy 9 values from the array into the matrix.

String toShortString();

String toString();
//Returns a string containing a concise, human-readable description of this object.




}

class Movie{
        void draw(Canvas canvas, float x, float y);
        static Movie decodeStream(@Source(FlowPermission.FILESYSTEM) InputStream arg0);
        int duration();
        boolean setTime(int arg0);
}

class Paint {
float ascent();
//Return the distance above (negative); the baseline (ascent); based on the current typeface and text size.

int breakText(CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth);
//Measure the text, stopping early if the measured width exceeds maxWidth.

int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth);
//Measure the text, stopping early if the measured width exceeds maxWidth.

int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth);
//Measure the text, stopping early if the measured width exceeds maxWidth.

void clearShadowLayer();
//Clear the shadow layer.

float descent();
//Return the distance below (positive); the baseline (descent); based on the current typeface and text size.

int getAlpha();
//Helper to getColor(); that just returns the color's alpha value.

int getColor();
//Return the paint's color.

ColorFilter getColorFilter();
//Get the paint's colorfilter (maybe be null);.

boolean getFillPath(Path src, Path dst);
//Applies any/all effects (patheffect, stroking); to src, returning the result in dst.

int getFlags();
//Return the paint's flags.

float getFontMetrics(Paint.FontMetrics metrics);
//Return the font's recommended interline spacing, given the Paint's settings for typeface, textSize, etc.

Paint.FontMetrics getFontMetrics();
//Allocates a new FontMetrics object, and then calls getFontMetrics(fm); with it, returning the object.

Paint.FontMetricsInt getFontMetricsInt();

int getFontMetricsInt(Paint.FontMetricsInt fmi);
//Return the font's interline spacing, given the Paint's settings for typeface, textSize, etc.

float getFontSpacing();
//Return the recommend line spacing based on the current typeface and text size.

int getHinting();
//Return the paint's hinting mode.

MaskFilter getMaskFilter();
//Get the paint's maskfilter object.

PathEffect getPathEffect();
//Get the paint's patheffect object.

Rasterizer getRasterizer();
//Get the paint's rasterizer (or null);.

Shader getShader();
//Get the paint's shader object.

Paint.Cap getStrokeCap();
//Return the paint's Cap, controlling how the start and end of stroked lines and paths are treated.

Paint.Join getStrokeJoin();
//Return the paint's stroke join type.

float getStrokeMiter();
//Return the paint's stroke miter value.

float getStrokeWidth();
//Return the width for stroking.

Paint.Style getStyle();
//Return the paint's style, used for controlling how primitives' geometries are interpreted (except for drawBitmap, which always assumes FILL_STYLE);.

Paint.Align getTextAlign();
//Return the paint's Align value for drawing text.

void getTextBounds(char[] text, int index, int count, Rect bounds);
//Return in bounds (allocated by the caller); the smallest rectangle that encloses all of the characters, with an implied origin at (0,0);.

void getTextBounds(String text, int start, int end, Rect bounds);
//Return in bounds (allocated by the caller); the smallest rectangle that encloses all of the characters, with an implied origin at (0,0);.

Locale getTextLocale();
//Get the text Locale.

void getTextPath(String text, int start, int end, float x, float y, Path path);
//Return the path (outline); for the specified text.

void getTextPath(char[] text, int index, int count, float x, float y, Path path);
//Return the path (outline); for the specified text.

float getTextScaleX();
//Return the paint's horizontal scale factor for text.

float getTextSize();
//Return the paint's text size.

float getTextSkewX();
//Return the paint's horizontal skew factor for text.

int getTextWidths(String text, float[] widths);
//Return the advance widths for the characters in the string.

int getTextWidths(CharSequence text, int start, int end, float[] widths);
//Return the advance widths for the characters in the string.

int getTextWidths(String text, int start, int end, float[] widths);
//Return the advance widths for the characters in the string.

int getTextWidths(char[] text, int index, int count, float[] widths);
//Return the advance widths for the characters in the string.

Typeface getTypeface();
//Get the paint's typeface object.

Xfermode getXfermode();
//Get the paint's xfermode object.

final boolean isAntiAlias();
//Helper for getFlags();, returning true if ANTI_ALIAS_FLAG bit is set AntiAliasing smooths out the edges of what is being drawn, but is has no impact on the interior of the shape.

final boolean isDither();
//Helper for getFlags();, returning true if DITHER_FLAG bit is set Dithering affects how colors that are higher precision than the device are down-sampled.

final boolean isFakeBoldText();
//Helper for getFlags();, returning true if FAKE_BOLD_TEXT_FLAG bit is set

final boolean isFilterBitmap();
//Whether or not the bitmap filter is activated.

final boolean isLinearText();
//Helper for getFlags();, returning true if LINEAR_TEXT_FLAG bit is set

final boolean isStrikeThruText();
//Helper for getFlags();, returning true if STRIKE_THRU_TEXT_FLAG bit is set

final boolean isSubpixelText();
//Helper for getFlags();, returning true if SUBPIXEL_TEXT_FLAG bit is set

final boolean isUnderlineText();
//Helper for getFlags();, returning true if UNDERLINE_TEXT_FLAG bit is set

float measureText(String text);
//Return the width of the text.

float measureText(CharSequence text, int start, int end);
//Return the width of the text.

float measureText(String text, int start, int end);
//Return the width of the text.

float measureText(char[] text, int index, int count);
//Return the width of the text.

void reset();
//Restores the paint to its default settings.

void set(Paint src);
//Copy the fields from src into this paint.

void setARGB(int a, int r, int g, int b);
//Helper to setColor();, that takes a,r,g,b and constructs the color int

void setAlpha(int a);
//Helper to setColor();, that only assigns the color's alpha value, leaving its r,g,b values unchanged.

void setAntiAlias(boolean aa);
//Helper for setFlags();, setting or clearing the ANTI_ALIAS_FLAG bit AntiAliasing smooths out the edges of what is being drawn, but is has no impact on the interior of the shape.

void setColor(int color);
//Set the paint's color.

ColorFilter setColorFilter(ColorFilter filter);
//Set or clear the paint's colorfilter, returning the parameter.

void setDither(boolean dither);
//Helper for setFlags();, setting or clearing the DITHER_FLAG bit Dithering affects how colors that are higher precision than the device are down-sampled.

void setFakeBoldText(boolean fakeBoldText);
//Helper for setFlags();, setting or clearing the FAKE_BOLD_TEXT_FLAG bit

void setFilterBitmap(boolean filter);
//Helper for setFlags();, setting or clearing the FILTER_BITMAP_FLAG bit.

void setFlags(int flags);
//Set the paint's flags.

void setHinting(int mode);
//Set the paint's hinting mode.

void setLinearText(boolean linearText);
//Helper for setFlags();, setting or clearing the LINEAR_TEXT_FLAG bit

MaskFilter setMaskFilter(MaskFilter maskfilter);
//Set or clear the maskfilter object.

PathEffect setPathEffect(PathEffect effect);
//Set or clear the patheffect object.

Rasterizer setRasterizer(Rasterizer rasterizer);
//Set or clear the rasterizer object.

Shader setShader(Shader shader);
//Set or clear the shader object.

void setShadowLayer(float radius, float dx, float dy, int color);
//This draws a shadow layer below the main layer, with the specified offset and color, and blur radius.

void setStrikeThruText(boolean strikeThruText);
//Helper for setFlags();, setting or clearing the STRIKE_THRU_TEXT_FLAG bit

void setStrokeCap(Paint.Cap cap);
//Set the paint's Cap.

void setStrokeJoin(Paint.Join join);
//Set the paint's Join.

void setStrokeMiter(float miter);
//Set the paint's stroke miter value.

void setStrokeWidth(float width);
//Set the width for stroking.

void setStyle(Paint.Style style);
//Set the paint's style, used for controlling how primitives' geometries are interpreted (except for drawBitmap, which always assumes Fill);.

void setSubpixelText(boolean subpixelText);
//Helper for setFlags();, setting or clearing the SUBPIXEL_TEXT_FLAG bit

void setTextAlign(Paint.Align align);
//Set the paint's text alignment.

void setTextLocale(Locale locale);
//Set the text locale.

void setTextScaleX(float scaleX);
//Set the paint's horizontal scale factor for text.

void setTextSize(float textSize);
//Set the paint's text size.

void setTextSkewX(float skewX);
//Set the paint's horizontal skew factor for text.

Typeface setTypeface(Typeface typeface);
//Set or clear the typeface object.

void setUnderlineText(boolean underlineText);
//Helper for setFlags();, setting or clearing the UNDERLINE_TEXT_FLAG bit

Xfermode setXfermode(Xfermode xfermode);
//Set or clear the xfermode object.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

}

class Point {
    
    
int describeContents();
//Parcelable interface methods

final boolean equals(int x, int y);
//Returns true if the point's coordinates equal (x,y);

boolean equals(Object o);
//Compares this instance with the specified object and indicates if they are equal.

int hashCode();
//Returns an integer hash code for this object.

final void negate();
//Negate the point's coordinates

final void offset(int dx, int dy);
//Offset the point's coordinates by dx, dy

void readFromParcel(Parcel in);
//Set the point's coordinates from the data stored in the specified parcel.

void set(int x, int y);
//Set the point's x and y coordinates

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel out, int flags);
//Write this point to the specified parcel.



}

class PointF {

int describeContents();
//Parcelable interface methods

boolean equals(Object o);
//Compares this instance with the specified object and indicates if they are equal.

final boolean equals(float x, float y);
//Returns true if the point's coordinates equal (x,y);

int hashCode();
//Returns an integer hash code for this object.

final float length();
//Return the euclidian distance from (0,0); to the point

static float length(float x, float y);
//Returns the euclidian distance from (0,0); to (x,y);

final void negate();

final void offset(float dx, float dy);

void readFromParcel(Parcel in);
//Set the point's coordinates from the data stored in the specified parcel.

final void set(float x, float y);
//Set the point's x and y coordinates

final void set(PointF p);
//Set the point's x and y coordinates to the coordinates of p

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel out, int flags);
//Write this point to the specified parcel.

}

class PorterDuffColorFilter{
        PorterDuffColorFilter(int srcColor, Mode mode);
}
class Rect {
    
final int centerX();

final int centerY();

boolean contains(int x, int y);
//Returns true if (x,y); is inside the rectangle.

boolean contains(int left, int top, int right, int bottom);
//Returns true iff the 4 specified sides of a rectangle are inside or equal to this rectangle.

boolean contains(Rect r);
//Returns true iff the specified rectangle r is inside or equal to this rectangle.

int describeContents();
//Parcelable interface methods

boolean equals(Object o);
//Compares this instance with the specified object and indicates if they are equal.

final float exactCenterX();

final float exactCenterY();

String flattenToString();
//Return a string representation of the rectangle in a well-defined format.

int hashCode();
//Returns an integer hash code for this object.

final int height();

void inset(int dx, int dy);
//Inset the rectangle by (dx,dy);.

boolean intersect(Rect r);
//If the specified rectangle intersects this rectangle, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

boolean intersect(int left, int top, int right, int bottom);
//If the rectangle specified by left,top,right,bottom intersects this rectangle, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

boolean intersects(int left, int top, int right, int bottom);
//Returns true if this rectangle intersects the specified rectangle.

static boolean intersects(Rect a, Rect b);
//Returns true iff the two specified rectangles intersect.

final boolean isEmpty();
//Returns true if the rectangle is empty (left >= right or top >= bottom);

void offset(int dx, int dy);
//Offset the rectangle by adding dx to its left and right coordinates, and adding dy to its top and bottom coordinates.

void offsetTo(int newLeft, int newTop);
//Offset the rectangle to a specific (left, top); position, keeping its width and height the same.

void readFromParcel(Parcel in);
//Set the rectangle's coordinates from the data stored in the specified parcel.

void set(int left, int top, int right, int bottom);
//Set the rectangle's coordinates to the specified values.

void set(Rect src);
//Copy the coordinates from src into this rectangle.

void setEmpty();
//Set the rectangle to (0,0,0,0);

boolean setIntersect(Rect a, Rect b);
//If rectangles a and b intersect, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

void sort();
//Swap top/bottom or left/right if there are flipped (i.e.

String toShortString();
//Return a string representation of the rectangle in a compact form.

String toString();
//Returns a string containing a concise, human-readable description of this object.

static Rect unflattenFromString(String str);
//Returns a Rect from a string of the form returned by flattenToString();, or null if the string is not of that form.

void union(int left, int top, int right, int bottom);
//Update this Rect to enclose itself and the specified rectangle.

void union(Rect r);
//Update this Rect to enclose itself and the specified rectangle.

void union(int x, int y);
//Update this Rect to enclose itself and the [x,y] coordinate.

final int width();

void writeToParcel(Parcel out, int flags);
//Write this rectangle to the specified parcel.

}

class RectF {
    
final float centerX();

final float centerY();

boolean contains(float left, float top, float right, float bottom);
//Returns true iff the 4 specified sides of a rectangle are inside or equal to this rectangle.

boolean contains(float x, float y);
//Returns true if (x,y); is inside the rectangle.

boolean contains(RectF r);
//Returns true iff the specified rectangle r is inside or equal to this rectangle.

int describeContents();
//Parcelable interface methods

boolean equals(Object o);
//Compares this instance with the specified object and indicates if they are equal.

int hashCode();
//Returns an integer hash code for this object.

final float height();

void inset(float dx, float dy);
//Inset the rectangle by (dx,dy);.

boolean intersect(float left, float top, float right, float bottom);
//If the rectangle specified by left,top,right,bottom intersects this rectangle, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

boolean intersect(RectF r);
//If the specified rectangle intersects this rectangle, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

static boolean intersects(RectF a, RectF b);
//Returns true iff the two specified rectangles intersect.

boolean intersects(float left, float top, float right, float bottom);
//Returns true if this rectangle intersects the specified rectangle.

final boolean isEmpty();
//Returns true if the rectangle is empty (left >= right or top >= bottom);

void offset(float dx, float dy);
//Offset the rectangle by adding dx to its left and right coordinates, and adding dy to its top and bottom coordinates.

void offsetTo(float newLeft, float newTop);
//Offset the rectangle to a specific (left, top); position, keeping its width and height the same.

void readFromParcel(Parcel in);
//Set the rectangle's coordinates from the data stored in the specified parcel.

void round(Rect dst);
//Set the dst integer Rect by rounding this rectangle's coordinates to their nearest integer values.

void roundOut(Rect dst);
//Set the dst integer Rect by rounding "out" this rectangle, choosing the floor of top and left, and the ceiling of right and bottom.

void set(float left, float top, float right, float bottom);
//Set the rectangle's coordinates to the specified values.

void set(RectF src);
//Copy the coordinates from src into this rectangle.

void set(Rect src);
//Copy the coordinates from src into this rectangle.

void setEmpty();
//Set the rectangle to (0,0,0,0);

boolean setIntersect(RectF a, RectF b);
//If rectangles a and b intersect, return true and set this rectangle to that intersection, otherwise return false and do not change this rectangle.

void sort();
//Swap top/bottom or left/right if there are flipped (i.e.

String toShortString();
//Return a string representation of the rectangle in a compact form.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void union(float left, float top, float right, float bottom);
//Update this Rect to enclose itself and the specified rectangle.

void union(RectF r);
//Update this Rect to enclose itself and the specified rectangle.

void union(float x, float y);
//Update this Rect to enclose itself and the [x,y] coordinate.

final float width();

void writeToParcel(Parcel out, int flags);
//Write this rectangle to the specified parcel.



}


package android.graphics.drawable;

class BitmapDrawable {
    
void draw(Canvas canvas);
//Draw in its bounds (set via setBounds); respecting optional effects such as alpha (set via setAlpha); and color filter (set via setColorFilter);.

final Bitmap getBitmap();
//Returns the bitmap used by this drawable to render.

int getChangingConfigurations();
//Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created.

final Drawable.ConstantState getConstantState();
//Return a Drawable.ConstantState instance that holds the shared state of this Drawable.

int getGravity();
//Get the gravity used to position/stretch the bitmap within its bounds.

int getIntrinsicHeight();
//Return the intrinsic height of the underlying drawable object.

int getIntrinsicWidth();
//Return the intrinsic width of the underlying drawable object.

int getOpacity();
//Return the opacity/transparency of this Drawable.

final Paint getPaint();
//Returns the paint used to render this drawable.

Shader.TileMode getTileModeX();
//Indicates the repeat behavior of this drawable on the X axis.

Shader.TileMode getTileModeY();
//Indicates the repeat behavior of this drawable on the Y axis.

void inflate(Resources r, XmlPullParser parser, AttributeSet attrs);
//Inflate this Drawable from an XML resource.

Drawable mutate();
//A mutable BitmapDrawable still shares its Bitmap with any other Drawable that comes from the same resource.

void setAlpha(int alpha);
//Specify an alpha value for the drawable.

void setAntiAlias(boolean aa);
//Enables or disables anti-aliasing for this drawable.

void setColorFilter(ColorFilter cf);
//Specify an optional colorFilter for the drawable.

void setDither(boolean dither);
//Set to true to have the drawable dither its colors when drawn to a device with fewer than 8-bits per color component.

void setFilterBitmap(boolean filter);
//Set to true to have the drawable filter its bitmap when scaled or rotated (for drawables that use bitmaps);.

void setGravity(int gravity);
//Set the gravity used to position/stretch the bitmap within its bounds.

void setTargetDensity(int density);
//Set the density at which this drawable will be rendered.

void setTargetDensity(DisplayMetrics metrics);
//Set the density scale at which this drawable will be rendered.

void setTargetDensity(Canvas canvas);
//Set the density scale at which this drawable will be rendered.

void setTileModeX(Shader.TileMode mode);
//Sets the repeat behavior of this drawable on the X axis.

void setTileModeXY(Shader.TileMode xmode, Shader.TileMode ymode);
//Sets the repeat behavior of this drawable on both axis.

final void setTileModeY(Shader.TileMode mode);
//Sets the repeat behavior of this drawable on the Y axis.

//Protected Methods
void onBoundsChange(Rect bounds);
//Override this in your subclass to change appearance if you recognize the specified state.



}

class Drawable {

void clearColorFilter();

final Rect copyBounds();
//Return a copy of the drawable's bounds in a new Rect.

final void copyBounds(Rect bounds);
//Return a copy of the drawable's bounds in the specified Rect (allocated by the caller);.

static Drawable createFromPath(String pathName);
//Create a drawable from file path name.

static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName, BitmapFactory.Options opts);
//Create a drawable from an inputstream, using the given resources and value to determine density information.

static Drawable createFromResourceStream(Resources res, TypedValue value, InputStream is, String srcName);
//Create a drawable from an inputstream, using the given resources and value to determine density information.

static Drawable createFromStream(InputStream is, String srcName);
//Create a drawable from an inputstream

static Drawable createFromXml(Resources r, XmlPullParser parser);
//Create a drawable from an XML document.

static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs);
//Create from inside an XML document.

abstract void draw(Canvas canvas);
//Draw in its bounds (set via setBounds); respecting optional effects such as alpha (set via setAlpha); and color filter (set via setColorFilter);.

final Rect getBounds();
//Return the drawable's bounds Rect.

Drawable.Callback getCallback();
//Return the current Drawable.Callback implementation attached to this Drawable.

int getChangingConfigurations();
//Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created.

Drawable.ConstantState getConstantState();
//Return a Drawable.ConstantState instance that holds the shared state of this Drawable.

Drawable getCurrent();

int getIntrinsicHeight();
//Return the intrinsic height of the underlying drawable object.

int getIntrinsicWidth();
//Return the intrinsic width of the underlying drawable object.

final int getLevel();
//Retrieve the current level.

int getMinimumHeight();
//Returns the minimum height suggested by this Drawable.

int getMinimumWidth();
//Returns the minimum width suggested by this Drawable.

abstract int getOpacity();
//Return the opacity/transparency of this Drawable.

boolean getPadding(Rect padding);
//Return in padding the insets suggested by this Drawable for placing content inside the drawable's bounds.

int[] getState();
//Describes the current state, as a union of primitve states, such as state_focused, state_selected, etc.

Region getTransparentRegion();
//Returns a Region representing the part of the Drawable that is completely transparent.

void inflate(Resources r, XmlPullParser parser, AttributeSet attrs);
//Inflate this Drawable from an XML resource.

void invalidateSelf();
//Use the current Drawable.Callback implementation to have this Drawable redrawn.

boolean isStateful();
//Indicates whether this view will change its appearance based on state.

final boolean isVisible();

void jumpToCurrentState();
//If this Drawable does transition animations between states, ask that it immediately jump to the current state and skip any active animations.

Drawable mutate();
//Make this drawable mutable.

static int resolveOpacity(int op1, int op2);
//Return the appropriate opacity value for two source opacities.

void scheduleSelf(Runnable what, long when);
//Use the current Drawable.Callback implementation to have this Drawable scheduled.

abstract void setAlpha(int alpha);
//Specify an alpha value for the drawable.

void setBounds(int left, int top, int right, int bottom);
//Specify a bounding rectangle for the Drawable.

void setBounds(Rect bounds);
//Specify a bounding rectangle for the Drawable.

final void setCallback(Drawable.Callback cb);
//Bind a Drawable.Callback object to this Drawable.

void setChangingConfigurations(int configs);
//Set a mask of the configuration parameters for which this drawable may change, requiring that it be re-created.

abstract void setColorFilter(ColorFilter cf);
//Specify an optional colorFilter for the drawable.

void setColorFilter(int color, PorterDuff.Mode mode);
//Specify a color and porterduff mode to be the colorfilter for this drawable.

void setDither(boolean dither);
//Set to true to have the drawable dither its colors when drawn to a device with fewer than 8-bits per color component.

void setFilterBitmap(boolean filter);
//Set to true to have the drawable filter its bitmap when scaled or rotated (for drawables that use bitmaps);.

final boolean setLevel(int level);
//Specify the level for the drawable.

boolean setState(int[] stateSet);
//Specify a set of states for the drawable.

boolean setVisible(boolean visible, boolean restart);
//Set whether this Drawable is visible.

void unscheduleSelf(Runnable what);
//Use the current Drawable.Callback implementation to have this Drawable unscheduled.

//Protected Methods
void onBoundsChange(Rect bounds);
//Override this in your subclass to change appearance if you recognize the specified state.

boolean onLevelChange(int level);
//Override this in your subclass to change appearance if you vary based on level.

boolean onStateChange(int[] state);
//Override this in your subclass to change appearance if you recognize the specified state.

    
}

class ShapeDrawable {

void draw(Canvas canvas);
//Draw in its bounds (set via setBounds); respecting optional effects such as alpha (set via setAlpha); and color filter (set via setColorFilter);.

int getChangingConfigurations();
//Return a mask of the configuration parameters for which this drawable may change, requiring that it be re-created.

Drawable.ConstantState getConstantState();
//Return a Drawable.ConstantState instance that holds the shared state of this Drawable.

int getIntrinsicHeight();
//Return the intrinsic height of the underlying drawable object.

int getIntrinsicWidth();
//Return the intrinsic width of the underlying drawable object.

int getOpacity();
//Return the opacity/transparency of this Drawable.

boolean getPadding(Rect padding);
//Return in padding the insets suggested by this Drawable for placing content inside the drawable's bounds.

Paint getPaint();
//Returns the Paint used to draw the shape.

ShapeDrawable.ShaderFactory getShaderFactory();
//Returns the ShaderFactory used by this ShapeDrawable for requesting a Shader.

Shape getShape();
//Returns the Shape of this ShapeDrawable.

void inflate(Resources r, XmlPullParser parser, AttributeSet attrs);
//Inflate this Drawable from an XML resource.

Drawable mutate();
//Make this drawable mutable.

void setAlpha(int alpha);
//Set the alpha level for this drawable [0..255].

void setColorFilter(ColorFilter cf);
//Specify an optional colorFilter for the drawable.

void setDither(boolean dither);
//Set to true to have the drawable dither its colors when drawn to a device with fewer than 8-bits per color component.

void setIntrinsicHeight(int height);
//Sets the intrinsic (default); height for this shape.

void setIntrinsicWidth(int width);
//Sets the intrinsic (default); width for this shape.

void setPadding(Rect padding);
//Sets padding for this shape, defined by a Rect object.

void setPadding(int left, int top, int right, int bottom);
//Sets padding for the shape.

void setShaderFactory(ShapeDrawable.ShaderFactory fact);
//Sets a ShaderFactory to which requests for a Shader object will be made.

void setShape(Shape s);
//Sets the Shape of this ShapeDrawable.

//Protected Methods
boolean inflateTag(String name, Resources r, XmlPullParser parser, AttributeSet attrs);
//Subclasses override this to parse custom subelements.

void onBoundsChange(Rect bounds);
//Override this in your subclass to change appearance if you recognize the specified state.

void onDraw(Shape shape, Canvas canvas, Paint paint);
//Called from the drawable's draw(); method after the canvas has been set to draw the shape at (0,0);.



}
package android.hardware;

class Camera {

final void addCallbackBuffer(byte[] callbackBuffer);
//Adds a pre-allocated buffer to the preview callback buffer queue.

final void autoFocus( Camera.AutoFocusCallback cb);
//Starts camera auto-focus and registers a callback function to run when the camera is focused.

final void cancelAutoFocus();
//Cancels any auto-focus function in progress.

final boolean enableShutterSound(@Sink(CAMERA_SETTINGS) boolean enabled);
//Enable or disable the default shutter sound when taking a picture.

static void getCameraInfo( int cameraId, @Source(CAMERA) Camera.CameraInfo cameraInfo);
//Returns the information about a particular camera.

static int getNumberOfCameras();
//Returns the number of physical cameras available on this device.

@Source(CAMERA_SETTINGS) Camera.Parameters getParameters();
//Returns the current settings for this Camera service.

final void lock();
//Re-locks the camera to prevent other processes from accessing it.

static @Source(CAMERA) Camera open(int cameraId);
//Creates a new Camera object to access a particular hardware camera.

static @Source(CAMERA) Camera open();
//Creates a new Camera object to access the first back-facing camera on the device.

final void reconnect();
//Reconnects to the camera service after another process used it.

final void release();
//Disconnects and releases the Camera object resources.

void setAutoFocusMoveCallback(Camera.AutoFocusMoveCallback cb);
//Sets camera auto-focus move callback.

final void setDisplayOrientation(@Sink(CAMERA) int degrees);
//Set the clockwise rotation of preview display in degrees.

final void setErrorCallback(Camera.ErrorCallback cb);
//Registers a callback to be invoked when an error occurs.

final void setFaceDetectionListener(Camera.FaceDetectionListener listener);
//Registers a listener to be notified about the faces detected in the preview frame.

final void setOneShotPreviewCallback(Camera.PreviewCallback cb);
//Installs a callback to be invoked for the next preview frame in addition to displaying it on the screen.

void setParameters(@Sink(CAMERA_SETTINGS) Camera.Parameters params);
//Changes the settings for this Camera service.

final void setPreviewCallback(Camera.PreviewCallback cb);
//Installs a callback to be invoked for every preview frame in addition to displaying them on the screen.

final void setPreviewCallbackWithBuffer(Camera.PreviewCallback cb);
//Installs a callback to be invoked for every preview frame, using buffers supplied with addCallbackBuffer(byte[]);, in addition to displaying them on the screen.

final void setPreviewDisplay(@Source(CAMERA) SurfaceHolder holder);
//Sets the Surface to be used for live preview.

final void setPreviewTexture(@Source(CAMERA) SurfaceTexture surfaceTexture);
//Sets the SurfaceTexture to be used for live preview.

final void setZoomChangeListener(Camera.OnZoomChangeListener listener);
//Registers a listener to be notified when the zoom value is updated by the camera driver during smooth zoom.

final void startFaceDetection();
//Starts the face detection.

final void startPreview();
//Starts capturing and drawing preview frames to the screen.

final void startSmoothZoom(int value);
//Zooms to the requested value smoothly.

final void stopFaceDetection();
//Stops the face detection.

final void stopPreview();
//Stops capturing and drawing preview frames to the surface, and resets the camera for a future call to startPreview();.

final void stopSmoothZoom();
//Stops the smooth zoom.

final void takePicture(Camera.ShutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback jpeg);
//Equivalent to takePicture(shutter, raw, null, jpeg);.

final void takePicture(Camera.ShutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback postview, Camera.PictureCallback jpeg);
//Triggers an asynchronous image capture.

final void unlock();
//Unlocks the camera to allow another process to access it.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.
}
interface Camera$PictureCallback {
    void onPictureTaken(@Source(FlowPermission.CAMERA) byte @Source(FlowPermission.CAMERA) [] arg0, @Source(FlowPermission.CAMERA) Camera arg1);
}
 
class Camera$Parameters {
    
String flatten();
//Creates a single string with all the parameters set in this Parameters object.

String get(String key);
//Returns the value of a String parameter.

String getAntibanding();
//Gets the current antibanding setting.

boolean getAutoExposureLock();
//Gets the state of the auto-exposure lock.

boolean getAutoWhiteBalanceLock();
//Gets the state of the auto-white balance lock.

String getColorEffect();
//Gets the current color effect setting.

int getExposureCompensation();
//Gets the current exposure compensation index.

float getExposureCompensationStep();
//Gets the exposure compensation step.

String getFlashMode();
//Gets the current flash mode setting.

float getFocalLength();
//Gets the focal length (in millimeter); of the camera.

List<Camera.Area> getFocusAreas();
//Gets the current focus areas.

void getFocusDistances(float[] output);
//Gets the distances from the camera to where an object appears to be in focus.

String getFocusMode();
//Gets the current focus mode setting.

float getHorizontalViewAngle();
//Gets the horizontal angle of view in degrees.

int getInt(String key);
//Returns the value of an integer parameter.

int getJpegQuality();
//Returns the quality setting for the JPEG picture.

int getJpegThumbnailQuality();
//Returns the quality setting for the EXIF thumbnail in Jpeg picture.

Camera.Size getJpegThumbnailSize();
//Returns the dimensions for EXIF thumbnail in Jpeg picture.

int getMaxExposureCompensation();
//Gets the maximum exposure compensation index.

int getMaxNumDetectedFaces();
//Gets the maximum number of detected faces supported.

int getMaxNumFocusAreas();
//Gets the maximum number of focus areas supported.

int getMaxNumMeteringAreas();
//Gets the maximum number of metering areas supported.

int getMaxZoom();
//Gets the maximum zoom value allowed for snapshot.

List<Camera.Area> getMeteringAreas();
//Gets the current metering areas.

int getMinExposureCompensation();
//Gets the minimum exposure compensation index.

int getPictureFormat();
//Returns the image format for pictures.

Camera.Size getPictureSize();
//Returns the dimension setting for pictures.

Camera.Size getPreferredPreviewSizeForVideo();
//Returns the preferred or recommended preview size (width and height); in pixels for video recording.

int getPreviewFormat();
//Returns the image format for preview frames got from Camera.PreviewCallback.

void getPreviewFpsRange(int[] range);
//Returns the current minimum and maximum preview fps.

int getPreviewFrameRate();
//This method was deprecated in API level 9. replaced by getPreviewFpsRange(int[]);

Camera.Size getPreviewSize();
//Returns the dimensions setting for preview pictures.

String getSceneMode();
//Gets the current scene mode setting.

List<String> getSupportedAntibanding();
//Gets the supported antibanding values.

List<String> getSupportedColorEffects();
//Gets the supported color effects.

List<String> getSupportedFlashModes();
//Gets the supported flash modes.

List<String> getSupportedFocusModes();
//Gets the supported focus modes.

List<Camera.Size> getSupportedJpegThumbnailSizes();
//Gets the supported jpeg thumbnail sizes.

List<Integer> getSupportedPictureFormats();
//Gets the supported picture formats.

List<Camera.Size> getSupportedPictureSizes();
//Gets the supported picture sizes.

List<Integer> getSupportedPreviewFormats();
//Gets the supported preview formats.

List<int[]> getSupportedPreviewFpsRange();
//Gets the supported preview fps (frame-per-second); ranges.

List<Integer> getSupportedPreviewFrameRates();
//This method was deprecated in API level 9. replaced by getSupportedPreviewFpsRange();

List<Camera.Size> getSupportedPreviewSizes();
//Gets the supported preview sizes.

List<String> getSupportedSceneModes();
//Gets the supported scene modes.

List<Camera.Size> getSupportedVideoSizes();
//Gets the supported video frame sizes that can be used by MediaRecorder.

List<String> getSupportedWhiteBalance();
//Gets the supported white balance.

float getVerticalViewAngle();
//Gets the vertical angle of view in degrees.

boolean getVideoStabilization();
//Get the current state of video stabilization.

String getWhiteBalance();
//Gets the current white balance setting.

int getZoom();
//Gets current zoom value.

List<Integer> getZoomRatios();
//Gets the zoom ratios of all zoom values.

boolean isAutoExposureLockSupported();
//Returns true if auto-exposure locking is supported.

boolean isAutoWhiteBalanceLockSupported();
//Returns true if auto-white balance locking is supported.

boolean isSmoothZoomSupported();
//Returns true if smooth zoom is supported.

boolean isVideoSnapshotSupported();
//Returns true if video snapshot is supported.

boolean isVideoStabilizationSupported();
//Returns true if video stabilization is supported.

boolean isZoomSupported();
//Returns true if zoom is supported.

void remove(String key);
//void removeGpsData();
//Removes GPS latitude, longitude, altitude, and timestamp from the parameters.

void set(String key, String value);
//Sets a String parameter.

void set(String key, int value);
//Sets an integer parameter.

void setAntibanding(String antibanding);
//Sets the antibanding.

void setAutoExposureLock(boolean toggle);
//Sets the auto-exposure lock state.

void setAutoWhiteBalanceLock(boolean toggle);
//Sets the auto-white balance lock state.

void setColorEffect(String value);
//Sets the current color effect setting.

void setExposureCompensation(int value);
//Sets the exposure compensation index.

void setFlashMode(String value);
//Sets the flash mode.

void setFocusAreas(List<Camera.Area> focusAreas);
//Sets focus areas.

void setFocusMode(String value);
//Sets the focus mode.

void setGpsAltitude(double altitude);
//Sets GPS altitude.

void setGpsLatitude(double latitude);
//Sets GPS latitude coordinate.

void setGpsLongitude(double longitude);
//Sets GPS longitude coordinate.

void setGpsProcessingMethod(String processing_method);
//Sets GPS processing method.

void setGpsTimestamp(long timestamp);
//Sets GPS timestamp.

void setJpegQuality(int quality);
//Sets Jpeg quality of captured picture.

void setJpegThumbnailQuality(int quality);
//Sets the quality of the EXIF thumbnail in Jpeg picture.

void setJpegThumbnailSize(int width, int height);
//Sets the dimensions for EXIF thumbnail in Jpeg picture.

void setMeteringAreas(List<Camera.Area> meteringAreas);
//Sets metering areas.

void setPictureFormat(int pixel_format);
//Sets the image format for pictures.

void setPictureSize(int width, int height);
//Sets the dimensions for pictures.

void setPreviewFormat(int pixel_format);
//Sets the image format for preview pictures.

void setPreviewFpsRange(int min, int max);
//Sets the maximum and maximum preview fps.

void setPreviewFrameRate(int fps);
//This method was deprecated in API level 9. replaced by setPreviewFpsRange(int, int);

void setPreviewSize(int width, int height);
//Sets the dimensions for preview pictures.

void setRecordingHint(boolean hint);
//Sets recording mode hint.

void setRotation(int rotation);
//Sets the clockwise rotation angle in degrees relative to the orientation of the camera.

void setSceneMode(String value);
//Sets the scene mode.

void setVideoStabilization(boolean toggle);
//Enables and disables video stabilization.

void setWhiteBalance(String value);
//Sets the white balance.

void setZoom(int value);
//Sets current zoom value.

void unflatten(String flattened);
//Takes a flattened string of parameters and adds each one to this Parameters object.



}

class Camera$AutoFocusCallback{
            void onAutoFocus(boolean arg0, Camera arg1);
}

class Sensor {
    
float getMaximumRange();

int getMinDelay();

String getName();

float getPower();

float getResolution();

int getType();

String getVendor();

int getVersion();

String toString();
//Returns a string containing a concise, human-readable description of this object.



}

class SensorEventListener {

void onSensorChanged(SensorEvent arg0);
//Called when sensor values have changed.

void onAccuracyChanged(Sensor arg0, int arg1);
//Called when the accuracy of a sensor has changed.
}


class SensorManager {
    
    
static float getAltitude(float p0, float p);
//Computes the Altitude in meters from the atmospheric pressure and the pressure at sea level.

static void getAngleChange(float[] angleChange, float[] R, float[] prevR);
//Helper function to compute the angle change between two rotation matrices.

Sensor getDefaultSensor(int type);
//Use this method to get the default sensor for a given type.

static float getInclination(float[] I);
//Computes the geomagnetic inclination angle in radians from the inclination matrix I returned by getRotationMatrix(float[], float[], float[], float[]);.

static float[] getOrientation(float[] R, float[] values);
//Computes the device's orientation based on the rotation matrix.

static void getQuaternionFromVector(float[] Q, float[] rv);
//Helper function to convert a rotation vector to a normalized quaternion.

static boolean getRotationMatrix(float[] R, float[] I, float[] gravity, float[] geomagnetic);
//Computes the inclination matrix I as well as the rotation matrix R transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where:

//X is defined as the vector product Y.Z (It is tangential to the ground at the device's current location and roughly points East);.

static void getRotationMatrixFromVector(float[] R, float[] rotationVector);
//Helper function to convert a rotation vector to a rotation matrix.

List<Sensor> getSensorList(int type);
//Use this method to get the list of available sensors of a certain type.

int getSensors();
//This method was deprecated in API level 3. This method is deprecated, use getSensorList(int); instead

boolean registerListener(SensorListener listener, int sensors, int rate);
//This method was deprecated in API level 3. This method is deprecated, use registerListener(SensorEventListener, Sensor, int); instead.

boolean registerListener(SensorListener listener, int sensors);
//This method was deprecated in API level 3. This method is deprecated, use registerListener(SensorEventListener, Sensor, int); instead.

boolean registerListener(SensorEventListener listener, Sensor sensor, int rate, Handler handler);
//Registers a SensorEventListener for the given sensor.

boolean registerListener(SensorEventListener listener, Sensor sensor, int rate);
//Registers a SensorEventListener for the given sensor.

static boolean remapCoordinateSystem(float[] inR, int X, int Y, float[] outR);
//Rotates the supplied rotation matrix so it is expressed in a different coordinate system.

void unregisterListener(SensorListener listener);
//This method was deprecated in API level 3. This method is deprecated, use unregisterListener(SensorEventListener); instead.

void unregisterListener(SensorListener listener, int sensors);
//This method was deprecated in API level 3. This method is deprecated, use unregisterListener(SensorEventListener, Sensor); instead.

void unregisterListener(SensorEventListener listener, Sensor sensor);
//Unregisters a listener for the sensors with which it is registered.

void unregisterListener(SensorEventListener listener);
//Unregisters a listener for all sensors.



}



package android.inputmethodservice;

class InputMethodService {
    
    
boolean enableHardwareAcceleration();
//You can call this to try to enable hardware accelerated drawing for your IME.

int getBackDisposition();

int getCandidatesHiddenVisibility();
//Returns the visibility mode (either View.INVISIBLE or View.GONE); of the candidates view when it is not shown.

InputBinding getCurrentInputBinding();
//Return the currently active InputBinding for the input method, or null if there is none.

InputConnection getCurrentInputConnection();
//Retrieve the currently active InputConnection that is bound to the input method, or null if there is none.

EditorInfo getCurrentInputEditorInfo();

boolean getCurrentInputStarted();

LayoutInflater getLayoutInflater();

int getMaxWidth();
//Return the maximum width, in pixels, available the input method.

CharSequence getTextForImeAction(int imeOptions);
//Return text that can be used as a button label for the given EditorInfo.imeOptions.

Dialog getWindow();

void hideStatusIcon();

void hideWindow();

boolean isExtractViewShown();
//Return whether the fullscreen extract view is shown.

boolean isFullscreenMode();
//Return whether the input method is currently running in fullscreen mode.

boolean isInputViewShown();
//Return whether the soft input view is currently shown to the user.

boolean isShowInputRequested();
//Returns true if we have been asked to show our input view.

void onAppPrivateCommand(String action, Bundle data);

void onBindInput();
//Called when a new client has bound to the input method.

void onComputeInsets(InputMethodService.Insets outInsets);
//Compute the interesting insets into your UI.

void onConfigurationChanged(Configuration newConfig);
//Take care of handling configuration changes.

void onConfigureWindow(Window win, boolean isFullscreen, boolean isCandidatesOnly);
//Update the given window's parameters for the given mode.

void onCreate();
//Called by the system when the service is first created.

View onCreateCandidatesView();
//Create and return the view hierarchy used to show candidates.

View onCreateExtractTextView();
//Called by the framework to create the layout for showing extacted text.

AbstractInputMethodService.AbstractInputMethodImpl onCreateInputMethodInterface();
//Implement to return our standard InputMethodService.InputMethodImpl.

AbstractInputMethodService.AbstractInputMethodSessionImpl onCreateInputMethodSessionInterface();
//Implement to return our standard InputMethodService.InputMethodSessionImpl.

View onCreateInputView();
//Create and return the view hierarchy used for the input area (such as a soft keyboard);.

void onDestroy();
//Called by the system to notify a Service that it is no longer used and is being removed.

void onDisplayCompletions(CompletionInfo[] completions);
//Called when the application has reported auto-completion candidates that it would like to have the input method displayed.

boolean onEvaluateFullscreenMode();
//Override this to control when the input method should run in fullscreen mode.

boolean onEvaluateInputViewShown();
//Override this to control when the soft input area should be shown to the user.

boolean onExtractTextContextMenuItem(int id);
//This is called when the user has selected a context menu item from the extracted text view, when running in fullscreen mode.

void onExtractedCursorMovement(int dx, int dy);
//This is called when the user has performed a cursor movement in the extracted text view, when it is running in fullscreen mode.

void onExtractedSelectionChanged(int start, int end);
//This is called when the user has moved the cursor in the extracted text view, when running in fullsreen mode.

void onExtractedTextClicked();
//This is called when the user has clicked on the extracted text view, when running in fullscreen mode.

void onExtractingInputChanged(EditorInfo ei);
//This is called when, while currently displayed in extract mode, the current input target changes.

void onFinishCandidatesView(boolean finishingInput);
//Called when the candidates view is being hidden from the user.

void onFinishInput();
//Called to inform the input method that text input has finished in the last editor.

void onFinishInputView(boolean finishingInput);
//Called when the input view is being hidden from the user.

boolean onGenericMotionEvent(MotionEvent event);
//Override this to intercept generic motion events before they are processed by the application.

void onInitializeInterface();
//This is a hook that subclasses can use to perform initialization of their interface.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Override this to intercept key down events before they are processed by the application.

boolean onKeyLongPress(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyLongPress();: always returns false (doesn't handle the event);.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int count, @Source(USER_INPUT) KeyEvent event);
//Override this to intercept special key multiple events before they are processed by the application.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Override this to intercept key up events before they are processed by the application.

boolean onShowInputRequested(int flags, boolean configChange);
//The system has decided that it may be time to show your input method.

void onStartCandidatesView(EditorInfo info, boolean restarting);
//Called when only the candidates view has been shown for showing processing as the user enters text through a hard keyboard.

void onStartInput(EditorInfo attribute, boolean restarting);
//Called to inform the input method that text input has started in an editor.

void onStartInputView(EditorInfo info, boolean restarting);
//Called when the input view is being shown and input has started on a new editor.

boolean onTrackballEvent(MotionEvent event);
//Override this to intercept trackball motion events before they are processed by the application.

void onUnbindInput();
//Called when the previous bound client is no longer associated with the input method.

void onUpdateCursor(Rect newCursor);
//Called when the application has reported a new location of its text cursor.

void onUpdateExtractedText(int token, ExtractedText text);
//Called when the application has reported new extracted text to be shown due to changes in its current text state.

void onUpdateExtractingViews(EditorInfo ei);
//Called when the fullscreen-mode extracting editor info has changed, to update the state of its UI such as the action buttons shown.

void onUpdateExtractingVisibility(EditorInfo ei);
//Called when the fullscreen-mode extracting editor info has changed, to determine whether the extracting (extract text and candidates); portion of the UI should be shown.

void onUpdateSelection(int oldSelStart, int oldSelEnd, int newSelStart, int newSelEnd, int candidatesStart, int candidatesEnd);
//Called when the application has reported a new selection region of the text.

void onViewClicked(boolean focusChanged);
//Called when the user tapped or clicked a text view.

void onWindowHidden();
//Called when the input method window has been hidden from the user, after previously being visible.

void onWindowShown();
//Called when the input method window has been shown to the user, after previously not being visible.

void requestHideSelf(int flags);
//Close this input method's soft input area, removing it from the display.

boolean sendDefaultEditorAction(boolean fromEnterKey);
//Ask the input target to execute its default action via InputConnection.performEditorAction();.

void sendDownUpKeyEvents(@Source(USER_INPUT) int keyEventCode);
//Send the given key event code (as defined by KeyEvent); to the current input connection is a key down + key up event pair.

void sendKeyChar(@Source(USER_INPUT) char charCode);
//Send the given UTF-16 character to the current input connection.

void setBackDisposition(int disposition);

void setCandidatesView(@Sink(DISPLAY) View view);
//Replaces the current candidates view with a new one.

void setCandidatesViewShown(boolean shown);
//Controls the visibility of the candidates display area.

void setExtractView(@Sink(DISPLAY) View view);

void setExtractViewShown(boolean shown);
//Controls the visibility of the extracted text area.

void setInputView(@Sink(DISPLAY) View view);
//Replaces the current input view with a new one.

void setTheme(int theme);
//You can call this to customize the theme used by your IME's window.

void showStatusIcon(int iconResId);

void showWindow(boolean showInput);

void switchInputMethod(String id);
//Force switch to a new input method, as identified by id.

void updateFullscreenMode();
//Re-evaluate whether the input method should be running in fullscreen mode, and update its UI if this has changed since the last time it was evaluated.

void updateInputViewShown();
//Re-evaluate whether the soft input area should currently be shown, and update its UI if this has changed since the last time it was evaluated.

//Protected Methods
void dump(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET})FileDescriptor fd, @PolyFlowReceiver PrintWriter fout, String[] args);
//Performs a dump of the InputMethodService's internal state.

void onCurrentInputMethodSubtypeChanged(InputMethodSubtype newSubtype);
//Called when the subtype was changed.



}


class Keyboard {
    
    
int getHeight();
//Returns the total height of the keyboard

List<Keyboard.Key> getKeys();

int getMinWidth();

List<Keyboard.Key> getModifierKeys();

int[] getNearestKeys(int x, int y);
//Returns the indices of the keys that are closest to the given point.

int getShiftKeyIndex();

boolean isShifted();

boolean setShifted(boolean shiftState);

//Protected Methods
Keyboard.Key createKeyFromXml(Resources res, Keyboard.Row parent, int x, int y, XmlResourceParser parser);

Keyboard.Row createRowFromXml(Resources res, XmlResourceParser parser);

int getHorizontalGap();

int getKeyHeight();

int getKeyWidth();

int getVerticalGap();

void setHorizontalGap(int gap);

void setKeyHeight(int height);

void setKeyWidth(int width);

void setVerticalGap(int gap);


}

class Keyboard$Key {
    
int[] getCurrentDrawableState();
//Returns the drawable state for the key, based on the current state and type of the key.

boolean isInside(int x, int y);
//Detects if a point falls inside this key.

void onPressed();
//Informs the key that it has been pressed, in case it needs to change its appearance or state.

void onReleased(boolean inside);
//Changes the pressed state of the key.

int squaredDistanceFrom(int x, int y);
//Returns the square of the distance between the center of the key and the given point.



}

class KeyboardView {
    
    
void closing();

Keyboard getKeyboard();
//Returns the current keyboard being displayed by this view.

boolean handleBack();

void invalidateAllKeys();
//Requests a redraw of the entire keyboard.

void invalidateKey(int keyIndex);
//Invalidates a key so that it will be redrawn on the next repaint.

boolean isPreviewEnabled();
//Returns the enabled state of the key feedback popup.

boolean isProximityCorrectionEnabled();
//Returns true if proximity correction is enabled.

boolean isShifted();
//Returns the state of the shift key of the keyboard, if any.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

boolean onHoverEvent(MotionEvent event);
//Implement this method to handle hover events.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

boolean onTouchEvent(MotionEvent me);
//Implement this method to handle touch screen motion events.

void setKeyboard(Keyboard keyboard);
//Attaches a keyboard to this view.

void setOnKeyboardActionListener(KeyboardView.OnKeyboardActionListener listener);

void setPopupOffset(int x, int y);

void setPopupParent(View v);

void setPreviewEnabled(boolean previewEnabled);
//Enables or disables the key feedback popup.

void setProximityCorrectionEnabled(boolean enabled);
//When enabled, calls to onKey(int, int[]); will include key codes for adjacent keys.

boolean setShifted(boolean shifted);
//Sets the state of the shift key of the keyboard, if any.

void setVerticalCorrection(int verticalOffset);
//Protected Methods

KeyboardView.OnKeyboardActionListener getOnKeyboardActionListener();
//Returns the KeyboardView.OnKeyboardActionListener object.

boolean onLongPress(@Source(USER_INPUT) Keyboard.Key popupKey);
//Called when a key is long pressed.

void swipeDown();

void swipeLeft();

void swipeRight();

void swipeUp();


}

class KeyboardView$OnKeyboardActionListener {
    
abstract void onKey(@Source(USER_INPUT) int primaryCode, @Source(USER_INPUT) int[] keyCodes);
//Send a key press to the listener.

abstract void onPress(@Source(USER_INPUT) int primaryCode);
//Called when the user presses a key.

abstract void onRelease(@Source(USER_INPUT) int primaryCode);
//Called when the user releases a key.

abstract void onText(CharSequence text);
//Sends a sequence of characters to the listener.

abstract void swipeDown();
//Called when the user quickly moves the finger from up to down.

abstract void swipeLeft();
//Called when the user quickly moves the finger from right to left.

abstract void swipeRight();
//Called when the user quickly moves the finger from left to right.

abstract void swipeUp();
//Called when the user quickly moves the finger from down to up.



}
package android.location;

class Address {
    
void clearLatitude();
//Removes any latitude associated with this address.

void clearLongitude();
//Removes any longitude associated with this address.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

String getAddressLine(int index);
//Returns a line of the address numbered by the given index (starting at 0);, or null if no such line is present.

String getAdminArea();
//Returns the administrative area name of the address, for example, "CA", or null if it is unknown

String getCountryCode();
//Returns the country code of the address, for example "US", or null if it is unknown.

String getCountryName();
//Returns the localized country name of the address, for example "Iceland", or null if it is unknown.

Bundle getExtras();
//Returns additional provider-specific information about the address as a Bundle.

String getFeatureName();
//Returns the feature name of the address, for example, "Golden Gate Bridge", or null if it is unknown

double getLatitude();
//Returns the latitude of the address if known.

Locale getLocale();
//Returns the Locale associated with this address.

String getLocality();
//Returns the locality of the address, for example "Mountain View", or null if it is unknown.

double getLongitude();
//Returns the longitude of the address if known.

int getMaxAddressLineIndex();
//Returns the largest index currently in use to specify an address line.

String getPhone();
//Returns the phone number of the address if known, or null if it is unknown.

String getPostalCode();
//Returns the postal code of the address, for example "94110", or null if it is unknown.

String getPremises();
//Returns the premises of the address, or null if it is unknown.

String getSubAdminArea();
//Returns the sub-administrative area name of the address, for example, "Santa Clara County", or null if it is unknown

String getSubLocality();
//Returns the sub-locality of the address, or null if it is unknown.

String getSubThoroughfare();
//Returns the sub-thoroughfare name of the address, which may be null.

String getThoroughfare();
//Returns the thoroughfare name of the address, for example, "1600 Ampitheater Parkway", which may be null

String getUrl();
//Returns the public URL for the address if known, or null if it is unknown.

boolean hasLatitude();
//Returns true if a latitude has been assigned to this Address, false otherwise.

boolean hasLongitude();
//Returns true if a longitude has been assigned to this Address, false otherwise.

void setAddressLine(int index, String line);
//Sets the line of the address numbered by index (starting at 0); to the given String, which may be null.

void setAdminArea(String adminArea);
//Sets the administrative area name of the address to the given String, which may be null

void setCountryCode(String countryCode);
//Sets the country code of the address to the given String, which may be null.

void setCountryName(String countryName);
//Sets the country name of the address to the given String, which may be null.

void setExtras(Bundle extras);
//Sets the extra information associated with this fix to the given Bundle.

void setFeatureName(String featureName);
//Sets the feature name of the address to the given String, which may be null

void setLatitude(double latitude);
//Sets the latitude associated with this address.

void setLocality(String locality);
//Sets the locality of the address to the given String, which may be null.

void setLongitude(double longitude);
//Sets the longitude associated with this address.

void setPhone(String phone);
//Sets the phone number associated with this address.

void setPostalCode(String postalCode);
//Sets the postal code of the address to the given String, which may be null.

void setPremises(String premises);
//Sets the premises of the address to the given String, which may be null.

void setSubAdminArea(String subAdminArea);
//Sets the sub-administrative area name of the address to the given String, which may be null

void setSubLocality(String sublocality);
//Sets the sub-locality of the address to the given String, which may be null.

void setSubThoroughfare(String subthoroughfare);
//Sets the sub-thoroughfare name of the address, which may be null.

void setThoroughfare(String thoroughfare);
//Sets the thoroughfare name of the address, which may be null.

void setUrl(String Url);
//Sets the public URL associated with this address.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel parcel, int flags);
//Flatten this object in to a Parcel.


}

class Geocoder {

List<Address> getFromLocation(double latitude, double longitude, int maxResults);
//Returns an array of Addresses that are known to describe the area immediately surrounding the given latitude and longitude.

List<Address> getFromLocationName(String locationName, int maxResults, double lowerLeftLatitude, double lowerLeftLongitude, double upperRightLatitude, double upperRightLongitude);
//Returns an array of Addresses that are known to describe the named location, which may be a place name such as "Dalvik, Iceland", an address such as "1600 Amphitheatre Parkway, Mountain View, CA", an airport code such as "SFO", etc..

List<Address> getFromLocationName(String locationName, int maxResults);
//Returns an array of Addresses that are known to describe the named location, which may be a place name such as "Dalvik, Iceland", an address such as "1600 Amphitheatre Parkway, Mountain View, CA", an airport code such as "SFO", etc..

static boolean isPresent();
//Returns true if the Geocoder methods getFromLocation and getFromLocationName are implemented.

}

class Location {
    
float bearingTo(Location dest);
//Returns the approximate initial bearing in degrees East of true North when traveling along the shortest path between this location and the given location.

static double convert(String coordinate);
//Converts a String in one of the formats described by FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS into a double.

static String convert(double coordinate, int outputType);
//Converts a coordinate to a String representation.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

static void distanceBetween(double startLatitude, double startLongitude, double endLatitude, double endLongitude, float[] results);
//Computes the approximate distance in meters between two locations, and optionally the initial and final bearings of the shortest path between them.

float distanceTo(Location dest);
//Returns the approximate distance in meters between this location and the given location.

void dump(@PolyFlowReceiver Printer pw, String prefix);

float getAccuracy();
//Get the estimated accuracy of this location, in meters.

double getAltitude();
//Get the altitude if available, in meters above sea level.

float getBearing();
//Get the bearing, in degrees.

long getElapsedRealtimeNanos();
//Return the time of this fix, in elapsed real-time since system boot.

Bundle getExtras();
//Returns additional provider-specific information about the location fix as a Bundle.

double getLatitude();
//Get the latitude, in degrees.

double getLongitude();
//Get the longitude, in degrees.

String getProvider();
//Returns the name of the provider that generated this fix.

float getSpeed();
//Get the speed if it is available, in meters/second over ground.

long getTime();
//Return the UTC time of this fix, in milliseconds since January 1, 1970.

boolean hasAccuracy();
//True if this location has an accuracy.

boolean hasAltitude();
//True if this location has an altitude.

boolean hasBearing();
//True if this location has a bearing.

boolean hasSpeed();
//True if this location has a speed.

void removeAccuracy();
//Remove the accuracy from this location.

void removeAltitude();
//Remove the altitude from this location.

void removeBearing();
//Remove the bearing from this location.

void removeSpeed();
//Remove the speed from this location.

void reset();
//Clears the contents of the location.

void set(Location l);
//Sets the contents of the location to the values from the given location.

void setAccuracy(float accuracy);
//Set the estimated accuracy of this location, meters.

void setAltitude(double altitude);
//Set the altitude, in meters above sea level.

void setBearing(float bearing);
//Set the bearing, in degrees.

void setElapsedRealtimeNanos(long time);
//Set the time of this fix, in elapsed real-time since system boot.

void setExtras(Bundle extras);
//Sets the extra information associated with this fix to the given Bundle.

void setLatitude(double latitude);
//Set the latitude, in degrees.

void setLongitude(double longitude);
//Set the longitude, in degrees.

void setProvider(String provider);
//Sets the name of the provider that generated this fix.

void setSpeed(float speed);
//Set the speed, in meters/second over ground.

void setTime(long time);
//Set the UTC time of this fix, in milliseconds since January 1, 1970.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel parcel, int flags);
//Flatten this object in to a Parcel.

    
}

class LocationListener {
    
    
abstract void onLocationChanged(@Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION}) Location location);
//Called when the location has changed.

abstract void onProviderDisabled(String provider);
//Called when the provider is disabled by the user.

abstract void onProviderEnabled(String provider);
//Called when the provider is enabled by the user.

abstract void onStatusChanged(String provider, int status, Bundle extras);
//Called when the provider status changes.



}

class LocationManager {
    
    
boolean addGpsStatusListener(GpsStatus.Listener listener) @Source(ACCESS_FINE_LOCATION);
//Adds a GPS status listener.

boolean addNmeaListener(GpsStatus.NmeaListener listener) @Source(ACCESS_FINE_LOCATION);
//Adds an NMEA listener.

void addProximityAlert(double latitude, double longitude, float radius, long expiration, PendingIntent intent) @Source(ACCESS_FINE_LOCATION);
//Set a proximity alert for the location given by the position (latitude, longitude); and the given radius.

void addTestProvider(String name, boolean requiresNetwork, boolean requiresSatellite, boolean requiresCell, boolean hasMonetaryCost, boolean supportsAltitude, boolean supportsSpeed, boolean supportsBearing, int powerRequirement, int accuracy) @Source(ACCESS_MOCK_LOCATION);
//Creates a mock location provider and adds it to the set of active providers.

void clearTestProviderEnabled(String provider) @Source(ACCESS_MOCK_LOCATION);
//Removes any mock enabled value associated with the given provider.

void clearTestProviderLocation(String provider) @Source(ACCESS_MOCK_LOCATION);
//Removes any mock location associated with the given provider.

void clearTestProviderStatus(String provider) @Source(ACCESS_MOCK_LOCATION);
//Removes any mock status values associated with the given provider.

List<String> getAllProviders();
//Returns a list of the names of all known location providers.

String getBestProvider(Criteria criteria, boolean enabledOnly);
//Returns the name of the provider that best meets the given criteria.

GpsStatus getGpsStatus(GpsStatus status);
//Retrieves information about the current status of the GPS engine.

@Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION}) Location getLastKnownLocation(String provider);
//Returns a Location indicating the data from the last known location fix obtained from the given provider.

@Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION}) LocationProvider getProvider(String name);
//Returns the information associated with the location provider of the given name, or null if no provider exists by that name.

List<String> getProviders(boolean enabledOnly);
//Returns a list of the names of location providers.

List<String> getProviders(Criteria criteria, boolean enabledOnly);
//Returns a list of the names of LocationProviders that satisfy the given criteria, or null if none do.

@Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION}) boolean isProviderEnabled(String provider);
//Returns the current enabled/disabled status of the given provider.

void removeGpsStatusListener(GpsStatus.Listener listener);
//Removes a GPS status listener.

void removeNmeaListener(GpsStatus.NmeaListener listener);
//Removes an NMEA listener.

void removeProximityAlert(PendingIntent intent) @Source(ACCESS_FINE_LOCATION);
//Removes the proximity alert with the given PendingIntent.

void removeTestProvider(String provider) @Source(ACCESS_MOCK_LOCATION);
//Removes the mock location provider with the given name.

void removeUpdates(PendingIntent intent);
//Removes all location updates for the specified pending intent.

void removeUpdates(LocationListener listener);
//Removes all location updates for the specified LocationListener.

void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for location updates using a Criteria and pending intent.

void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener, Looper looper) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for location updates using a Criteria, and a callback on the specified looper thread.

void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for location updates using the named provider, and a pending intent.

void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener, Looper looper) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for location updates using the named provider, and a callback on the specified looper thread.

void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for location updates using the named provider, and a pending intent.

void requestSingleUpdate(String provider, LocationListener listener, Looper looper) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for a single location update using the named provider and a callback.

void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for a single location update using a Criteria and a callback.

void requestSingleUpdate(String provider, PendingIntent intent) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for a single location update using a named provider and pending intent.

void requestSingleUpdate(Criteria criteria, PendingIntent intent) @Source({ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION});
//Register for a single location update using a Criteria and pending intent.

boolean sendExtraCommand(String provider, String command, Bundle extras);
//Sends additional commands to a location provider.

void setTestProviderEnabled(String provider, boolean enabled) @Source(ACCESS_MOCK_LOCATION);
//Sets a mock enabled value for the given provider.

void setTestProviderLocation(String provider, Location loc) @Source(ACCESS_MOCK_LOCATION);
//Sets a mock location for the given provider.

void setTestProviderStatus(String provider, int status, Bundle extras, long updateTime) @Source(ACCESS_MOCK_LOCATION);
//Sets mock status values for the given provider.



}
package android.media;

class CamcorderProfile {
    
    
static CamcorderProfile get(int quality);
//Returns the camcorder profile for the first back-facing camera on the device at the given quality level.

static CamcorderProfile get(int cameraId, int quality);
//Returns the camcorder profile for the given camera at the given quality level.

static boolean hasProfile(int quality);
//Returns true if camcorder profile exists for the first back-facing camera at the given quality level.

static boolean hasProfile(int cameraId, int quality);
//Returns true if camcorder profile exists for the given camera at the given quality level.



}

class ExifInterface {
    // Added by mcarthur
    @Source({FlowPermission.READ_EXTERNAL_STORAGE}) 
    String getAttribute(@Sink(FlowPermission.CONDITIONAL) String tag);

    ExifInterface(@Sink(FlowPermission.FILESYSTEM) String path);
    void setAttribute(String tag, String value);

}

class MediaPlayer {
        void reset();
        void pause() throws IllegalStateException;
        void setOnPreparedListener(OnPreparedListener listener);
        void setLooping(boolean arg0);
        void setDataSource(String arg0) throws IOException,IllegalArgumentException,SecurityException,IllegalStateException;
        void start() throws IllegalStateException;
        void prepare() throws IOException,IllegalStateException;
        MediaPlayer();
}

class MediaPlayer$OnPreparedListener{
        void onPrepared(MediaPlayer arg0);
}

class MediaRecorder {
    
final static int getAudioSourceMax();
//Gets the maximum value for audio sources.

int getMaxAmplitude();
//Returns the maximum absolute amplitude that was sampled since the last call to this method.

void prepare();
//Prepares the recorder to begin capturing and encoding data.

void release();
//Releases resources associated with this MediaRecorder object.

void reset();
//Restarts the MediaRecorder to its idle state.

void setAudioChannels(int numChannels);
//Sets the number of audio channels for recording.

void setAudioEncoder(int audio_encoder);
//Sets the audio encoder to be used for recording.

void setAudioEncodingBitRate(int bitRate);
//Sets the audio encoding bit rate for recording.

void setAudioSamplingRate(int samplingRate);
//Sets the audio sampling rate for recording.

void setAudioSource(int audio_source);
//Sets the audio source to be used for recording.

void setCamera(Camera c);
//Sets a Camera to use for recording.

void setCaptureRate(double fps);
//Set video frame capture rate.

void setLocation(float latitude, float longitude);
//Set and store the geodata (latitude and longitude); in the output file.

void setMaxDuration(int max_duration_ms);
//Sets the maximum duration (in ms); of the recording session.

void setMaxFileSize(long max_filesize_bytes);
//Sets the maximum filesize (in bytes); of the recording session.

void setOnErrorListener(MediaRecorder.OnErrorListener l);
//Register a callback to be invoked when an error occurs while recording.

void setOnInfoListener(MediaRecorder.OnInfoListener listener);
//Register a callback to be invoked when an informational event occurs while recording.

void setOrientationHint(int degrees);
//Sets the orientation hint for output video playback.

void setOutputFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd);
//Pass in the file descriptor of the file to be written.

void setOutputFile(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) String path);
//Sets the path of the output file to be produced.

void setOutputFormat(int output_format);
//Sets the format of the output file produced during recording.

void setPreviewDisplay(Surface sv);
//Sets a Surface to show a preview of recorded media (video);.

void setProfile(CamcorderProfile profile);
//Uses the settings from a CamcorderProfile object for recording.

void setVideoEncoder(int video_encoder);
//Sets the video encoder to be used for recording.

void setVideoEncodingBitRate(int bitRate);
//Sets the video encoding bit rate for recording.

void setVideoFrameRate(int rate);
//Sets the frame rate of the video to be captured.

void setVideoSize(int width, int height);
//Sets the width and height of the video to be captured.

void setVideoSource(int video_source);
//Sets the video source to be used for recording.

void start() @Source({RECORD_AUDIO, CAMERA});
//Begins capturing and encoding data to the file specified with setOutputFile();.

void stop() @Source({RECORD_AUDIO, CAMERA});
//Stops recording.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.



}

class ThumbnailUtils {
    
static Bitmap createVideoThumbnail(String filePath, int kind);
//Create a video thumbnail for a video.

static Bitmap extractThumbnail(Bitmap source, int width, int height, int options);
//Creates a centered bitmap of the desired size.

static Bitmap extractThumbnail(Bitmap source, int width, int height);
//Creates a centered bitmap of the desired size.



}

package android.net;

class ConnectivityManager {

@Source(ACCESS_NETWORK_STATE) NetworkInfo getActiveNetworkInfo();
//Returns details about the currently active data network.

NetworkInfo[] getAllNetworkInfo();

boolean getBackgroundDataSetting();
//This method was deprecated in API level 14. As of ICE_CREAM_SANDWICH, availability of background data depends on several combined factors, and this method will always return true. Instead, when background data is unavailable, getActiveNetworkInfo(); will now appear disconnected.

NetworkInfo getNetworkInfo(int networkType);

int getNetworkPreference();

boolean isActiveNetworkMetered();
//Returns if the currently active data network is metered.

static boolean isNetworkTypeValid(int networkType);

boolean requestRouteToHost(@Sink(CHANGE_NETWORK_STATE) int networkType, @Sink(CHANGE_NETWORK_STATE) int hostAddress);
//Ensure that a network route exists to deliver traffic to the specified host via the specified network interface.

void setNetworkPreference(int preference);

int startUsingNetworkFeature(@Sink(CHANGE_NETWORK_STATE) int networkType, @Sink(CHANGE_NETWORK_STATE) String feature);
//Tells the underlying networking system that the caller wants to begin using the named feature.

int stopUsingNetworkFeature(@Sink(CHANGE_NETWORK_STATE) int networkType, @Sink(CHANGE_NETWORK_STATE) String feature);
//Tells the underlying networking system that the caller is finished using the named feature.

}

class NetworkInfo {


NetworkInfo.DetailedState getDetailedState();
//Reports the current fine-grained state of the network.

String getExtraInfo();
//Report the extra information about the network state, if any was provided by the lower networking layers., if one is available.

String getReason();
//Report the reason an attempt to establish connectivity failed, if one is available.

NetworkInfo.State getState();
//Reports the current coarse-grained state of the network.

int getSubtype();
//Return a network-type-specific integer describing the subtype of the network.

String getSubtypeName();
//Return a human-readable name describing the subtype of the network.

int getType();
//Reports the type of network to which the info in this NetworkInfo pertains.

String getTypeName();
//Return a human-readable name describe the type of the network, for example "WIFI" or "MOBILE".

boolean isAvailable();
//Indicates whether network connectivity is possible.

boolean isConnected();
//Indicates whether network connectivity exists and it is possible to establish connections and pass data.

boolean isConnectedOrConnecting();
//Indicates whether network connectivity exists or is in the process of being established.

boolean isFailover();
//Indicates whether the current attempt to connect to the network resulted from the ConnectivityManager trying to fail over to this network following a disconnect from another network.

boolean isRoaming();
//Indicates whether the device is currently roaming on this network.

String toString();
//Returns a string containing a concise, human-readable description of this object.

}

class NetworkInfo$State {
    
static NetworkInfo.State valueOf(String name);

final static State[] values();


}

class TrafficStats {
    
static void clearThreadStatsTag();

static long getMobileRxBytes();
//Get the total number of bytes received through the mobile interface.

static long getMobileRxPackets();
//Get the total number of packets received through the mobile interface.

static long getMobileTxBytes();
//Get the total number of bytes transmitted through the mobile interface.

static long getMobileTxPackets();
//Get the total number of packets transmitted through the mobile interface.

static int getThreadStatsTag();
//Get the active tag used when accounting Socket traffic originating from the current thread.

static long getTotalRxBytes();
//Get the total number of bytes received through all network interfaces.

static long getTotalRxPackets();
//Get the total number of packets received through all network interfaces.

static long getTotalTxBytes();
//Get the total number of bytes sent through all network interfaces.

static long getTotalTxPackets();
//Get the total number of packets sent through all network interfaces.

static long getUidRxBytes(int uid);
//Get the number of bytes received through the network for this UID.

static long getUidRxPackets(int uid);
//Get the number of packets (TCP segments + UDP); received through the network for this UID.

static long getUidTcpRxBytes(int uid);
//Get the number of TCP payload bytes received for this UID.

static long getUidTcpRxSegments(int uid);
//Get the number of TCP segments received for this UID.

static long getUidTcpTxBytes(int uid);
//Get the number of TCP payload bytes sent for this UID.

static long getUidTcpTxSegments(int uid);
//Get the number of TCP segments sent for this UID.

static long getUidTxBytes(int uid);
//Get the number of bytes sent through the network for this UID.

static long getUidTxPackets(int uid);
//Get the number of packets (TCP segments + UDP); sent through the network for this UID.

static long getUidUdpRxBytes(int uid);
//Get the number of UDP payload bytes received for this UID.

static long getUidUdpRxPackets(int uid);
//Get the number of UDP packets received for this UID.

static long getUidUdpTxBytes(int uid);
//Get the number of UDP payload bytes sent for this UID.

static long getUidUdpTxPackets(int uid);
//Get the number of UDP packets sent for this UID.

static void incrementOperationCount(int tag, int operationCount);
//Increment count of network operations performed under the given accounting tag.

static void incrementOperationCount(int operationCount);
//Increment count of network operations performed under the accounting tag currently active on the calling thread.

static void setThreadStatsTag(int tag);
//Set active tag to use when accounting Socket traffic originating from the current thread.

static void tagSocket(Socket socket);
//Tag the given Socket with any statistics parameters active for the current thread.

static void untagSocket(Socket socket);
//Remove any statistics parameters from the given Socket.

}

class Uri {
    
    
abstract Uri.Builder buildUpon();
//Constructs a new builder, copying the attributes from this Uri.

int compareTo(Uri other);
//Compares the string representation of this Uri with that of another.

static String decode(String s);
//Decodes '%'-escaped octets in the given string using the UTF-8 scheme.

static String encode(String s, String allow);
//Encodes characters in the given string as '%'-escaped octets using the UTF-8 scheme.

static String encode(String s);
//Encodes characters in the given string as '%'-escaped octets using the UTF-8 scheme.

boolean equals(Object o);
//Compares this Uri to another object for equality.

static Uri fromFile(@Source({FILESYSTEM, WRITE_EXTERNAL_STORAGE}) File file);
//Creates a Uri from a file.

static Uri fromParts(String scheme, String ssp, String fragment);
//Creates an opaque Uri from the given components.

abstract String getAuthority();
//Gets the decoded authority part of this URI.

boolean getBooleanQueryParameter(String key, boolean defaultValue);
//Searches the query string for the first value with the given key and interprets it as a boolean value.

abstract String getEncodedAuthority();
//Gets the encoded authority part of this URI.

abstract String getEncodedFragment();
//Gets the encoded fragment part of this URI, everything after the '#'.

abstract String getEncodedPath();
//Gets the encoded path.

abstract String getEncodedQuery();
//Gets the encoded query component from this URI.

abstract String getEncodedSchemeSpecificPart();
//Gets the scheme-specific part of this URI, i.e.

abstract String getEncodedUserInfo();
//Gets the encoded user information from the authority.

abstract String getFragment();
//Gets the decoded fragment part of this URI, everything after the '#'.

abstract String getHost();
//Gets the encoded host from the authority for this URI.

abstract String getLastPathSegment();
//Gets the decoded last segment in the path.

abstract String getPath();
//Gets the decoded path.

abstract List<String> getPathSegments();
//Gets the decoded path segments.

abstract int getPort();
//Gets the port from the authority for this URI.

abstract String getQuery();
//Gets the decoded query component from this URI.

String getQueryParameter(String key);
//Searches the query string for the first value with the given key.

Set<String> getQueryParameterNames();
//Returns a set of the unique names of all query parameters.

List<String> getQueryParameters(String key);
//Searches the query string for parameter values with the given key.

abstract String getScheme();
//Gets the scheme of this URI.

abstract String getSchemeSpecificPart();
//Gets the scheme-specific part of this URI, i.e.

abstract String getUserInfo();
//Gets the decoded user information from the authority.

int hashCode();
//Hashes the encoded string represention of this Uri consistently with equals(Object);.

boolean isAbsolute();
//Returns true if this URI is absolute, i.e.

abstract boolean isHierarchical();
//Returns true if this URI is hierarchical like "http://google.com".

boolean isOpaque();
//Returns true if this URI is opaque like "mailto:nobody@google.com".

abstract boolean isRelative();
//Returns true if this URI is relative, i.e.

Uri normalizeScheme();
//Return an equivalent URI with a lowercase scheme component.

static Uri parse(String uriString);
//Creates a Uri which parses the given encoded URI string.

abstract String toString();
//Returns the encoded string representation of this URI.

static Uri withAppendedPath(Uri baseUri, String pathSegment);
//Creates a new Uri by appending an already-encoded path segment to a base Uri.

static void writeToParcel(Parcel out, Uri uri);
//Writes a Uri to a Parcel.

}

package android.net.rtp;

class AudioStream {
//CSH: using this class requires INTERNET permission
    
AudioCodec getCodec() @Source(INTERNET);
//Returns the AudioCodec, or null if it is not set.

int getDtmfType() @Source(INTERNET);
//Returns the RTP payload type for dual-tone multi-frequency (DTMF); digits, or -1 if it is not enabled.

AudioGroup getGroup() @Source(INTERNET);
//Returns the joined AudioGroup.

final boolean isBusy() @Source(INTERNET);
//Returns true if the stream has already joined an AudioGroup.

void join(AudioGroup group) @Source(INTERNET);
//Joins an AudioGroup.

void setCodec(AudioCodec codec) @Source(INTERNET);
//Sets the AudioCodec.

void setDtmfType(int type) @Source(INTERNET);
//Sets the RTP payload type for dual-tone multi-frequency (DTMF); digits.



}

package android.net.sip;

class SipAudioCall {
    //CSH:  Note: Using this class require the INTERNET and USE_SIP permissions. In addition, startAudio() requires the RECORD_AUDIO, ACCESS_WIFI_STATE, and WAKE_LOCK permissions; and setSpeakerMode() requires the MODIFY_AUDIO_SETTINGS permission.
    
    SipAudioCall(Context arg0, SipProfile arg1);
    void setListener(Listener arg0);
    void setListener(Listener arg0, boolean arg1);
    @Source(USE_SIP) boolean isInCall();
    @Source(USE_SIP) boolean isOnHold();
    void close();
    @Source(USE_SIP) SipProfile getLocalProfile();
    @Source(USE_SIP) SipProfile getPeerProfile();
    @Source(USE_SIP) int getState();
    void attachCall(SipSession arg0, String arg1) throws SipException;
    void makeCall(SipProfile arg0, SipSession arg1, int arg2) throws SipException;
    void endCall() throws SipException;
    void holdCall(int arg0) throws SipException;
    void answerCall(int arg0) throws SipException;
    void continueCall(int arg0) throws SipException;
    void toggleMute();
    @Source(USE_SIP) boolean isMuted();
    void setSpeakerMode(@Sink(MODIFY_AUDIO_SETTINGS) boolean arg0);
    void sendDtmf(@SINK({USE_SIP, INTERNET}) int arg0);
    void sendDtmf(@SINK({USE_SIP, INTERNET}) int arg0, @SINK({USE_SIP, INTERNET}) Message arg1);
    void startAudio() @Source({RECORD_AUDIO, ACCESS_WIFI_STATE, WAKE_LOCK, USE_SIP, INTERNET});
}
class SipAudioCall$Listener {
    Listener();
    void onReadyToCall(@Source(USE_SIP) SipAudioCall arg0);
    void onCalling(@Source(USE_SIP) SipAudioCall arg0);
    void onRinging(@Source(USE_SIP) SipAudioCall arg0, SipProfile arg1);
    void onRingingBack(@Source(USE_SIP) SipAudioCall arg0);
    void onCallEstablished(@Source(USE_SIP) SipAudioCall arg0);
    void onCallEnded(@Source(USE_SIP) SipAudioCall arg0);
    void onCallBusy(@Source(USE_SIP) SipAudioCall arg0);
    void onCallHeld(@Source(USE_SIP) SipAudioCall arg0);
    void onError(@Source(USE_SIP) SipAudioCall arg0, int arg1, String arg2);
    void onChanged(@Source(USE_SIP) SipAudioCall arg0);
}

class SipErrorCode {
    final int NO_ERROR;
    final int SOCKET_ERROR;
    final int SERVER_ERROR;
    final int TRANSACTION_TERMINTED;
    final int CLIENT_ERROR;
    final int TIME_OUT;
    final int INVALID_REMOTE_URI;
    final int PEER_NOT_REACHABLE;
    final int INVALID_CREDENTIALS;
    final int IN_PROGRESS;
    final int DATA_CONNECTION_LOST;
    final int CROSS_DOMAIN_AUTHENTICATION;
    final int SERVER_UNREACHABLE;
    static String toString(int arg0);
}

class SipException extends Exception {
    SipException();
    SipException(String arg0);
    SipException(String arg0, Throwable arg1);
}

class SipManager {
    //CSH:  Your application must also request the INTERNET and USE_SIP permissions.
    final int INCOMING_CALL_RESULT_CODE;
    final String EXTRA_CALL_ID;
    final String EXTRA_OFFER_SD;
    static SipManager newInstance(Context arg0);
    static boolean isApiSupported(Context arg0);
    static boolean isVoipSupported(Context arg0);
    static boolean isSipWifiOnly(Context arg0);
    void open(SipProfile arg0) throws SipException;
    void open(SipProfile arg0, PendingIntent arg1, SipRegistrationListener arg2) throws SipException;
    void setRegistrationListener(String arg0, SipRegistrationListener arg1) throws SipException;
    void close(String arg0) throws SipException;
    boolean isOpened(String arg0) throws SipException;
    boolean isRegistered(String arg0) throws SipException;
    @Source(USE_SIP) SipAudioCall makeAudioCall(@Sink({USE_SIP, INTERNET}) SipProfile arg0, @Sink({USE_SIP, INTERNET}) SipProfile arg1, @Sink({USE_SIP, INTERNET}) Listener arg2, @Sink({USE_SIP, INTERNET}) int arg3) throws SipException;
    @Source(USE_SIP) SipAudioCall makeAudioCall(@Sink({USE_SIP, INTERNET}) String arg0, @Sink({USE_SIP, INTERNET}) String arg1, @Sink({USE_SIP, INTERNET}) Listener arg2, @Sink({USE_SIP, INTERNET}) int arg3) throws SipException;
    @Source(USE_SIP) SipAudioCall takeAudioCall(@Sink({USE_SIP, INTERNET}) Intent arg0, @Sink({USE_SIP, INTERNET}) Listener arg1) throws SipException;
    static boolean isIncomingCallIntent(Intent arg0);
    static @Source(USE_SIP) String getCallId(Intent arg0);
    static String getOfferSessionDescription(Intent arg0);
    void register(SipProfile arg0, int arg1, SipRegistrationListener arg2) throws SipException;
    void unregister(SipProfile arg0, SipRegistrationListener arg1) throws SipException;
    @Source(USE_SIP) SipSession getSessionFor(Intent arg0) throws SipException;
    @Source(USE_SIP) SipSession createSipSession(SipProfile arg0, Listener arg1) throws SipException;
}

class SipProfile implements Parcelable, Serializable, Cloneable {
    final Creator<SipProfile> CREATOR;
    void writeToParcel(Parcel arg0, int arg1);
    int describeContents();
    String getUriString();
    String getDisplayName();
    String getUserName();
    String getAuthUserName();
    String getPassword();
    String getSipDomain();
    int getPort();
    String getProtocol();
    String getProxyAddress();
    String getProfileName();
    boolean getSendKeepAlive();
    boolean getAutoRegistration();
}
class SipProfile$Builder {
    Builder(SipProfile arg0);
    Builder(String arg0) throws ParseException;
    Builder(String arg0, String arg1) throws ParseException;
    Builder setAuthUserName(String arg0);
    Builder setProfileName(String arg0);
    Builder setPassword(String arg0);
    Builder setPort(int arg0) throws IllegalArgumentException;
    Builder setProtocol(String arg0) throws IllegalArgumentException;
    Builder setOutboundProxy(String arg0);
    Builder setDisplayName(String arg0);
    Builder setSendKeepAlive(boolean arg0);
    Builder setAutoRegistration(boolean arg0);
    SipProfile build();
}

interface SipRegistrationListener {
    void onRegistering(String arg0);
    void onRegistrationDone(String arg0, long arg1);
    void onRegistrationFailed(String arg0, int arg1, String arg2);
}

class SipSession {
    String getLocalIp();
    SipProfile getLocalProfile();
    SipProfile getPeerProfile();
    int getState();
    boolean isInCall();
    String getCallId();
    void setListener(Listener arg0);
    void register(int arg0);
    void unregister();
    void makeCall(SipProfile arg0, String arg1, int arg2);
    void answerCall(String arg0, int arg1);
    void endCall();
    void changeCall(String arg0, int arg1);
}
class SipSession$Listener {
    Listener();
    void onCalling(@Source(USE_SIP) SipSession arg0);
    void onRinging(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) SipProfile arg1, @Source(USE_SIP) String arg2);
    void onRingingBack(@Source(USE_SIP) SipSession arg0);
    void onCallEstablished(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) String arg1);
    void onCallEnded(@Source(USE_SIP) SipSession arg0);
    void onCallBusy(@Source(USE_SIP) SipSession arg0);
    void onError(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) int arg1, @Source(USE_SIP) String arg2);
    void onCallChangeFailed(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) int arg1, @Source(USE_SIP) String arg2);
    void onRegistering(@Source(USE_SIP) SipSession arg0);
    void onRegistrationDone(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) int arg1);
    void onRegistrationFailed(@Source(USE_SIP) SipSession arg0, @Source(USE_SIP) int arg1, @Source(USE_SIP) String arg2);
    void onRegistrationTimeout(@Source(USE_SIP) SipSession arg0);
}
class SipSession$State {
    static String toString(int arg0);
}
package android.nfc;


class Tag{
             @Source(NFC) String @Source(NFC) [] getTechList() @Source(NFC) ;
}
class NfcAdapter {
    
void disableForegroundDispatch(@Sink(NFC) Activity activity);
//Disable foreground dispatch to the given activity.

void disableForegroundNdefPush(@Sink(NFC) Activity activity);
//This method was deprecated in API level 14. use setNdefPushMessage(NdefMessage, Activity, Activity...); instead

void enableForegroundDispatch(@Sink(NFC) Activity activity, @Sink(NFC) PendingIntent intent, @Sink(NFC) IntentFilter[] filters, @Sink(NFC) String[][] techLists);
//Enable foreground dispatch to the given Activity.

void enableForegroundNdefPush(@Sink(NFC) Activity activity, @Sink(NFC) NdefMessage message);
//This method was deprecated in API level 14. use setNdefPushMessage(NdefMessage, Activity, Activity...); instead

static NfcAdapter getDefaultAdapter(Context context);
//Helper to get the default NFC Adapter.

boolean isEnabled();
//Return true if this NFC Adapter has any features enabled.

boolean isNdefPushEnabled();
//Return true if the NDEF Push (Android Beam); feature is enabled.

void setBeamPushUris(@Sink(NFC) Uri[] uris, @Sink(NFC) Activity activity);
//Set one or more Uris to send using Android Beam (TM);.

void setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback callback, @Sink(NFC) Activity activity);
//Set a callback that will dynamically generate one or more Uris to send using Android Beam (TM);.

void setNdefPushMessage(@Sink(NFC) NdefMessage message, @Sink(NFC) Activity activity, @Sink(NFC) Activity... activities);
//Set a static NdefMessage to send using Android Beam (TM);.

void setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback callback, @Sink(NFC) Activity activity, @Sink(NFC) Activity... activities);
//Set a callback that dynamically generates NDEF messages to send using Android Beam (TM);.

void setOnNdefPushCompleteCallback(NfcAdapter.OnNdefPushCompleteCallback callback, @Sink(NFC) Activity activity, @Sink(NFC) Activity... activities);
//Set a callback on successful Android Beam (TM);.




}


class NdefMessage {
    
int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object obj);
//Returns true if the specified NDEF Message contains identical NDEF Records.

int getByteArrayLength();
//Return the length of this NDEF Message if it is written to a byte array with toByteArray();.

NdefRecord[] getRecords();
//Get the NDEF Records inside this NDEF Message.

int hashCode();
//Returns an integer hash code for this object.

byte[] toByteArray();
//Return this NDEF Message as raw bytes.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.




}

class NdefRecord {
    
    
static NdefRecord createApplicationRecord(String packageName);
//Create a new Android Application Record (AAR);.

static NdefRecord createExternal(String domain, String type, byte[] data);
//Create a new NDEF Record containing external (application-specific); data.

static NdefRecord createMime(String mimeType, byte[] mimeData);
//Create a new NDEF Record containing MIME data.

static NdefRecord createUri(String uriString);
//Create a new NDEF Record containing a URI.

static NdefRecord createUri(Uri uri);
//Create a new NDEF Record containing a URI.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object obj);
//Returns true if the specified NDEF Record contains identical tnf, type, id and payload fields.

byte[] getId();
//Returns the variable length ID.

byte[] getPayload();
//Returns the variable length payload.

short getTnf();
//Returns the 3-bit TNF.

byte[] getType();
//Returns the variable length Type field.

int hashCode();
//Returns an integer hash code for this object.

byte[] toByteArray();
//This method was deprecated in API level 16. use toByteArray(); instead

String toMimeType();
//Map this record to a MIME type, or return null if it cannot be mapped.

String toString();
//Returns a string containing a concise, human-readable description of this object.

Uri toUri();
//Map this record to a URI, or return null if it cannot be mapped.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.




}

package android.nfc.tech;


class BasicTagTechnology{
            void connect() throws IOException;
}


class MifareClassic{
            boolean authenticateSectorWithKeyA(int sectorIndex, byte[] key) throws IOException;
            static @Source(NFC) MifareClassic get(@Source({NFC, LITERAL}) Tag tag);
            @Source(NFC) byte @Source(NFC) [] readBlock(int blockIndex) throws IOException;
            int getSectorCount();
            int getBlockCountInSector(int sectorIndex);
}

class Ndef {
    
    
boolean canMakeReadOnly();
//Indicates whether a tag can be made read-only with makeReadOnly();.

void close() @Source(NFC);
//Disable I/O operations to the tag from this TagTechnology object, and release resources.

void connect() @Source(NFC);
//Enable I/O operations to the tag from this TagTechnology object.

static Ndef get(Tag tag);
//Get an instance of Ndef for the given tag.

NdefMessage getCachedNdefMessage();
//Get the NdefMessage that was read from the tag at discovery time.

int getMaxSize();
//Get the maximum NDEF message size in bytes.

@Source(NFC) NdefMessage getNdefMessage();
//Read the current NdefMessage on this tag.

Tag getTag();
//Get the Tag object backing this TagTechnology object.

String getType();
//Get the NDEF tag type.

boolean isConnected();
//Helper to indicate if I/O operations should be possible.

@Source(NFC) boolean isWritable();
//Determine if the tag is writable.

@Source(NFC) boolean makeReadOnly();
//Make a tag read-only.

void writeNdefMessage(@Sink(NFC) NdefMessage msg);
//Overwrite the NdefMessage on this tag.




}


package android.opengl;

class GLU {
    
static String gluErrorString(int error);
//Return an error string from a GL or GLU error code.

static void gluLookAt(GL10 gl, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ);
//Define a viewing transformation in terms of an eye point, a center of view, and an up vector.

static void gluOrtho2D(GL10 gl, float left, float right, float bottom, float top);
//Set up a 2D orthographic projection matrix

static void gluPerspective(GL10 gl, float fovy, float aspect, float zNear, float zFar);
//Set up a perspective projection matrix

static int gluProject(float objX, float objY, float objZ, float[] model, int modelOffset, float[] project, int projectOffset, int[] view, int viewOffset, float[] win, int winOffset);
//Map object coordinates into window coordinates.

static int gluUnProject(float winX, float winY, float winZ, float[] model, int modelOffset, float[] project, int projectOffset, int[] view, int viewOffset, float[] obj, int objOffset);
//Map window coordinates to object coordinates.


}
package android.os;

class AsyncTask {

AsyncTask();
//Init    
    
final boolean cancel(boolean mayInterruptIfRunning);
//Attempts to cancel execution of this task.

static void execute(@PolySource @PolySink Runnable runnable);
//Convenience version of execute(Object); for use with a simple Runnable object.

final AsyncTask<Params, Progress, Result> execute(@PolySource @PolySink Params... params);
//Executes the task with the specified parameters.

final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params);
//Executes the task with the specified parameters.

final Result get(long timeout, TimeUnit unit);
//Waits if necessary for at most the given time for the computation to complete, and then retrieves its result.

final Result get();
//Waits if necessary for the computation to complete, and then retrieves its result.

final AsyncTask.Status getStatus();
//Returns the current status of this task.

final boolean isCancelled();
//Returns true if this task was cancelled before it completed normally.

//Protected Methods
abstract Result doInBackground(Params... params);
//Override this method to perform a computation on a background thread.

void onCancelled(Result result);
//Runs on the UI thread after cancel(boolean); is invoked and doInBackground(Object[]); has finished.

void onCancelled();
//Applications should preferably override onCancelled(Object);.

void onPostExecute(Result result);
//Runs on the UI thread after doInBackground(Params...);.

void onPreExecute();
//Runs on the UI thread before doInBackground(Params...);.

void onProgressUpdate(Progress... values);
//Runs on the UI thread after publishProgress(Progress...); is invoked.

final void publishProgress(Progress... values);
//This method can be invoked from doInBackground(Params...); to publish updates on the UI thread while the background computation is still running.

    
}

class Environment {
    
static @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getDataDirectory();
//Gets the Android data directory.

static @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getDownloadCacheDirectory();
//Gets the Android download/cache content directory.

static @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getExternalStorageDirectory();
//Gets the Android external storage directory.

static @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getExternalStoragePublicDirectory(String type);
//Get a top-level public external storage directory for placing files of a particular type.

static String getExternalStorageState();
//Gets the current state of the primary "external" storage device.

static @Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File getRootDirectory();
//Gets the Android root directory.

static boolean isExternalStorageEmulated();
//Returns whether the device has an external storage device which is emulated.

static boolean isExternalStorageRemovable();
//Returns whether the primary "external" storage device is removable.



}

class IInterface{
    IBinder asBinder();
}

class IBinder {
    //Added by Carl Hartung
    abstract boolean transact(int code, Parcel data, Parcel reply, int flags);
    //Perform a generic operation with the object.
    
    abstract IInterface queryLocalInterface(String descriptor);
    //Attempt to retrieve a local implementation of an interface for this Binder object.
    
    abstract String getInterfaceDescriptor();
    //Get the canonical name of the interface supported by this binder.
     
    //UNUSED and UNANNOTATED 
    // abstract void dump(FileDescriptor fd, String[] args);
    // abstract void dumpAsync(FileDescriptor fd, String[] args);
    // abstract boolean isBinderAlive();
    // abstract void linkToDeath(IBinder.DeathRecipient recipient, int flags);
    // abstract boolean pingBinder();
    // abstract boolean unlinkToDeath(IBinder.DeathRecipient recipient, int flags);
    }
class Binder {

Binder();    
//Creates a new Binder

void attachInterface(IInterface owner, String descriptor);
//Convenience method for associating a specific interface with the Binder.

final static long clearCallingIdentity();
//Reset the identity of the incoming IPC on the current thread.

void dump(FileDescriptor fd, String[] args);
//Implemented to call the more convenient version dump(FileDescriptor, PrintWriter, String[]);.

void dumpAsync(FileDescriptor fd, String[] args);
//Like dump(FileDescriptor, String[]);, but ensures the target executes asynchronously.

final static void flushPendingCommands();
//Flush any Binder commands pending in the current thread to the kernel driver.

final static int getCallingPid();
//Return the ID of the process that sent you the current transaction that is being processed.

final static int getCallingUid();
//Return the Linux uid assigned to the process that sent you the current transaction that is being processed.

final static UserHandle getCallingUserHandle();
//Return the UserHandle assigned to the process that sent you the current transaction that is being processed.

String getInterfaceDescriptor();
//Default implementation returns an empty interface name.

boolean isBinderAlive();
//Check to see if the process that the binder is in is still alive. Note that if you're calling on a local binder, this always returns true because your process is alive if you're calling it.

final static void joinThreadPool();
//Add the calling thread to the IPC thread pool.

void linkToDeath(IBinder.DeathRecipient recipient, int flags);
//Local implementation is a no-op.

boolean pingBinder();
//Default implementation always returns true -- if you got here, the object is alive.

IInterface queryLocalInterface(String descriptor);
//Use information supplied to attachInterface(); to return the associated IInterface if it matches the requested descriptor.

final static void restoreCallingIdentity(long token);
//Restore the identity of the incoming IPC on the current thread back to a previously identity that was returned by clearCallingIdentity();.

final boolean transact(int code, Parcel data, Parcel reply, int flags);
//Default implementation rewinds the parcels and calls onTransact.

boolean unlinkToDeath(IBinder.DeathRecipient recipient, int flags);
//Local implementation is a no-op.

//Protected Methods
void dump(@Sink({FILESYSTEM, WRITE_EXTERNAL_STORAGE, INTERNET})FileDescriptor fd, @PolyFlowReceiver PrintWriter fout, String[] args);
//Print the object's state into the given stream.

void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

boolean onTransact(int code, Parcel data, Parcel reply, int flags);
//Default implementation is a stub that returns false.




}
    
class Bundle {
  void clear();
//Removes all elements from the mapping of this Bundle.

Object clone();
//Clones the current Bundle.

boolean containsKey(String key);
//Returns true if the given key is contained in the mapping of this Bundle.

int describeContents();
//Report the nature of this Parcelable's contents

Object get(String key);
//Returns the entry with the given key as an object.

boolean getBoolean(String key);
//Returns the value associated with the given key, or false if no mapping of the desired type exists for the given key.

boolean getBoolean(String key, boolean defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

boolean[] getBooleanArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Bundle getBundle(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

byte getByte(String key);
//Returns the value associated with the given key, or (byte); 0 if no mapping of the desired type exists for the given key.

Byte getByte(String key, byte defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

byte[] getByteArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

char getChar(String key);
//Returns the value associated with the given key, or (char); 0 if no mapping of the desired type exists for the given key.

char getChar(String key, char defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

char[] getCharArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

CharSequence getCharSequence(String key, CharSequence defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

CharSequence getCharSequence(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

CharSequence[] getCharSequenceArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<CharSequence> getCharSequenceArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ClassLoader getClassLoader();
//Return the ClassLoader currently associated with this Bundle.

double getDouble(String key);
//Returns the value associated with the given key, or 0.0 if no mapping of the desired type exists for the given key.

double getDouble(String key, double defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

double[] getDoubleArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

float getFloat(String key);
//Returns the value associated with the given key, or 0.0f if no mapping of the desired type exists for the given key.

float getFloat(String key, float defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

float[] getFloatArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

int getInt(String key, int defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

int getInt(String key);
//Returns the value associated with the given key, or 0 if no mapping of the desired type exists for the given key.

int[] getIntArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<Integer> getIntegerArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

long getLong(String key);
//Returns the value associated with the given key, or 0L if no mapping of the desired type exists for the given key.

long getLong(String key, long defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

long[] getLongArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> T getParcelable(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Parcelable[] getParcelableArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> ArrayList<T> getParcelableArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

Serializable getSerializable(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

short getShort(String key);
//Returns the value associated with the given key, or (short); 0 if no mapping of the desired type exists for the given key.

short getShort(String key, short defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

short[] getShortArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

<T extends Parcelable> SparseArray<T> getSparseParcelableArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

String getString(String key, String defaultValue);
//Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key.

String getString(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

String[] getStringArray(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

ArrayList<String> getStringArrayList(String key);
//Returns the value associated with the given key, or null if no mapping of the desired type exists for the given key or a null value is explicitly associated with the key.

boolean hasFileDescriptors();
//Reports whether the bundle contains any parcelled file descriptors.

boolean isEmpty();
//Returns true if the mapping of this Bundle is empty, false otherwise.

Set<String> keySet();
//Returns a Set containing the Strings used as keys in this Bundle.

void putAll(Bundle map);
//Inserts all mappings from the given Bundle into this Bundle.

void putBoolean(String key, boolean value);
//Inserts a Boolean value into the mapping of this Bundle, replacing any existing value for the given key.

void putBooleanArray(String key, boolean[] value);
//Inserts a boolean array value into the mapping of this Bundle, replacing any existing value for the given key.

void putBundle(String key, Bundle value);
//Inserts a Bundle value into the mapping of this Bundle, replacing any existing value for the given key.

void putByte(String key, byte value);
//Inserts a byte value into the mapping of this Bundle, replacing any existing value for the given key.

void putByteArray(String key, byte[] value);
//Inserts a byte array value into the mapping of this Bundle, replacing any existing value for the given key.

void putChar(String key, char value);
//Inserts a char value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharArray(String key, char[] value);
//Inserts a char array value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequence(String key, CharSequence value);
//Inserts a CharSequence value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequenceArray(String key, CharSequence[] value);
//Inserts a CharSequence array value into the mapping of this Bundle, replacing any existing value for the given key.

void putCharSequenceArrayList(String key, ArrayList<CharSequence> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void putDouble(String key, double value);
//Inserts a double value into the mapping of this Bundle, replacing any existing value for the given key.

void putDoubleArray(String key, double[] value);
//Inserts a double array value into the mapping of this Bundle, replacing any existing value for the given key.

void putFloat(String key, float value);
//Inserts a float value into the mapping of this Bundle, replacing any existing value for the given key.

void putFloatArray(String key, float[] value);
//Inserts a float array value into the mapping of this Bundle, replacing any existing value for the given key.

void putInt(String key, int value);
//Inserts an int value into the mapping of this Bundle, replacing any existing value for the given key.

void putIntArray(String key, int[] value);
//Inserts an int array value into the mapping of this Bundle, replacing any existing value for the given key.

void putIntegerArrayList(String key, ArrayList<Integer> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void putLong(String key, long value);
//Inserts a long value into the mapping of this Bundle, replacing any existing value for the given key.

void putLongArray(String key, long[] value);
//Inserts a long array value into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelable(String key, Parcelable value);
//Inserts a Parcelable value into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelableArray(String key, Parcelable[] value);
//Inserts an array of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putParcelableArrayList(String key, ArrayList<? extends Parcelable> value);
//Inserts a List of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putSerializable(String key, Serializable value);
//Inserts a Serializable value into the mapping of this Bundle, replacing any existing value for the given key.

void putShort(String key, short value);
//Inserts a short value into the mapping of this Bundle, replacing any existing value for the given key.

void putShortArray(String key, short[] value);
//Inserts a short array value into the mapping of this Bundle, replacing any existing value for the given key.

void putSparseParcelableArray(String key, SparseArray<? extends Parcelable> value);
//Inserts a SparceArray of Parcelable values into the mapping of this Bundle, replacing any existing value for the given key.

void putString(String key, String value);
//Inserts a String value into the mapping of this Bundle, replacing any existing value for the given key.

void putStringArray(String key, String[] value);
//Inserts a String array value into the mapping of this Bundle, replacing any existing value for the given key.

void putStringArrayList(String key, ArrayList<String> value);
//Inserts an ArrayList value into the mapping of this Bundle, replacing any existing value for the given key.

void readFromParcel(Parcel parcel);
//Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.

void remove(String key);
//Removes any entry with the given key from the mapping of this Bundle.

void setClassLoader(ClassLoader loader);
//Changes the ClassLoader this Bundle uses when instantiating objects.

int size();
//Returns the number of mappings contained in this Bundle.

synchronized String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel parcel, int flags);
//Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
}

class Message {
    
void copyFrom(Message o);
//Make this message like o.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

Runnable getCallback();
//Retrieve callback object that will execute when this message is handled.

Bundle getData();
//Obtains a Bundle of arbitrary data associated with this event, lazily creating it if necessary.

Handler getTarget();
//Retrieve the a Handler implementation that will receive this message.

long getWhen();
//Return the targeted delivery time of this message, in milliseconds.

static Message obtain(Handler h, int what, int arg1, int arg2, Object obj);
//Same as obtain();, but sets the values of the target, what, arg1, arg2, and obj members.

static Message obtain(Handler h, int what, Object obj);
//Same as obtain();, but sets the values of the target, what, and obj members.

static Message obtain(Handler h, int what);
//Same as obtain();, but sets the values for both target and what members on the Message.

static Message obtain(Handler h);
//Same as obtain();, but sets the value for the target member on the Message returned.

static Message obtain(Handler h, Runnable callback);
//Same as obtain(Handler);, but assigns a callback Runnable on the Message that is returned.

static Message obtain();
//Return a new Message instance from the global pool.

static Message obtain(Handler h, int what, int arg1, int arg2);
//Same as obtain();, but sets the values of the target, what, arg1, and arg2 members.

static Message obtain(Message orig);
//Same as obtain();, but copies the values of an existing message (including its target); into the new one.

Bundle peekData();
//Like getData();, but does not lazily create the Bundle.

void recycle();
//Return a Message instance to the global pool.

void sendToTarget();
//Sends this Message to the Handler specified by getTarget();.

void setData(Bundle data);
//Sets a Bundle of arbitrary data values.

void setTarget(Handler target);

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Flatten this object in to a Parcel.

}
class Looper {
    
    
void dump(Printer pw, String prefix);

static Looper getMainLooper();
//Returns the application's main looper, which lives in the main thread of the application.

Thread getThread();
//Return the Thread associated with this Looper.

static void loop();
//Run the message queue in this thread.

static Looper myLooper();
//Return the Looper object associated with the current thread.

static MessageQueue myQueue();
//Return the MessageQueue object associated with the current thread.

static void prepare();
//Initialize the current thread as a looper.

static void prepareMainLooper();
//Initialize the current thread as a looper, marking it as an application's main looper.

void quit();
//Quits the looper.

void setMessageLogging(Printer printer);
//Control logging of messages as they are processed by this Looper.

String toString();
//Returns a string containing a concise, human-readable description of this object.




}


class FileObserver{
            FileObserver(String path, int mask);
            void onEvent(int arg0, String arg1);
            void startWatching();
}

class Handler {
 
Handler();
//Creates a new Handler
   
void dispatchMessage(Message msg);
//Handle system messages here.

final void dump(Printer pw, String prefix);
//final Looper getLooper();
//String getMessageName(Message message);
//Returns a string representing the name of the specified message.

void handleMessage(Message msg);
//Subclasses must implement this to receive messages.

final boolean hasMessages(int what, Object object);
//Check if there are any pending posts of messages with code 'what' and whose obj is 'object' in the message queue.

final boolean hasMessages(int what);
//Check if there are any pending posts of messages with code 'what' in the message queue.

final Message obtainMessage(int what, int arg1, int arg2);
//Same as obtainMessage();, except that it also sets the what, arg1 and arg2 members of the returned Message.

final Message obtainMessage();
//Returns a new Message from the global message pool.

final Message obtainMessage(int what, int arg1, int arg2, Object obj);
//Same as obtainMessage();, except that it also sets the what, obj, arg1,and arg2 values on the returned Message.

final Message obtainMessage(int what);
//Same as obtainMessage();, except that it also sets the what member of the returned Message.

final Message obtainMessage(int what, Object obj);
//Same as obtainMessage();, except that it also sets the what and obj members of the returned Message.

final boolean post(Runnable r);
//Causes the Runnable r to be added to the message queue.

final boolean postAtFrontOfQueue(Runnable r);
//Posts a message to an object that implements Runnable.

final boolean postAtTime(Runnable r, Object token, long uptimeMillis);
//Causes the Runnable r to be added to the message queue, to be run at a specific time given by uptimeMillis.

final boolean postAtTime(Runnable r, long uptimeMillis);
//Causes the Runnable r to be added to the message queue, to be run at a specific time given by uptimeMillis.

final boolean postDelayed(Runnable r, long delayMillis);
//Causes the Runnable r to be added to the message queue, to be run after the specified amount of time elapses.

final void removeCallbacks(Runnable r);
//Remove any pending posts of Runnable r that are in the message queue.

final void removeCallbacks(Runnable r, Object token);
//Remove any pending posts of Runnable r with Object token that are in the message queue.

final void removeCallbacksAndMessages(Object token);
//Remove any pending posts of callbacks and sent messages whose obj is token.

final void removeMessages(int what);
//Remove any pending posts of messages with code 'what' that are in the message queue.

final void removeMessages(int what, Object object);
//Remove any pending posts of messages with code 'what' and whose obj is 'object' that are in the message queue.

final boolean sendEmptyMessage(int what);
//Sends a Message containing only the what value.

final boolean sendEmptyMessageAtTime(int what, long uptimeMillis);
//Sends a Message containing only the what value, to be delivered at a specific time.

final boolean sendEmptyMessageDelayed(int what, long delayMillis);
//Sends a Message containing only the what value, to be delivered after the specified amount of time elapses.

final boolean sendMessage(Message msg);
//Pushes a message onto the end of the message queue after all pending messages before the current time.

final boolean sendMessageAtFrontOfQueue(Message msg);
//Enqueue a message at the front of the message queue, to be processed on the next iteration of the message loop.

boolean sendMessageAtTime(Message msg, long uptimeMillis);
//Enqueue a message into the message queue after all pending messages before the absolute time (in milliseconds); uptimeMillis.

final boolean sendMessageDelayed(Message msg, long delayMillis);
//Enqueue a message into the message queue after all pending messages before (current time + delayMillis);.

String toString();
//Returns a string containing a concise, human-readable description of this object.

}


class Messenger{
            Messenger(Handler target);
            IBinder getBinder();
}
class Message{
    Bundle getData();
    void sendToTarget();
}



class Parcel {
    
final void appendFrom(Parcel parcel, int offset, int length);

final IBinder[] createBinderArray();

final ArrayList<IBinder> createBinderArrayList();
//Read and return a new ArrayList containing IBinder objects from the parcel that was written with writeBinderList(List); at the current dataPosition();.

final boolean[] createBooleanArray();

final byte[] createByteArray();
//Read and return a byte[] object from the parcel.

final char[] createCharArray();

final double[] createDoubleArray();

final float[] createFloatArray();

final int[] createIntArray();

final long[] createLongArray();

final String[] createStringArray();

final ArrayList<String> createStringArrayList();
//Read and return a new ArrayList containing String objects from the parcel that was written with writeStringList(List); at the current dataPosition();.

final <T> T[] createTypedArray(Creator<T> c);
//Read and return a new array containing a particular object type from the parcel at the current dataPosition();.

final <T> ArrayList<T> createTypedArrayList(Creator<T> c);
//Read and return a new ArrayList containing a particular object type from the parcel that was written with writeTypedList(List); at the current dataPosition();.

final int dataAvail();
//Returns the amount of data remaining to be read from the parcel.

final int dataCapacity();
//Returns the total amount of space in the parcel.

final int dataPosition();
//Returns the current position in the parcel data.

final int dataSize();
//Returns the total amount of data contained in the parcel.

final void enforceInterface(String interfaceName);

final boolean hasFileDescriptors();
//Report whether the parcel contains any marshalled file descriptors.

final byte[] marshall();
//Returns the raw bytes of the parcel.

static Parcel obtain();
//Retrieve a new Parcel object from the pool.

final Object[] readArray(ClassLoader loader);
//Read and return a new Object array from the parcel at the current dataPosition();.

final ArrayList readArrayList(ClassLoader loader);
//Read and return a new ArrayList object from the parcel at the current dataPosition();.

final void readBinderArray(IBinder[] val);

final void readBinderList(List<IBinder> list);
//Read into the given List items IBinder objects that were written with writeBinderList(List); at the current dataPosition();.

final void readBooleanArray(boolean[] val);

final Bundle readBundle(ClassLoader loader);
//Read and return a new Bundle object from the parcel at the current dataPosition();, using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects.

final Bundle readBundle();
//Read and return a new Bundle object from the parcel at the current dataPosition();.

final byte readByte();
//Read a byte value from the parcel at the current dataPosition();.

final void readByteArray(byte[] val);
//Read a byte[] object from the parcel and copy it into the given byte array.

final void readCharArray(char[] val);

final double readDouble();
//Read a double precision floating point value from the parcel at the current dataPosition();.

final void readDoubleArray(double[] val);

final void readException(int code, String msg);
//Use this function for customized exception handling.

final void readException();
//Special function for reading an exception result from the header of a parcel, to be used after receiving the result of a transaction.

final ParcelFileDescriptor readFileDescriptor();
//Read a FileDescriptor from the parcel at the current dataPosition();.

final float readFloat();
//Read a floating point value from the parcel at the current dataPosition();.

final void readFloatArray(float[] val);

final HashMap readHashMap(ClassLoader loader);
//Please use readBundle(ClassLoader); instead (whose data must have been written with writeBundle(Bundle);.

final int readInt();
//Read an integer value from the parcel at the current dataPosition();.

final void readIntArray(int[] val);

final void readList(List outVal, ClassLoader loader);
//Read into an existing List object from the parcel at the current dataPosition();, using the given class loader to load any enclosed Parcelables.

final long readLong();
//Read a long integer value from the parcel at the current dataPosition();.

final void readLongArray(long[] val);
//final void readMap(Map outVal, ClassLoader loader);
//Please use readBundle(ClassLoader); instead (whose data must have been written with writeBundle(Bundle);.

final <T extends Parcelable> T readParcelable(ClassLoader loader);
//Read and return a new Parcelable from the parcel.

final Parcelable[] readParcelableArray(ClassLoader loader);
//Read and return a new Parcelable array from the parcel.

final Serializable readSerializable();
//Read and return a new Serializable object from the parcel.

final SparseArray readSparseArray(ClassLoader loader);
//Read and return a new SparseArray object from the parcel at the current dataPosition();.

final SparseBooleanArray readSparseBooleanArray();
//Read and return a new SparseBooleanArray object from the parcel at the current dataPosition();.

final String readString();
//Read a string value from the parcel at the current dataPosition();.

final void readStringArray(String[] val);

final void readStringList(List<String> list);
//Read into the given List items String objects that were written with writeStringList(List); at the current dataPosition();.

final IBinder readStrongBinder();
//Read an object from the parcel at the current dataPosition();.

final <T> void readTypedArray(T[] val, Creator<T> c);

final <T> void readTypedList(List<T> list, Creator<T> c);
//Read into the given List items containing a particular object type that were written with writeTypedList(List); at the current dataPosition();.

final Object readValue(ClassLoader loader);
//Read a typed object from a parcel.

final void recycle();
//Put a Parcel object back into the pool.

final void setDataCapacity(int size);
//Change the capacity (current available space); of the parcel.

final void setDataPosition(int pos);
//Move the current read/write position in the parcel.

final void setDataSize(int size);
//Change the amount of data in the parcel.

final void unmarshall(byte[] data, int offest, int length);
//Set the bytes in data to be the raw bytes of this Parcel.

final void writeArray(Object[] val);
//Flatten an Object array into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeBinderArray(IBinder[] val);

final void writeBinderList(List<IBinder> val);
//Flatten a List containing IBinder objects into the parcel, at the current dataPosition(); and growing dataCapacity(); if needed.

final void writeBooleanArray(boolean[] val);

final void writeBundle(Bundle val);
//Flatten a Bundle into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeByte(byte val);
//Write a byte value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeByteArray(byte[] b, int offset, int len);
//Write a byte array into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeByteArray(byte[] b);
//Write a byte array into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeCharArray(char[] val);

final void writeDouble(double val);
//Write a double precision floating point value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeDoubleArray(double[] val);

final void writeException(Exception e);
//Special function for writing an exception result at the header of a parcel, to be used when returning an exception from a transaction.

final void writeFileDescriptor(FileDescriptor val);
//Write a FileDescriptor into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeFloat(float val);
//Write a floating point value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeFloatArray(float[] val);

final void writeInt(int val);
//Write an integer value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeIntArray(int[] val);

final void writeInterfaceToken(String interfaceName);
//Store or read an IBinder interface token in the parcel at the current dataPosition();.

final void writeList(List val);
//Flatten a List into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeLong(long val);
//Write a long integer value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeLongArray(long[] val);

final void writeMap(Map val);
//Please use writeBundle(Bundle); instead.

final void writeNoException();
//Special function for writing information at the front of the Parcel indicating that no exception occurred.

final void writeParcelable(Parcelable p, int parcelableFlags);
//Flatten the name of the class of the Parcelable and its contents into the parcel.

final <T extends Parcelable> void writeParcelableArray(T[] value, int parcelableFlags);
//Write a heterogeneous array of Parcelable objects into the Parcel.

final void writeSerializable(Serializable s);
//Write a generic serializable object in to a Parcel.

final void writeSparseArray(SparseArray<Object> val);
//Flatten a generic SparseArray into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeSparseBooleanArray(SparseBooleanArray val);

final void writeString(String val);
//Write a string value into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeStringArray(String[] val);

final void writeStringList(List<String> val);
//Flatten a List containing String objects into the parcel, at the current dataPosition(); and growing dataCapacity(); if needed.

final void writeStrongBinder(IBinder val);
//Write an object into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final void writeStrongInterface(IInterface val);
//Write an object into the parcel at the current dataPosition();, growing dataCapacity(); if needed.

final <T extends Parcelable> void writeTypedArray(T[] val, int parcelableFlags);
//Flatten a heterogeneous array containing a particular object type into the parcel, at the current dataPosition(); and growing dataCapacity(); if needed.

final <T extends Parcelable> void writeTypedList(List<T> val);
//Flatten a List containing a particular object type into the parcel, at the current dataPosition(); and growing dataCapacity(); if needed.

final void writeValue(Object v);
//Flatten a generic object in to a parcel.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

final static Parcel obtain(int obj);
//    
    
    
    
}

class Parcelable{
            void writeToParcel(Parcel arg0, int arg1);
            int describeContents();
}
class Parcelable$Creator {
    
    
abstract T createFromParcel(Parcel source);
//Create a new instance of the Parcelable class, instantiating it from the given Parcel whose data had previously been written by Parcelable.writeToParcel();.

abstract T[] newArray(int size);
//Create a new array of the Parcelable class.


}
class Parcelable$ClassLoaderCreator{
            T createFromParcel(Parcel arg0, ClassLoader arg1);
}

class ParcelFileDescriptor {
    
    
static ParcelFileDescriptor adoptFd(int fd);
//Take ownership of a raw native fd in to a new ParcelFileDescriptor.

void close();
//Close the ParcelFileDescriptor.

static ParcelFileDescriptor[] createPipe();
//Create two ParcelFileDescriptors structured as a data pipe.

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

int detachFd();
//Return the native fd int for this ParcelFileDescriptor and detach it from the object here.

ParcelFileDescriptor dup();
//Create a new ParcelFileDescriptor that is a dup of the existing FileDescriptor.

static ParcelFileDescriptor dup(FileDescriptor orig);
//Create a new ParcelFileDescriptor that is a dup of an existing FileDescriptor.

static ParcelFileDescriptor fromDatagramSocket(DatagramSocket datagramSocket);
//Create a new ParcelFileDescriptor from the specified DatagramSocket.

static ParcelFileDescriptor fromFd(int fd);
//Create a new ParcelFileDescriptor from a raw native fd.

static ParcelFileDescriptor fromSocket(Socket socket);
//Create a new ParcelFileDescriptor from the specified Socket.

int getFd();
//Return the native fd int for this ParcelFileDescriptor.

FileDescriptor getFileDescriptor();
//Retrieve the actual FileDescriptor associated with this object.

long getStatSize();
//Return the total size of the file representing this fd, as determined by stat();.

static ParcelFileDescriptor open(File file, int mode);
//Create a new ParcelFileDescriptor accessing a given file.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel. If PARCELABLE_WRITE_RETURN_VALUE is set in flags, the file descriptor will be closed after a copy is written to the Parcel.

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.




}

class PowerManager{
        @Source(FlowPermission.WAKE_LOCK) WakeLock newWakeLock(int flags, String tag);
}

class PowerManager$WakeLock{
        void acquire();
        void release();
}

class Process {
    
    
final static long getElapsedCpuTime();
//Returns elapsed milliseconds of the time this process has run.

final static int getGidForName(String name);
//Returns the GID assigned to a particular user name, or -1 if there is none.

final static int getThreadPriority(int tid);
//Return the current priority of a thread, based on Linux priorities.

final static int getUidForName(String name);
//Returns the UID assigned to a particular user name, or -1 if there is none.

final static void killProcess(int pid);
//Kill the process with the given PID.

final static int myPid();
//Returns the identifier of this process, which can be used with killProcess(int); and sendSignal(int, int);.

final static int myTid();
//Returns the identifier of the calling thread, which be used with setThreadPriority(int, int);.

final static int myUid();
//Returns the identifier of this process's uid.

final static UserHandle myUserHandle();
//Returns this process's user handle.

final static void sendSignal(int pid, int signal);
//Send a signal to the given process.

final static void setThreadPriority(int tid, int priority);
//Set the priority of a thread, based on Linux priorities.

final static void setThreadPriority(int priority);
//Set the priority of the calling thread, based on Linux priorities.

final static boolean supportsProcesses();
//This method was deprecated in API level 14. This method always returns true. Do not use.



}

class SystemClock {
static @Source(READ_TIME) long currentThreadTimeMillis();
//Returns milliseconds running in the current thread.

static @Source(READ_TIME) long elapsedRealtime();
//Returns milliseconds since boot, including time spent in sleep.

static @Source(READ_TIME) long elapsedRealtimeNanos();
//Returns nanoseconds since boot, including time spent in sleep.

static boolean setCurrentTimeMillis(@Sink(WRITE_TIME) long millis);
//Sets the current wall time, in milliseconds.

static void sleep(long ms);
//Waits a given number of milliseconds (of uptimeMillis); before returning.

static @Source(READ_TIME) long uptimeMillis();
//Returns milliseconds since boot, not counting time spent in deep sleep.


}

class Vibrator{
        void vibrate(@Sink(VIBRATE) long arg0);
}
package android.preference;

class DialogPreference{
void setDialogTitle(CharSequence dialogTitle);
//Sets the title of the dialog. This will be shown on subsequent dialogs.

protected void onDialogClosed(boolean positiveResult);
//Called when the dialog is dismissed and should be used to save data to the SharedPreferences

protected void showDialog(Bundle state);
//Shows the dialog associated with this Preference.
}

class EditTextPreference {

EditTextPreference(Context context);
//New EditTextPreference

EditTextPreference(Context context, AttributeSet attrs);
//New EditTextPreference

EditTextPreference(Context context, AttributeSet attrs, int defStyle);
//New EditTextPreference

EditText getEditText();
//Returns the EditText widget that will be shown in the dialog.

@Source(SHARED_PREFERENCES) String getText();
//Gets the text from the SharedPreferences.

void setText(@Sink(SHARED_PREFERENCES) String text);
//Saves the text to the SharedPreferences.

boolean shouldDisableDependents();
//Checks whether this preference's dependents should currently be disabled.

//Protected Methods
void onAddEditTextToDialogView(View dialogView, EditText editText);
//Adds the EditText widget of this preference to the dialog's view.

void onBindDialogView(View view);
//Binds views in the content View of the dialog to data.

void onDialogClosed(boolean positiveResult);
//Called when the dialog is dismissed and should be used to save data to the SharedPreferences.

@Source(SHARED_PREFERENCES) Object onGetDefaultValue(TypedArray a, int index);
//Called when a Preference is being inflated and the default value attribute needs to be read.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a Preference to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state.

void onSetInitialValue(@Sink(SHARED_PREFERENCES) boolean restoreValue, @Sink(SHARED_PREFERENCES) Object defaultValue);
//Implement this to set the initial value of the Preference.



}

class Preference {
    
    
@Source(SHARED_PREFERENCES) int compareTo(@Sink(SHARED_PREFERENCES) Preference another);
//Compares Preference objects based on order (if set);, otherwise alphabetically on the titles.

Context getContext();
//Returns the Context of this Preference.

@Source(SHARED_PREFERENCES) String getDependency();
//Returns the key of the dependency on this Preference.

@Source(SHARED_PREFERENCES) SharedPreferences.Editor getEditor();
//Returns an SharedPreferences.Editor where this Preference can save its value(s);.

Bundle getExtras();
//Return the extras Bundle object associated with this preference, creating a new Bundle if there currently isn't one.

String getFragment();
//Return the fragment class name associated with this Preference.

Drawable getIcon();
//Returns the icon of this Preference.

Intent getIntent();
//Return the Intent associated with this Preference.

@Source(SHARED_PREFERENCES) String getKey();
//Gets the key for this Preference, which is also the key used for storing values into SharedPreferences.

int getLayoutResource();
//Gets the layout resource that will be shown as the View for this Preference.

Preference.OnPreferenceChangeListener getOnPreferenceChangeListener();
//Returns the callback to be invoked when this Preference is changed by the user (but before the internal state has been updated);.

Preference.OnPreferenceClickListener getOnPreferenceClickListener();
//Returns the callback to be invoked when this Preference is clicked.

@Source(SHARED_PREFERENCES) int getOrder();
//Gets the order of this Preference with respect to other Preference objects on the same level.

@Source(SHARED_PREFERENCES) PreferenceManager getPreferenceManager();
//Gets the PreferenceManager that manages this Preference object's tree.

@Source(SHARED_PREFERENCES) SharedPreferences getSharedPreferences();
//Returns the SharedPreferences where this Preference can read its value(s);.

boolean getShouldDisableView();
//Checks whether this Preference should disable its view when it's action is disabled.

@Source(SHARED_PREFERENCES) CharSequence getSummary();
//Returns the summary of this Preference.

@Source(SHARED_PREFERENCES) CharSequence getTitle();
//Returns the title of this Preference.

int getTitleRes();
//Returns the title resource ID of this Preference.

View getView(View convertView, ViewGroup parent);
//Gets the View that will be shown in the PreferenceActivity.

int getWidgetLayoutResource();
//Gets the layout resource for the controllable widget portion of this Preference.

@Source(SHARED_PREFERENCES) boolean hasKey();
//Checks whether this Preference has a valid key.

boolean isEnabled();
//Checks whether this Preference should be enabled in the list.

@Source(SHARED_PREFERENCES) boolean isPersistent();
//Checks whether this Preference is persistent.

boolean isSelectable();
//Checks whether this Preference should be selectable in the list.

void notifyDependencyChange(boolean disableDependents);
//Notifies any listening dependents of a change that affects the dependency.

void onDependencyChanged(Preference dependency, boolean disableDependent);
//Called when the dependency changes.

Bundle peekExtras();
//Return the extras Bundle object associated with this preference, returning null if there is not currently one.

void restoreHierarchyState(Bundle container);
//Restore this Preference hierarchy's previously saved state from the given container.

void saveHierarchyState(Bundle container);
//Store this Preference hierarchy's frozen state into the given container.

void setDefaultValue(Object defaultValue);
//Sets the default value for this Preference, which will be set either if persistence is off or persistence is on and the preference is not found in the persistent storage.

void setDependency(@Sink(SHARED_PREFERENCES) String dependencyKey);
//Sets the key of a Preference that this Preference will depend on.

void setEnabled(boolean enabled);
//Sets whether this Preference is enabled.

void setFragment(String fragment);
//Sets the class name of a fragment to be shown when this Preference is clicked.

void setIcon(@Sink(DISPLAY) Drawable icon);
//Sets the icon for this Preference with a Drawable.

void setIcon(int iconResId);
//Sets the icon for this Preference with a resource ID.

void setIntent(Intent intent);
//Sets an Intent to be used for startActivity(Intent); when this Preference is clicked.

void setKey(@Sink(SHARED_PREFERENCES) String key);
//Sets the key for this Preference, which is used as a key to the SharedPreferences.

void setLayoutResource(int layoutResId);
//Sets the layout resource that is inflated as the View to be shown for this Preference.

void setOnPreferenceChangeListener(Preference.OnPreferenceChangeListener onPreferenceChangeListener);
//Sets the callback to be invoked when this Preference is changed by the user (but before the internal state has been updated);.

void setOnPreferenceClickListener(Preference.OnPreferenceClickListener onPreferenceClickListener);
//Sets the callback to be invoked when this Preference is clicked.

void setOrder(int order);
//Sets the order of this Preference with respect to other Preference objects on the same level.

void setPersistent(boolean persistent);
//Sets whether this Preference is persistent.

void setSelectable(boolean selectable);
//Sets whether this Preference is selectable.

void setShouldDisableView(boolean shouldDisableView);
//Sets whether this Preference should disable its view when it gets disabled.

void setSummary(int summaryResId);
//Sets the summary for this Preference with a resource ID.

void setSummary(@Sink(SHARED_PREFERENCES) CharSequence summary);
//Sets the summary for this Preference with a CharSequence.

void setTitle(int titleResId);
//Sets the title for this Preference with a resource ID.

void setTitle(@Sink(SHARED_PREFERENCES) CharSequence title);
//Sets the title for this Preference with a CharSequence.

void setWidgetLayoutResource(int widgetLayoutResId);
//Sets The layout for the controllable widget portion of this Preference.

boolean shouldCommit();
//Returns whether the Preference should commit its saved value(s); in getEditor();.

boolean shouldDisableDependents();
//Checks whether this preference's dependents should currently be disabled.

String toString();
//Returns a string containing a concise, human-readable description of this object.

//Protected Methods
boolean callChangeListener(Object newValue);
//Call this method after the user changes the preference, but before the internal state is set.

Preference findPreferenceInHierarchy(String key);
//Finds a Preference in this hierarchy (the whole thing, even above/below your PreferenceScreen screen break); with the given key.

boolean getPersistedBoolean(boolean defaultReturnValue);
//Attempts to get a persisted boolean from the SharedPreferences.

float getPersistedFloat(float defaultReturnValue);
//Attempts to get a persisted float from the SharedPreferences.

int getPersistedInt(int defaultReturnValue);
//Attempts to get a persisted int from the SharedPreferences.

long getPersistedLong(long defaultReturnValue);
//Attempts to get a persisted long from the SharedPreferences.

String getPersistedString(String defaultReturnValue);
//Attempts to get a persisted String from the SharedPreferences.

void notifyChanged();
//Should be called when the data of this Preference has changed.

void notifyHierarchyChanged();
//Should be called when a Preference has been added/removed from this group, or the ordering should be re-evaluated.

void onAttachedToActivity();
//Called when the Preference hierarchy has been attached to the PreferenceActivity.

void onAttachedToHierarchy(PreferenceManager preferenceManager);
//Called when this Preference has been attached to a Preference hierarchy.

void onBindView(View view);
//Binds the created View to the data for this Preference.

void onClick();
//Processes a click on the preference.

View onCreateView(ViewGroup parent);
//Creates the View to be shown for this Preference in the PreferenceActivity.

Object onGetDefaultValue(TypedArray a, int index);
//Called when a Preference is being inflated and the default value attribute needs to be read.

void onPrepareForRemoval();
//Called when this Preference is being removed from the hierarchy.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a Preference to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state.

void onSetInitialValue(@Sink(SHARED_PREFERENCES) boolean restorePersistedValue, @Sink(SHARED_PREFERENCES) Object defaultValue);
//Implement this to set the initial value of the Preference.

boolean persistBoolean(@Sink(SHARED_PREFERENCES) boolean value);
//Attempts to persist a boolean to the SharedPreferences.

boolean persistFloat(@Sink(SHARED_PREFERENCES) float value);
//Attempts to persist a float to the SharedPreferences.

boolean persistInt(@Sink(SHARED_PREFERENCES) int value);
//Attempts to persist an int to the SharedPreferences.

boolean persistLong(@Sink(SHARED_PREFERENCES) long value);
//Attempts to persist a long to the SharedPreferences.

boolean persistString(@Sink(SHARED_PREFERENCES) String value);
//Attempts to persist a String to the SharedPreferences.

boolean shouldPersist();
//Checks whether, at the given time this method is called, this Preference should store/restore its value(s); into the SharedPreferences.



}
class Preference$OnPreferenceChangeListener{
        boolean onPreferenceChange(Preference arg0, Object arg1);
}
class PreferenceActivity {
    
PreferenceActivity();
//New PreferenceActivity

void addPreferencesFromIntent(Intent intent);
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

void addPreferencesFromResource(int preferencesResId);
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

Preference findPreference(CharSequence key);
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

void finishPreferencePanel(Fragment caller, int resultCode, Intent resultData);
//Called by a preference panel fragment to finish itself.

PreferenceManager getPreferenceManager();
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

PreferenceScreen getPreferenceScreen();
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

boolean hasHeaders();
//Returns true if this activity is currently showing the header list.

void invalidateHeaders();
//Call when you need to change the headers being displayed.

boolean isMultiPane();
//Returns true if this activity is showing multiple panes -- the headers and a preference fragment.

void loadHeadersFromResource(int resid, List<PreferenceActivity.Header> target);
//Parse the given XML file as a header description, adding each parsed Header into the target list.

void onBuildHeaders(List<PreferenceActivity.Header> target);
//Called when the activity needs its list of headers build.

Intent onBuildStartFragmentIntent(String fragmentName, Bundle args, int titleRes, int shortTitleRes);
//Called by startWithFragment(String, Bundle, Fragment, int, int, int); when in single-pane mode, to build an Intent to launch a new activity showing the selected fragment.

void onContentChanged();
//Updates the screen state (current list and other views); when the content changes.

PreferenceActivity.Header onGetInitialHeader();
//Called to determine the initial header to be shown.

PreferenceActivity.Header onGetNewHeader();
//Called after the header list has been updated (onBuildHeaders(List); has been called and returned due to invalidateHeaders();); to specify the header that should now be selected.

void onHeaderClick(PreferenceActivity.Header header, int position);
//Called when the user selects an item in the header list.

boolean onIsHidingHeaders();
//Called to determine whether the header list should be hidden.

boolean onIsMultiPane();
//Called to determine if the activity should run in multi-pane mode.

boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref);
//Called when the user has clicked on a Preference that has a fragment class name associated with it.

boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference);
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

void setListFooter(@Sink(DISPLAY) View view);
//Set a footer that should be shown at the bottom of the header list.

void setParentTitle(@Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence shortTitle, View.OnClickListener listener);
//Should be called after onCreate to ensure that the breadcrumbs, if any, were created.

void setPreferenceScreen(@Sink(DISPLAY) PreferenceScreen preferenceScreen);
//This method was deprecated in API level 11. This function is not relevant for a modern fragment-based PreferenceActivity.

void showBreadCrumbs(@Sink(DISPLAY) CharSequence title, @Sink(DISPLAY) CharSequence shortTitle);
//Change the base title of the bread crumbs for the current preferences.

void startPreferenceFragment(@Sink(DISPLAY) Fragment fragment, boolean push);
//Start a new fragment.

void startPreferencePanel(String fragmentClass, Bundle args, int titleRes, @Sink(DISPLAY) CharSequence titleText, @Sink(DISPLAY) Fragment resultTo, int resultRequestCode);
//Start a new fragment containing a preference panel.

void startWithFragment(String fragmentName, Bundle args, @Sink(DISPLAY) Fragment resultTo, int resultRequestCode);
//Like startWithFragment(String, Bundle, Fragment, int, int, int); but uses a 0 titleRes.

void startWithFragment(String fragmentName, Bundle args, @Sink(DISPLAY) Fragment resultTo, int resultRequestCode, int titleRes, int shortTitleRes);
//Start a new instance of this activity, showing only the given preference fragment.

void switchToHeader(@Sink(DISPLAY) PreferenceActivity.Header header);
//When in two-pane mode, switch to the fragment pane to show the given preference fragment.

void switchToHeader(String fragmentName, Bundle args);
//When in two-pane mode, switch the fragment pane to show the given preference fragment.

//Protected Methods
void onActivityResult(int requestCode, int resultCode, Intent data);
//Called when an activity you launched exits, giving you the requestCode you started it with, the resultCode it returned, and any additional data from it.

void onCreate(Bundle savedInstanceState);
//Called when the activity is starting.

void onDestroy();
//Perform any final cleanup before an activity is destroyed.

void onListItemClick(ListView l, View v, int position, long id);
//This method will be called when an item in the list is selected.

void onNewIntent(Intent intent);
//This is called for activities that set launchMode to "singleTop" in their package, or if a client used the FLAG_ACTIVITY_SINGLE_TOP flag when calling startActivity(Intent);.

void onRestoreInstanceState(Bundle state);
//Ensures the list view has been created before Activity restores all of the view states.

void onSaveInstanceState(Bundle outState);
//Called to retrieve per-instance state from an activity before being killed so that the state can be restored in onCreate(Bundle); or onRestoreInstanceState(Bundle); (the Bundle populated by this method will be passed to both);.

void onStop();
//Called when you are no longer visible to the user.



}
class PreferenceManager{
@PolyFlow
static SharedPreferences getDefaultSharedPreferences(Context context);
//Gets a SharedPreferences instance that points to the default file that is used by the preference framework in the given context.

static void setDefaultValues(Context context, int resId, boolean readAgain);
//Similar to setDefaultValues(Context, int, boolean) but allows the client to provide the filename and mode of the shared preferences file.
}


class PreferenceFragment {
    
void addPreferencesFromIntent(Intent intent);
//Adds preferences from activities that match the given Intent.

void addPreferencesFromResource(int preferencesResId);
//Inflates the given XML resource and adds the preference hierarchy to the current preference hierarchy.

@Source(SHARED_PREFERENCES) Preference findPreference(CharSequence key);
//Finds a Preference based on its key.

@Source(SHARED_PREFERENCES) PreferenceManager getPreferenceManager();
//Returns the PreferenceManager used by this fragment.

@Source(SHARED_PREFERENCES) PreferenceScreen getPreferenceScreen();
//Gets the root of the preference hierarchy that this fragment is showing.

void onActivityCreated(Bundle savedInstanceState);
//Called when the fragment's activity has been created and this fragment's view hierarchy instantiated.

void onActivityResult(int requestCode, int resultCode, Intent data);
//Receive the result from a previous call to startActivityForResult(Intent, int);.

void onCreate(Bundle savedInstanceState);
//Called to do initial creation of a fragment.

View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);
//Called to have the fragment instantiate its user interface view.

void onDestroy();
//Called when the fragment is no longer in use.

void onDestroyView();
//Called when the view previously created by onCreateView(LayoutInflater, ViewGroup, Bundle); has been detached from the fragment.

boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference);

void onSaveInstanceState(Bundle outState);
//Called to ask the fragment to save its current dynamic state, so it can later be reconstructed in a new instance of its process is restarted.

void onStart();
//Called when the Fragment is visible to the user.

void onStop();
//Called when the Fragment is no longer started.

void setPreferenceScreen(@Sink(DISPLAY) PreferenceScreen preferenceScreen);
//Sets the root of the preference hierarchy that this fragment is showing.



}

class Preference$OnPreferenceClickListener{
            boolean onPreferenceClick(Preference arg0);
}
package android.provider;


class ContactsContract$CommonDataKinds$Phone {
    
final static CharSequence getTypeLabel(Resources res, int type, CharSequence label);
//Return a CharSequence that best describes the given type, possibly substituting the given LABEL value for TYPE_CUSTOM.

final static int getTypeLabelResource(int type);
//Return the string resource that best describes the given TYPE.



}
class ContactsContract$CommonDataKinds$Email {
    
final static CharSequence getTypeLabel(Resources res, int type, CharSequence label);
//Return a CharSequence that best describes the given type, possibly substituting the given LABEL value for TYPE_CUSTOM.

final static int getTypeLabelResource(int type);
//Return the string resource that best describes the given TYPE.



}

class ContactsContract$Contacts {
    
static Uri getLookupUri(ContentResolver resolver, Uri contactUri);
//Builds a CONTENT_LOOKUP_URI style Uri describing the requested Contacts entry.

static Uri getLookupUri(long contactId, String lookupKey);
//Build a CONTENT_LOOKUP_URI lookup Uri using the given _ID and LOOKUP_KEY.

static Uri lookupContact(ContentResolver resolver, Uri lookupUri);
//Computes a content URI (see CONTENT_URI); given a lookup URI.

static void markAsContacted(ContentResolver resolver, long contactId);
//This method was deprecated in API level 16. The class DataUsageStatUpdater of the Android support library should be used instead.

static InputStream openContactPhotoInputStream(ContentResolver cr, Uri contactUri, boolean preferHighres);
//Opens an InputStream for the contacts's photo and returns the photo as a byte stream.

static InputStream openContactPhotoInputStream(ContentResolver cr, Uri contactUri);
//Opens an InputStream for the contacts's thumbnail photo and returns the photo as a byte stream.



}


class MediaStore$Audio$Playlists$Members{
        static @Source(FlowPermission.MEDIA) Uri getContentUri(String volumeName, long playlistId);
}
package android.speech.tts;

class TextToSpeech {
void shutdown();
//Releases the resources used by the TextToSpeech engine. It is good practice for instance to call this method in the onDestroy() method of an Activity so the TextToSpeech engine can be cleanly stopped.

int setLanguage(Locale loc);
//Sets the text-to-speech language.

TextToSpeech(Context context, OnInitListener listener);
//The constructor for the TextToSpeech class, using the default TTS engine.

boolean isSpeaking();
//Checks whether the TTS engine is busy speaking.

int speak(@Sink(SPEAKER) String text, int queueMode, HashMap<String,String> params);
//Speaks the string using the specified queuing strategy and speech parameters.
}

class TextToSpeech$OnInitListener{
        void onInit(int arg0);
}
package android.support.v4.app;
class FragmentActivity {
//CSH: in spreadsheet, not found in API:
// doReallyStop
// dumpViewHierarchy
// invalidateSupportFragment
// onReallyStop
// viewToString


void dump(String prefix, @Sink({INTERNET, FILESYSTEM, WRITE_EXTERNAL_STORAGE}) FileDescriptor fd, @PolyFlowReceiver PrintWriter writer, String[] args);
//Print the Activity's state into the given stream.

Object getLastCustomNonConfigurationInstance();
//Return the value previously returned from onRetainCustomNonConfigurationInstance();.

FragmentManager getSupportFragmentManager();
//Return the FragmentManager for interacting with fragments associated with this activity.

LoaderManager getSupportLoaderManager();
//Return the LoaderManager for this fragment, creating it if needed.

void onAttachFragment(Fragment fragment);
//Called when a fragment is attached to the activity.

void onBackPressed();
//Take care of popping the fragment back stack or finishing the activity as appropriate.

void onConfigurationChanged(Configuration newConfig);
//Dispatch configuration change to all fragments.

boolean onCreatePanelMenu(int featureId, Menu menu);
//Dispatch to Fragment.onCreateOptionsMenu();.

View onCreateView(String name, Context context, AttributeSet attrs);
//Add support for inflating the <fragment> tag.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Take care of calling onBackPressed(); for pre-Eclair platforms.

void onLowMemory();
//Dispatch onLowMemory(); to all fragments.

boolean onMenuItemSelected(int featureId, MenuItem item);
//Dispatch context and options menu to fragments.

void onPanelClosed(int featureId, Menu menu);
//Call onOptionsMenuClosed(); on fragments.

boolean onPreparePanel(int featureId, View view, Menu menu);
//Dispatch onPrepareOptionsMenu(); to fragments.

Object onRetainCustomNonConfigurationInstance();
//Use this instead of onRetainNonConfigurationInstance();.

final Object onRetainNonConfigurationInstance();
//This method was deprecated in API level . Use the new Fragment API setRetainInstance(boolean); instead; this is also available on older platforms through the Android compatibility package.

void startActivityForResult(Intent intent, int requestCode);
//Modifies the standard behavior to allow results to be delivered to fragments.

void startActivityFromFragment(Fragment fragment, Intent intent, int requestCode);
//Called by Fragment.startActivityForResult(); to implement its behavior.

void supportInvalidateOptionsMenu();
//Invalidate the activity's options menu.


//Protected Methods
void onActivityResult(int requestCode, int resultCode, Intent data);
//Dispatch incoming result to the correct fragment.

void onCreate(Bundle savedInstanceState);
//Perform initialization of all fragments and loaders.

void onDestroy();
//Destroy all fragments and loaders.

void onNewIntent(Intent intent);
//Handle onNewIntent(); to inform the fragment manager that the state is not saved.

void onPause();
//Dispatch onPause(); to fragments.

void onPostResume();
//Dispatch onResume(); to fragments.

void onResume();
//Dispatch onResume(); to fragments.

void onResumeFragments();
//This is the fragment-orientated version of onResume(); that you can override to perform operations in the Activity at the same point where its fragments are resumed.

void onSaveInstanceState(Bundle outState);
//Save all appropriate fragment state.

void onStart();
//Dispatch onStart(); to all fragments.

void onStop();
//Dispatch onStop(); to all fragments.
}

class FragmentTabHost {
    
    
//CSH: in spreadsheet, not found in API:
//doTabChanged
//ensureContent
//initFragmentTabHost

void addTab(@Sink(DISPLAY) TabHost.TabSpec tabSpec, Class<?> clss, Bundle args);

//void onTabChanged(String tabId);

//void setOnTabChangedListener(TabHost.OnTabChangeListener l);
//Register a callback to be invoked when the selected state of any of the items in this list changes

//void setup();
//This method was deprecated in API level . Don't call the original TabHost setup, you must instead call setup(Context, FragmentManager); or setup(Context, FragmentManager, int);.

//void setup(Context context, FragmentManager manager);

//void setup(Context context, FragmentManager manager, int containerId);

//Protected Methods
//void onAttachedToWindow();
//This is called when the view is attached to a window.

//void onDetachedFromWindow();
//This is called when the view is detached from a window.

//void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

//Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

}

class Fragment{
        void setHasOptionsMenu(boolean hasMenu);
        void startActivity(Intent intent);
        void onCreate(Bundle savedInstanceState);
        Fragment();
        boolean onOptionsItemSelected(MenuItem item);
        void onActivityCreated( Bundle savedInstanceState);
        LoaderManager getLoaderManager();
        void setArguments(@Source({INTENT,LITERAL}) Bundle args);
        Bundle getArguments();
        boolean isResumed();
        FragmentActivity getActivity();
}
class NavUtils{
            static void navigateUpFromSameTask(Activity sourceActivity);
}

package android.support.v4.content;
class LocalBroadcastManager{
            static LocalBroadcastManager getInstance(Context context);
            void registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
            boolean sendBroadcast(Intent intent);
}

package android.support.v4.util;

class LongSparseArray {
//CSH: found in spreadsheet, not in API
//binarySearch
//gc

//void append(long key, E value);
//Puts a key/value pair into the array, optimizing for the case where the key is greater than all existing keys in the array.

//void clear();
//Removes all key-value mappings from this LongSparseArray.

LongSparseArray<E> clone();
//Creates and returns a copy of this Object.

void delete(long key);
//Removes the mapping from the specified key, if there was any.

E get(long key, E valueIfKeyNotFound);
//Gets the Object mapped from the specified key, or the specified Object if no such mapping has been made.

E get(long key);
//Gets the Object mapped from the specified key, or null if no such mapping has been made.

static int idealByteArraySize(int need);

static int idealLongArraySize(int need);

//int indexOfKey(long key);
//Returns the index for which keyAt(int); would return the specified key, or a negative number if the specified key is not mapped.

//int indexOfValue(E value);
//Returns an index for which valueAt(int); would return the specified key, or a negative number if no keys map to the specified value.

//long keyAt(int index);
//Given an index in the range 0...size();-1, returns the key from the indexth key-value mapping that this LongSparseArray stores.

void put(long key, E value);
//Adds a mapping from the specified key to the specified value, replacing the previous mapping from the specified key if there was one.

//void remove(long key);
//Alias for delete(long);.

//void removeAt(int index);
//Removes the mapping at the specified index.

//void setValueAt(int index, E value);
//Given an index in the range 0...size();-1, sets a new value for the indexth key-value mapping that this LongSparseArray stores.

//int size();
//Returns the number of key-value mappings that this LongSparseArray currently stores.

//E valueAt(int index);
//Given an index in the range 0...size();-1, returns the value from the indexth key-value mapping that this LongSparseArray stores.

}

class SparseArrayCompat {
// CSH: specified in spreadsheet but not found in class or parents
// binarySearch
// gc
// idealByteArraySize
// idealIntArraySize

void append(int key, E value);
//Puts a key/value pair into the array, optimizing for the case where the key is greater than all existing keys in the array.

void clear();
//Removes all key-value mappings from this SparseArray.

void delete(int key);
//Removes the mapping from the specified key, if there was any.

E get(int key);
//Gets the Object mapped from the specified key, or null if no such mapping has been made.

E get(int key, E valueIfKeyNotFound);
//Gets the Object mapped from the specified key, or the specified Object if no such mapping has been made.

int indexOfKey(int key);
//Returns the index for which keyAt(int); would return the specified key, or a negative number if the specified key is not mapped.

int indexOfValue(E value);
//Returns an index for which valueAt(int); would return the specified key, or a negative number if no keys map to the specified value.

int keyAt(int index);
//Given an index in the range 0...size();-1, returns the key from the indexth key-value mapping that this SparseArray stores.

void put(int key, E value);
//Adds a mapping from the specified key to the specified value, replacing the previous mapping from the specified key if there was one.

void remove(int key);
//Alias for delete(int);.

void removeAt(int index);
//Removes the mapping at the specified index.

void removeAtRange(int index, int size);
//Remove a range of mappings as a batch.

void setValueAt(int index, E value);
//Given an index in the range 0...size();-1, sets a new value for the indexth key-value mapping that this SparseArray stores.

int size();
//Returns the number of key-value mappings that this SparseArray currently stores.

E valueAt(int index);
//Given an index in the range 0...size();-1, returns the value from the indexth key-value mapping that this SparseArray stores.
}

package android.support.v4.view;

class AccessibilityDelegateCompat {
//CSH: Methods in spreadsheet but not in class or parent:
//getBridge

//CSH: It's unclear whether these push anything to the screen, AccessibilityEvent probably holds that answer.
   
boolean dispatchPopulateAccessibilityEvent(View host, AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the host View first and then to its children for adding their text content to the event.

AccessibilityNodeProviderCompat getAccessibilityNodeProvider(View host);
//Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.

void onInitializeAccessibilityEvent(View host, AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about the the host View which is the event source.

void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info);
//Initializes an AccessibilityNodeInfoCompat with information about the host view.

void onPopulateAccessibilityEvent(View host, AccessibilityEvent event);
//Gives a chance to the host View to populate the accessibility event with its text content.

boolean onRequestSendAccessibilityEvent(ViewGroup host, View child, AccessibilityEvent event);
//Called when a child of the host View has requested sending an AccessibilityEvent and gives an opportunity to the parent (the host); to augment the event.

boolean performAccessibilityAction(View host, int action, Bundle args);
//Performs the specified accessibility action on the view.

void sendAccessibilityEvent(View host, int eventType);
//Sends an accessibility event of the given type.

void sendAccessibilityEventUnchecked(View host, AccessibilityEvent event);
//Sends an accessibility event.

}

class MotionEventCompat {
static int findPointerIndex(MotionEvent event, int pointerId);
//Call findPointerIndex(int);.

static int getActionIndex(MotionEvent event);
//Call getAction();, returning only the pointer index portion

//static int getActionMasked(MotionEvent event);
//Call getAction();, returning only the ACTION_MASK portion.

//static int getPointerCount(MotionEvent event);
//The number of pointers of data contained in this event.

static int getPointerId(MotionEvent event, int pointerIndex);
//Call getPointerId(int);.

static float getX(MotionEvent event, int pointerIndex);
//Call getX(int);.

static float getY(MotionEvent event, int pointerIndex);
//Call getY(int);.

}

class PagerAdapter {
void destroyItem(ViewGroup container, int position, Object object);
//Remove a page for the given position.

void destroyItem(View container, int position, Object object);
//This method was deprecated in API level . Use destroyItem(ViewGroup, int, Object);

void finishUpdate(View container);
//This method was deprecated in API level . Use finishUpdate(ViewGroup);

void finishUpdate(ViewGroup container);
//Called when the a change in the shown pages has been completed.

abstract int getCount();
//Return the number of views available.

int getItemPosition(Object object);
//Called when the host view is attempting to determine if an item's position has changed.

CharSequence getPageTitle(int position);
//This method may be called by the ViewPager to obtain a title string to describe the specified page.

float getPageWidth(int position);
//Returns the proportional width of a given page as a percentage of the ViewPager's measured width from (0.f-1.f]

Object instantiateItem(ViewGroup container, int position);
//Create the page for the given position.

Object instantiateItem(View container, int position);
//This method was deprecated in API level . Use instantiateItem(ViewGroup, int);

abstract boolean isViewFromObject(View view, Object object);
//Determines whether a page View is associated with a specific key object as returned by instantiateItem(ViewGroup, int);.

void notifyDataSetChanged();
//This method should be called by the application if the data backing this adapter has changed and associated views should update.

void registerDataSetObserver(DataSetObserver observer);
//Register an observer to receive callbacks related to the adapter's data changing.

void restoreState(Parcelable state, ClassLoader loader);
//Restore any instance state associated with this adapter and its pages that was previously saved by saveState();.

Parcelable saveState();
//Save any instance state associated with this adapter and its pages that should be restored if the current UI state needs to be reconstructed.

void setPrimaryItem(View container, int position, Object object);
//This method was deprecated in API level . Use setPrimaryItem(ViewGroup, int, Object);

void setPrimaryItem(ViewGroup container, int position, Object object);
//Called to inform the adapter of which item is currently considered to be the "primary", that is the one show to the user as the current page.

void startUpdate(View container);
//This method was deprecated in API level . Use startUpdate(ViewGroup);

void startUpdate(ViewGroup container);
//Called when a change in the shown pages is going to start being made.

void unregisterDataSetObserver(DataSetObserver observer);
//Unregister an observer from callbacks related to the adapter's data changing.
}

class PagerTabStrip {

//boolean getDrawFullUnderline();
//Return whether or not this tab strip will draw a full-width underline.

//int getTabIndicatorColor();

//boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

//void setBackgroundColor(int color);
//Sets the background color for this view.

//void setBackgroundDrawable(Drawable d);
//This method was deprecated in API level . use setBackground(Drawable); instead

//void setBackgroundResource(int resId);
//Set the background to a given resource.

//void setDrawFullUnderline(boolean drawFull);
//Set whether this tab strip should draw a full-width underline in the current tab indicator color.

void setPadding(int left, int top, int right, int bottom);
//Sets the padding.

void setTabIndicatorColor(int color);
//Set the color of the tab indicator bar.

//void setTabIndicatorColorResource(int resId);
//Set the color of the tab indicator bar from a color resource.

void setTextSpacing(int textSpacing);
//Set the required spacing between title segments.

//Protected Methods
//void onDraw(Canvas canvas);
//Implement this to do your drawing.

}

class PagerTitleStrip {
//CSH: Methods in spreadsheet not found in class or parents:
// access$100
// setSingleLineAllCaps
// updateAdapter
// updateText
// updateTextPositions


int getTextSpacing();

void requestLayout();
//Call this when something has changed which has invalidated the layout of this view.

void setGravity(int gravity);
//Set the Gravity used to position text within the title strip.

void setNonPrimaryAlpha(float alpha);
//Set the alpha value used for non-primary page titles.

void setTextColor(int color);
//Set the color value used as the base color for all displayed page titles.

void setTextSize(int unit, float size);
//Set the default text size to a given unit and value.

void setTextSpacing(int spacingPixels);
//Set the required spacing between title segments.

//Protected Methods
void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

}

class ViewPager {
// CSH: Methods in spreadsheet not found in ViewPager or parent classes
// populate
// setCurrentItemInternal
// access$300
// access$200
// setScrollState
// infoForChild
// setScrollingCacheEnabled
// infoForPosition
// completeScroll
// scrollToItem
// getChildRectInPagerCoordinates
// addNewItem
// performDrag
// pageScrolled
// determineTargetPage
// smoothScrollTo
// setOnAdapterChangeListener
// setInternalPageChangeListener
// recomputeScrollPosition
// pageRight
// pageLeft
// initViewPager
// infoForCurrentScrollPosition
// infoForAnyChild
// distanceInfluenceForSnapDuration
// dataSetChanged
// calculatePageOffsets
// setChildrenDrawingOrderEnabledCompat
// removeNonDecorViews
// onSecondaryPointerUp
// endDrag
// enableLayers
// access$400
// access$000
//isGutterDrag
 
void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//We only want the current page that is being shown to be focusable.

void addTouchables(ArrayList<View> views);
//We only want the current page that is being shown to be touchable.

void addView(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

boolean arrowScroll(int direction);

boolean beginFakeDrag();
//Start a fake drag of the pager.

void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

void endFakeDrag();
//End a fake drag of the pager.

boolean executeKeyEvent(@Source(USER_INPUT) KeyEvent event);
//You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.

void fakeDragBy(float xOffset);
//Fake drag by an offset in pixels.

ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

PagerAdapter getAdapter();
//Retrieve the current adapter supplying pages.

int getCurrentItem();

int getOffscreenPageLimit();
//Returns the number of pages that will be retained to either side of the current page in the view hierarchy in an idle state.

int getPageMargin();
//Return the margin between pages.

boolean isFakeDragging();
//Returns true if a fake drag is in progress.

boolean onInterceptTouchEvent(MotionEvent ev);
//Implement this method to intercept all touch screen motion events.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

void removeView(View view);
//Note: do not invoke this method from draw(android.graphics.Canvas);, onDraw(android.graphics.Canvas);, dispatchDraw(android.graphics.Canvas); or any related method.

void setAdapter(PagerAdapter adapter);
//Set a PagerAdapter that will supply views for this pager as needed.

void setCurrentItem(int item, boolean smoothScroll);
//Set the currently selected page.

void setCurrentItem(int item);
//Set the currently selected page.

void setOffscreenPageLimit(int limit);
//Set the number of pages that should be retained to either side of the current page in the view hierarchy in an idle state.

void setOnPageChangeListener(ViewPager.OnPageChangeListener listener);
//Set a listener that will be invoked whenever the page changes or is incrementally scrolled.

void setPageMargin(int marginPixels);
//Set the margin between pages.

void setPageMarginDrawable(int resId);
//Set a drawable that will be used to fill the margin between pages.

void setPageMarginDrawable(Drawable d);
//Set a drawable that will be used to fill the margin between pages.

void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer);
//Set a ViewPager.PageTransformer that will be called for each attached page whenever the scroll position is changed.

//Protected Methods
boolean canScroll(View v, boolean checkV, int dx, int x, int y);
//Tests scrollability within child views of v given a delta of dx.

boolean checkLayoutParams(ViewGroup.LayoutParams p);

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

ViewGroup.LayoutParams generateDefaultLayoutParams();
//Returns a set of default layout parameters.

ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

int getChildDrawingOrder(int childCount, int i);
//Returns the index of the child to draw for this iteration.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onPageScrolled(int position, float offset, int offsetPixels);
//This method will be invoked when the current page is scrolled, either as part of a programmatically initiated smooth scroll or a user initiated touch scroll.

boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect);
//We only want the current page that is being shown to be focusable.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.
}

package android.support.v4.view.accessibility;

class AccessibilityNodeInfoCompat {
// CSH: Present in spreadsheet but not in class or parents:
// wrapNonNullInstance
    
void addAction(int action);
//Adds an action that can be performed on the node.

//void addChild(View child);
//Adds a child.

//void addChild(View root, int virtualDescendantId);
//Adds a virtual child which is a descendant of the given root.

//boolean equals(Object obj);
//Compares this instance with the specified object and indicates if they are equal.

//List<AccessibilityNodeInfoCompat> findAccessibilityNodeInfosByText(String text);
//Finds AccessibilityNodeInfos by text.

//AccessibilityNodeInfoCompat findFocus(int focus);
//Find the view that has the specified focus type.

//AccessibilityNodeInfoCompat focusSearch(int direction);
//Searches for the nearest view in the specified direction that can take input focus.

//int getActions();
//Gets the actions that can be performed on the node.

//void getBoundsInParent(Rect outBounds);
//Gets the node bounds in parent coordinates.

//void getBoundsInScreen(Rect outBounds);
//Gets the node bounds in screen coordinates.

//AccessibilityNodeInfoCompat getChild(int index);
//Get the child at given index.

//int getChildCount();
//Gets the number of children.

//CharSequence getClassName();
//Gets the class this node comes from.

//CharSequence getContentDescription();
//Gets the content description of this node.

Object getInfo();

//int getMovementGranularities();
//Gets the movement granularities for traversing the text of this node.

//CharSequence getPackageName();
//Gets the package this node comes from.

//AccessibilityNodeInfoCompat getParent();
//Gets the parent.

//CharSequence getText();
//Gets the text of this node.

//int getWindowId();
//Gets the id of the window from which the info comes from.

//int hashCode();
//Returns an integer hash code for this object.

//boolean isAccessibilityFocused();
//Gets whether this node is accessibility focused.

//boolean isCheckable();
//Gets whether this node is checkable.

//boolean isChecked();
//Gets whether this node is checked.

//boolean isClickable();
//Gets whether this node is clickable.

//boolean isEnabled();
//Gets whether this node is enabled.

//boolean isFocusable();
//Gets whether this node is focusable.

//boolean isFocused();
//Gets whether this node is focused.

//boolean isLongClickable();
//Gets whether this node is long clickable.

//boolean isPassword();
//Gets whether this node is a password.

//boolean isScrollable();
//Gets if the node is scrollable.

//boolean isSelected();
//Gets whether this node is selected.

//boolean isVisibleToUser();
//Sets whether this node is visible to the user.

//static AccessibilityNodeInfoCompat obtain(View root, int virtualDescendantId);
//Returns a cached instance if such is available otherwise a new one and sets the source.

//static AccessibilityNodeInfoCompat obtain(AccessibilityNodeInfoCompat info);
//Returns a cached instance if such is available or a new one is create.

//static AccessibilityNodeInfoCompat obtain();
//Returns a cached instance if such is available otherwise a new one.

//static AccessibilityNodeInfoCompat obtain(View source);
//Returns a cached instance if such is available otherwise a new one and sets the source.

//boolean performAction(int action);
//Performs an action on the node.

//boolean performAction(int action, Bundle arguments);
//Performs an action on the node.

//void recycle();
//Return an instance back to be reused.

//void setAccessibilityFocused(boolean focused);
//Sets whether this node is accessibility focused.

//void setBoundsInParent(Rect bounds);
//Sets the node bounds in parent coordinates.

//void setBoundsInScreen(Rect bounds);
//Sets the node bounds in screen coordinates.

//void setCheckable(boolean checkable);
//Sets whether this node is checkable.

//void setChecked(boolean checked);
//Sets whether this node is checked.

void setClassName(CharSequence className);
//Sets the class this node comes from.

//void setClickable(boolean clickable);
//Sets whether this node is clickable.

//void setContentDescription(CharSequence contentDescription);
//Sets the content description of this node.

//void setEnabled(boolean enabled);
//Sets whether this node is enabled.

//void setFocusable(boolean focusable);
//Sets whether this node is focusable.

//void setFocused(boolean focused);
//Sets whether this node is focused.

//void setLongClickable(boolean longClickable);
//Sets whether this node is long clickable.

//void setMovementGranularities(int granularities);
//Sets the movement granularities for traversing the text of this node.

//void setPackageName(CharSequence packageName);
//Sets the package this node comes from.

//void setParent(View parent);
//Sets the parent.

//void setParent(View root, int virtualDescendantId);
//Sets the parent to be a virtual descendant of the given root.

//void setPassword(boolean password);
//Sets whether this node is a password.

//void setScrollable(boolean scrollable);
//Sets if the node is scrollable.

//void setSelected(boolean selected);
//Sets whether this node is selected.

//void setSource(View root, int virtualDescendantId);
//Sets the source to be a virtual descendant of the given root.

//void setSource(View source);
//Sets the source.

//void setText(CharSequence text);
//Sets the text of this node.

//void setVisibleToUser(boolean visibleToUser);
//Sets whether this node is visible to the user.


    
}

package android.support.v4.widget;
class EdgeEffectCompat {

boolean draw(Canvas canvas);
//Draw into the provided canvas.

void finish();
//Immediately finish the current animation.

boolean isFinished();
//Reports if this EdgeEffectCompat's animation is finished.

//boolean onAbsorb(int velocity);
//Call when the effect absorbs an impact at the given velocity.

boolean onPull(float deltaDistance);
//A view should call this when content is pulled away from an edge by the user.

//boolean onRelease();
//Call when the object is released after being pulled.

void setSize(int width, int height);
//Set the size of this edge effect in pixels.

}


package android.telephony;
class TelephonyManager{
            @Source(READ_PHONE_STATE) String getDeviceId();
            @Source(READ_PHONE_STATE) String getSimSerialNumber();
            @Source(READ_PHONE_STATE) String getNetworkOperatorName();
            @Source(READ_PHONE_STATE) int getPhoneType();
                        @Source(READ_PHONE_STATE) String getLine1Number();

}


class SmsManager {
    
ArrayList<String> divideMessage(String text);
//Divide a message text into several fragments, none bigger than the maximum SMS message size.

static SmsManager getDefault();
//Get the default instance of the SmsManager

void sendDataMessage(@Sink(SEND_SMS) String destinationAddress, @Sink(SEND_SMS) String scAddress, @Sink(SEND_SMS) short destinationPort, @Sink(SEND_SMS) byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent);
//Send a data based SMS to a specific application port.

void sendMultipartTextMessage(@Sink(SEND_SMS) String destinationAddress, @Sink(SEND_SMS) String scAddress, @Sink(SEND_SMS) ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents);
//Send a multi-part text based SMS.

void sendTextMessage(@Sink(SEND_SMS) String destinationAddress, @Sink(SEND_SMS) String scAddress, @Sink(SEND_SMS) String text, PendingIntent sentIntent, PendingIntent deliveryIntent);
//Send a text based SMS.



}


class SmsMessage{
//Add by SOM
        @Source(READ_SMS) String getMessageBody();
        static SmsMessage createFromPdu(@Sink(WRITE_SMS) byte @Sink(WRITE_SMS)[] pdu);
       @Source(READ_EMAIL) String getDisplayOriginatingAddress();
       @Source(READ_EMAIL) String getEmailBody();
        boolean isEmail();
        @Source(READ_EMAIL) String getEmailFrom();
        @Source(READ_SMS) long getTimestampMillis();
         @Source(READ_SMS) String getServiceCenterAddress();
           @Source(READ_SMS) String getOriginatingAddress();

}package android.text;

class ClipboardManager{
        void setText(@Sink(WRITE_CLIPBOARD) CharSequence arg0);
}

class Editable {
    
abstract Editable append(CharSequence text);
//Convenience for replace(length();, length();, text, 0, text.length(););

abstract Editable append(CharSequence text, int start, int end);
//Convenience for replace(length();, length();, text, start, end);

abstract Editable append(char text);
//Convenience for append(String.valueOf(text););.

abstract void clear();
//Convenience for replace(0, length();, "", 0, 0);

abstract void clearSpans();
//Removes all spans from the Editable, as if by calling removeSpan(Object); on each of them.

abstract Editable delete(int st, int en);
//Convenience for replace(st, en, "", 0, 0);

abstract InputFilter[] getFilters();
//Returns the array of input filters that are currently applied to changes to this Editable.

abstract Editable insert(int where, CharSequence text, int start, int end);
//Convenience for replace(where, where, text, start, end);

abstract Editable insert(int where, CharSequence text);
//Convenience for replace(where, where, text, 0, text.length(););;

abstract Editable replace(int st, int en, CharSequence source, int start, int end);
//Replaces the specified range (stâ€¦en); of text in this Editable with a copy of the slice startâ€¦end from source.

abstract Editable replace(int st, int en, CharSequence text);
//Convenience for replace(st, en, text, 0, text.length(););

abstract void setFilters(InputFilter[] filters);
//Sets the series of filters that will be called in succession whenever the text of this Editable is changed, each of which has the opportunity to limit or transform the text that is being inserted.

    
}

class Html {
static String escapeHtml(CharSequence text);
//Returns an HTML escaped representation of the given plain text.

static Spanned fromHtml(String source);
//Returns displayable styled text from the provided HTML string.

static Spanned fromHtml(String source, Html.ImageGetter imageGetter, Html.TagHandler tagHandler);
//Returns displayable styled text from the provided HTML string.

static String toHtml(Spanned text);
//Returns an HTML representation of the provided Spanned text.

}

class Spanned {
    
abstract int getSpanEnd(Object tag);
//Return the end of the range of text to which the specified markup object is attached, or -1 if the object is not attached.

abstract int getSpanFlags(Object tag);
//Return the flags that were specified when setSpan(Object, int, int, int); was used to attach the specified markup object, or 0 if the specified object has not been attached.

abstract int getSpanStart(Object tag);
//Return the beginning of the range of text to which the specified markup object is attached, or -1 if the object is not attached.

abstract <T> T[] getSpans(int start, int end, Class<T> type);
//Return an array of the markup objects attached to the specified slice of this CharSequence and whose type is the specified type or a subclass of it.

abstract int nextSpanTransition(int start, int limit, Class type);
//Return the first offset greater than or equal to start where a markup object of class type begins or ends, or limit if there are no starts or ends greater than or equal to start but less than limit.



}

class TextUtils {
    
static CharSequence commaEllipsize(CharSequence text, TextPaint p, float avail, String oneMore, String more);
//Converts a CharSequence of the comma-separated form "Andy, Bob, Charles, David" that is too wide to fit into the specified width into one like "Andy, Bob, 2 more".

static CharSequence concat(CharSequence... text);
//Returns a CharSequence concatenating the specified CharSequences, retaining their spans if any.

static void copySpansFrom(Spanned source, int start, int end, Class kind, Spannable dest, int destoff);
//Copies the spans from the region start...end in source to the region destoff...destoff+end-start in dest.

static void dumpSpans(CharSequence cs, Printer printer, String prefix);
//Debugging tool to print the spans in a CharSequence.

static CharSequence ellipsize(CharSequence text, TextPaint p, float avail, TextUtils.TruncateAt where);
//Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a truncated copy with ellipsis character added at the specified edge or center.

static CharSequence ellipsize(CharSequence text, TextPaint paint, float avail, TextUtils.TruncateAt where, boolean preserveLength, TextUtils.EllipsizeCallback callback);
//Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a copy with ellipsis character added at the specified edge or center.

static boolean equals(CharSequence a, CharSequence b);
//Returns true if a and b are equal, including if they are both null.

static CharSequence expandTemplate(CharSequence template, CharSequence... values);
//Replace instances of "^1", "^2", etc.

static int getCapsMode(CharSequence cs, int off, int reqModes);
//Determine what caps mode should be in effect at the current offset in the text.

static void getChars(CharSequence s, int start, int end, char[] dest, int destoff);

static int getLayoutDirectionFromLocale(Locale locale);
//Return the layout direction for a given Locale

static int getOffsetAfter(CharSequence text, int offset);

static int getOffsetBefore(CharSequence text, int offset);

static CharSequence getReverse(CharSequence source, int start, int end);

static int getTrimmedLength(CharSequence s);
//Returns the length that the specified CharSequence would have if spaces and control characters were trimmed from the start and end, as by trim();.

static String htmlEncode(String s);
//Html-encode the string.

static int indexOf(CharSequence s, char ch);

static int indexOf(CharSequence s, CharSequence needle);

static int indexOf(CharSequence s, CharSequence needle, int start);

static int indexOf(CharSequence s, char ch, int start, int end);

static int indexOf(CharSequence s, char ch, int start);

static int indexOf(CharSequence s, CharSequence needle, int start, int end);

static boolean isDigitsOnly(CharSequence str);
//Returns whether the given CharSequence contains only digits.

static boolean isEmpty(CharSequence str);
//Returns true if the string is null or 0-length.

static boolean isGraphic(CharSequence str);
//Returns whether the given CharSequence contains any printable characters.

static boolean isGraphic(char c);
//Returns whether this character is a printable character.

static String join(CharSequence delimiter, Iterable tokens);
//Returns a string containing the tokens joined by delimiters.

static String join(CharSequence delimiter, Object[] tokens);
//Returns a string containing the tokens joined by delimiters.

static int lastIndexOf(CharSequence s, char ch, int start, int last);

static int lastIndexOf(CharSequence s, char ch);

static int lastIndexOf(CharSequence s, char ch, int last);

static boolean regionMatches(CharSequence one, int toffset, CharSequence two, int ooffset, int len);

static CharSequence replace(CharSequence template, String[] sources, CharSequence[] destinations);
//Return a new CharSequence in which each of the source strings is replaced by the corresponding element of the destinations.

static String[] split(String text, Pattern pattern);
//Splits a string on a pattern.

static String[] split(String text, String expression);
//String.split(); returns [''] when the string to be split is empty.

static CharSequence stringOrSpannedString(CharSequence source);

static String substring(CharSequence source, int start, int end);
//Create a new String object containing the given range of characters from the source string.

static void writeToParcel(CharSequence cs, Parcel p, int parcelableFlags);
//Flatten a CharSequence and whatever styles can be copied across processes into the parcel.

    
    
}

class TextWatcher {
    void onTextChanged(@Source(FlowPermission.USER_INPUT)CharSequence arg0, @Source(FlowPermission.USER_INPUT)int arg1, @Source(FlowPermission.USER_INPUT)int arg2, @Source(FlowPermission.USER_INPUT)int arg3);
    void afterTextChanged(@Source(FlowPermission.USER_INPUT)Editable arg0);
    void beforeTextChanged(@Source(FlowPermission.USER_INPUT)CharSequence arg0, @Source(FlowPermission.USER_INPUT)int arg1, @Source(FlowPermission.USER_INPUT)int arg2, @Source(FlowPermission.USER_INPUT)int arg3);
}

package android.text.format;
class Time{

void setToNow();
//Sets the time of the given Time object to the current time.

Time();
//Construct a Time object in the default timezone.

long toMillis(boolean arg0);
//Converts this time to milliseconds.
}

package android.text.method;

class LinkMovementMethod {
    
    
static MovementMethod getInstance();

void initialize(TextView widget, Spannable text);

void onTakeFocus(TextView view, Spannable text, int dir);

boolean onTouchEvent(TextView widget, Spannable buffer, MotionEvent event);

//Protected Methods
boolean down(TextView widget, Spannable buffer);
//Performs a down movement action.

boolean handleMovementKey(TextView widget, Spannable buffer, int keyCode, int movementMetaState, KeyEvent event);
//Performs a movement key action.

boolean left(TextView widget, Spannable buffer);
//Performs a left movement action.

boolean right(TextView widget, Spannable buffer);
//Performs a right movement action.

boolean up(TextView widget, Spannable buffer);
//Performs an up movement action.




}


class ReplacementTransformationMethod{
        CharSequence getTransformation(CharSequence source, View v);
}

class SingleLineTransformationMethod {
    
    
static SingleLineTransformationMethod getInstance();

//Protected Methods
char[] getOriginal();
//The characters to be replaced are \n and \r.

char[] getReplacement();
//The character \n is replaced with is space; the character \r is replaced with is FEFF (zero width space);.



}


class TransformationMethod{
        CharSequence getTransformation(CharSequence arg0, View arg1);
}

package android.util;

class AndroidRuntimeException{
            AndroidRuntimeException(String name);
}
class AttributeSet {
    
abstract boolean getAttributeBooleanValue(String namespace, String attribute, boolean defaultValue);
//Return the boolean value of 'attribute'.

abstract boolean getAttributeBooleanValue(int index, boolean defaultValue);
//Return the boolean value of attribute at 'index'.

abstract int getAttributeCount();
//Returns the number of attributes available in the set.

abstract float getAttributeFloatValue(int index, float defaultValue);
//Return the float value of attribute at 'index'.

abstract float getAttributeFloatValue(String namespace, String attribute, float defaultValue);
//Return the float value of 'attribute'.

abstract int getAttributeIntValue(String namespace, String attribute, int defaultValue);
//Return the integer value of 'attribute'.

abstract int getAttributeIntValue(int index, int defaultValue);
//Return the integer value of attribute at 'index'.

abstract int getAttributeListValue(String namespace, String attribute, String[] options, int defaultValue);
//Return the index of the value of 'attribute' in the list 'options'.

abstract int getAttributeListValue(int index, String[] options, int defaultValue);
//Return the index of the value of attribute at 'index' in the list 'options'.

abstract String getAttributeName(int index);
//Returns the name of the specified attribute.

abstract int getAttributeNameResource(int index);
//Return the resource ID associated with the given attribute name.

abstract int getAttributeResourceValue(String namespace, String attribute, int defaultValue);
//Return the value of 'attribute' as a resource identifier.

abstract int getAttributeResourceValue(int index, int defaultValue);
//Return the value of attribute at 'index' as a resource identifier.

abstract int getAttributeUnsignedIntValue(int index, int defaultValue);
//Return the integer value of attribute at 'index' that is formatted as an unsigned value.

abstract int getAttributeUnsignedIntValue(String namespace, String attribute, int defaultValue);
//Return the boolean value of 'attribute' that is formatted as an unsigned value.

abstract String getAttributeValue(int index);
//Returns the value of the specified attribute as a string representation.

abstract String getAttributeValue(String namespace, String name);
//Returns the value of the specified attribute as a string representation.

abstract String getClassAttribute();
//Return the value of the "class" attribute or null if there is not one.

abstract String getIdAttribute();
//Return the value of the "id" attribute or null if there is not one.

abstract int getIdAttributeResourceValue(int defaultValue);
//Return the integer value of the "id" attribute or defaultValue if there is none.

abstract String getPositionDescription();
//Returns a description of the current position of the attribute set.

abstract int getStyleAttribute();
//Return the value of the "style" attribute or 0 if there is not one.



}

class Base64 {
    
static byte[] decode(byte[] input, int offset, int len, int flags);
//Decode the Base64-encoded data in input and return the data in a new byte array.

static byte[] decode(byte[] input, int flags);
//Decode the Base64-encoded data in input and return the data in a new byte array.

static byte[] decode(String str, int flags);
//Decode the Base64-encoded data in input and return the data in a new byte array.

static byte[] encode(byte[] input, int flags);
//Base64-encode the given data and return a newly allocated byte[] with the result.

static byte[] encode(byte[] input, int offset, int len, int flags);
//Base64-encode the given data and return a newly allocated byte[] with the result.

static String encodeToString(byte[] input, int offset, int len, int flags);
//Base64-encode the given data and return a newly allocated String with the result.

static String encodeToString(byte[] input, int flags);
//Base64-encode the given data and return a newly allocated String with the result.



}

@PolyFlowReceiver
class FloatMath {
    
    
static float ceil(float value);
//Returns the float conversion of the most negative (i.e.

static float cos(float angle);
//Returns the closest float approximation of the cosine of the argument.

static float exp(float value);
//Returns the closest float approximation of the raising "e" to the power of the argument.

static float floor(float value);
//Returns the float conversion of the most positive (i.e.

static float hypot(float x, float y);
//Returns sqrt(x2+ y2);.

static float pow(float x, float y);
//Returns the closest float approximation of the result of raising x to the power of y.

static float sin(float angle);
//Returns the closest float approximation of the sine of the argument.

static float sqrt(float value);
//Returns the closest float approximation of the square root of the argument.



}


class Log {
//CSH:: I have no idea why most of these methods return an int, the documentation doesn't mention any return values

static int d(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//Send a DEBUG log message.

static int d(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//Send a DEBUG log message and log the exception.

static int e(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//Send an ERROR log message.

static int e(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//Send a ERROR log message and log the exception.

static String getStackTraceString(Throwable tr);
//Handy function to get a loggable stack trace from a Throwable

static int i(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//Send an INFO log message.

static int i(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//Send a INFO log message and log the exception.

static boolean isLoggable(String tag, int level);
//Checks to see whether or not a log for the specified tag is loggable at the specified level.

static int v(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//Send a VERBOSE log message.

static int v(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//Send a VERBOSE log message and log the exception.

static int w(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//Send a WARN log message and log the exception.

static int w(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//Send a WARN log message.

static int wtf(@Sink(WRITE_LOGS) String tag, Throwable tr);
//What a Terrible Failure: Report an exception that should never happen.

static int wtf(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);
//What a Terrible Failure: Report a condition that should never happen.

static int wtf(@Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg, Throwable tr);
//What a Terrible Failure: Report an exception that should never happen.

static int println(int priority, @Sink(WRITE_LOGS) String tag, @Sink(WRITE_LOGS) String msg);

}
class SparseArray{
            SparseArray();
            int size();
            int keyAt(int index);
            int indexOfValue(E value);
            E get(int key);
            void append(int key, E value);
}
class SparseBooleanArray {
    
    
void append(int key, boolean value);
//Puts a key/value pair into the array, optimizing for the case where the key is greater than all existing keys in the array.

void clear();
//Removes all key-value mappings from this SparseBooleanArray.

SparseBooleanArray clone();
//Creates and returns a copy of this Object.

void delete(int key);
//Removes the mapping from the specified key, if there was any.

boolean get(int key);
//Gets the boolean mapped from the specified key, or false if no such mapping has been made.

boolean get(int key, boolean valueIfKeyNotFound);
//Gets the boolean mapped from the specified key, or the specified value if no such mapping has been made.

int indexOfKey(int key);
//Returns the index for which keyAt(int); would return the specified key, or a negative number if the specified key is not mapped.

int indexOfValue(boolean value);
//Returns an index for which valueAt(int); would return the specified key, or a negative number if no keys map to the specified value.

int keyAt(int index);
//Given an index in the range 0...size();-1, returns the key from the indexth key-value mapping that this SparseBooleanArray stores.

void put(int key, boolean value);
//Adds a mapping from the specified key to the specified value, replacing the previous mapping from the specified key if there was one.

int size();
//Returns the number of key-value mappings that this SparseBooleanArray currently stores.

boolean valueAt(int index);
//Given an index in the range 0...size();-1, returns the value from the indexth key-value mapping that this SparseBooleanArray stores.



}

class SparseArray{
            void clear();
}

class Xml {
    
static AttributeSet asAttributeSet(XmlPullParser parser);
//Return an AttributeSet interface for use with the given XmlPullParser.

static Xml.Encoding findEncodingByName(String encodingName);
//Finds an encoding by name.

static XmlPullParser newPullParser();
//Returns a new pull parser with namespace support.

static XmlSerializer newSerializer();
//Creates a new xml serializer.

static void parse(String xml, ContentHandler contentHandler);
//Parses the given xml string and fires events on the given SAX handler.

static void parse(InputStream in, Xml.Encoding encoding, ContentHandler contentHandler);
//Parses xml from the given input stream and fires events on the given SAX handler.

static void parse(Reader in, ContentHandler contentHandler);
//Parses xml from the given reader and fires events on the given SAX handler.



}
package android.view;

class AbsSavedState{
            Parcelable getSuperState();
            void writeToParcel(Parcel dest, int flags);
}
class ActionMode {
    
abstract void finish();
//Finish and close this action mode.

abstract View getCustomView();
//Returns the current custom view for this action mode.

abstract Menu getMenu();
//Returns the menu of actions that this action mode presents.

abstract MenuInflater getMenuInflater();
//Returns a MenuInflater with the ActionMode's context.

abstract CharSequence getSubtitle();
//Returns the current subtitle of this action mode.

Object getTag();
//Retrieve the tag object associated with this ActionMode.

abstract CharSequence getTitle();
//Returns the current title of this action mode.

boolean getTitleOptionalHint();

abstract void invalidate();
//Invalidate the action mode and refresh menu content.

boolean isTitleOptional();

abstract void setCustomView(View view);
//Set a custom view for this action mode.

abstract void setSubtitle(int resId);
//Set the subtitle of the action mode.

abstract void setSubtitle(CharSequence subtitle);
//Set the subtitle of the action mode.

void setTag(Object tag);
//Set a tag object associated with this ActionMode.

abstract void setTitle(CharSequence title);
//Set the title of the action mode.

abstract void setTitle(int resId);
//Set the title of the action mode.

void setTitleOptionalHint(boolean titleOptional);
//Set whether or not the title/subtitle display for this action mode is optional.



}
class ActionMode$Callback{
            boolean onPrepareActionMode(ActionMode arg0, Menu arg1);
            boolean onCreateActionMode(ActionMode arg0, Menu arg1);
            boolean onActionItemClicked(ActionMode arg0, MenuItem arg1);
            void onDestroyActionMode(ActionMode arg0);
}

class CollapsibleActionView{
            void onActionViewCollapsed();
}

class ContextMenu {
    
abstract void clearHeader();
//Clears the header of the context menu.

abstract ContextMenu setHeaderIcon(@Sink(DISPLAY) Drawable icon);
//Sets the context menu header's icon to the icon given in icon Drawable.

abstract ContextMenu setHeaderIcon(int iconRes);
//Sets the context menu header's icon to the icon given in iconRes resource id.

abstract ContextMenu setHeaderTitle(@Sink(DISPLAY) CharSequence title);
//Sets the context menu header's title to the title given in title.

abstract ContextMenu setHeaderTitle(int titleRes);
//Sets the context menu header's title to the title given in titleRes resource identifier.

abstract ContextMenu setHeaderView(@Sink(DISPLAY) View view);
//Sets the header of the context menu to the View given in view.



}

class ContextThemeWrapper {

//void applyOverrideConfiguration(Configuration overrideConfiguration);
//Call to set an "override configuration" on this context -- this is a configuration that replies one or more values of the standard configuration that is applied to the context.

Resources getResources();
//Return a Resources instance for your application's package.

Object getSystemService(String name);
//Return the handle to a system-level service by name.
//CSH: Should be PolyX

//Resources.Theme getTheme();
//Return the Theme object associated with this Context.

//void setTheme(int resid);
//Set the base theme for this context.

//Protected Methods
//void attachBaseContext(Context newBase);
//Set the base context for this ContextWrapper.

//void onApplyThemeResource(Resources.Theme theme, int resid, boolean first);
//Called by setTheme(int); and getTheme(); to apply a theme resource to the current Theme object.

}

class Display {
    
    
void getCurrentSizeRange(Point outSmallestSize, Point outLargestSize);
//Return the range of display sizes an application can expect to encounter under normal operation, as long as there is no physical change in screen size.

int getDisplayId();
//Gets the display id.

int getFlags();
//Returns a combination of flags that describe the capabilities of the display.

int getHeight();
//This method was deprecated in API level 13. Use getSize(Point); instead.

void getMetrics(DisplayMetrics outMetrics);
//Gets display metrics that describe the size and density of this display.

String getName();
//Gets the name of the display.

int getOrientation();
//This method was deprecated in API level 8. use getRotation();

int getPixelFormat();
//This method was deprecated in API level 17. This method is no longer supported. The result is always RGBA_8888.

void getRealMetrics(DisplayMetrics outMetrics);
//Gets display metrics based on the real size of this display.

void getRealSize(Point outSize);
//Gets the real size of the display without subtracting any window decor or applying any compatibility scale factors.

void getRectSize(Rect outSize);
//Gets the size of the display as a rectangle, in pixels.

float getRefreshRate();
//Gets the refresh rate of this display in frames per second.

int getRotation();
//Returns the rotation of the screen from its "natural" orientation.

void getSize(Point outSize);
//Gets the size of the display, in pixels.

int getWidth();
//This method was deprecated in API level 13. Use getSize(Point); instead.

boolean isValid();
//Returns true if this display is still valid, false if the display has been removed.

String toString();
//Returns a string containing a concise, human-readable description of this object.



    
}

class FocusFinder {
    
View findNearestTouchable(ViewGroup root, int x, int y, int direction, int[] deltas);
//Find the nearest touchable view to the specified view.

final View findNextFocus(ViewGroup root, View focused, int direction);
//Find the next view to take focus in root's descendants, starting from the view that currently is focused.

View findNextFocusFromRect(ViewGroup root, Rect focusedRect, int direction);
//Find the next view to take focus in root's descendants, searching from a particular rectangle in root's coordinates.

static FocusFinder getInstance();
//Get the focus finder for this thread.



}

class GestureDetector {

boolean isLongpressEnabled();

boolean onTouchEvent(MotionEvent ev);
//Analyzes the given motion event and if applicable triggers the appropriate callbacks on the GestureDetector.OnGestureListener supplied.

void setIsLongpressEnabled(boolean isLongpressEnabled);
//Set whether longpress is enabled, if this is enabled when a user presses and holds down you get a longpress event and nothing further.

void setOnDoubleTapListener(GestureDetector.OnDoubleTapListener onDoubleTapListener);
//Sets the listener which will be called for double-tap and related gestures.

    
}

class GestureDetector$OnDoubleTapListener{
        boolean onDoubleTapEvent(@Source(USER_INPUT) MotionEvent arg0);
        boolean onSingleTapConfirmed(@Source(USER_INPUT) MotionEvent arg0);
        boolean onDoubleTap(@Source(USER_INPUT) MotionEvent arg0);
}
class GestureDetector$OnGestureListener{
        boolean onScroll(@Source(USER_INPUT) MotionEvent arg0, @Source(USER_INPUT) MotionEvent arg1, @Source(USER_INPUT) float arg2, @Source(USER_INPUT) float arg3);
        boolean onFling(@Source(USER_INPUT) MotionEvent arg0, @Source(USER_INPUT) MotionEvent arg1, @Source(USER_INPUT) float arg2, @Source(USER_INPUT) float arg3);
        void onShowPress(@Source(USER_INPUT) MotionEvent arg0);
        boolean onSingleTapUp(@Source(USER_INPUT) MotionEvent arg0);
        void onLongPress(@Source(USER_INPUT) MotionEvent arg0);
        boolean onDown(@Source(USER_INPUT) MotionEvent arg0);
}

class KeyEvent {
static KeyEvent changeAction(KeyEvent event, int action);
//Create a new key event that is the same as the given one, but whose action is replaced with the given value.

static KeyEvent changeFlags(KeyEvent event, int flags);
//Create a new key event that is the same as the given one, but whose flags are replaced with the given value.

static KeyEvent changeTimeRepeat(KeyEvent event, long eventTime, int newRepeat);
//Create a new key event that is the same as the given one, but whose event time and repeat count are replaced with the given value.

static KeyEvent changeTimeRepeat(KeyEvent event, long eventTime, int newRepeat, int newFlags);
//Create a new key event that is the same as the given one, but whose event time and repeat count are replaced with the given value.

final boolean dispatch(KeyEvent.Callback receiver, KeyEvent.DispatcherState state, Object target);
//Deliver this key event to a KeyEvent.Callback interface.

final boolean dispatch(KeyEvent.Callback receiver);
//This method was deprecated in API level 5. Use dispatch(Callback, DispatcherState, Object); instead.

final int getAction();
//Retrieve the action of this key event.

final String getCharacters();
//For the special case of a ACTION_MULTIPLE event with key code of KEYCODE_UNKNOWN, this is a raw string of characters associated with the event.

static int getDeadChar(int accent, int c);
//Get the character that is produced by putting accent on the character c.

final int getDeviceId();
//Gets the id for the device that this event came from.

char getDisplayLabel();
//Gets the primary character for this key.

final long getDownTime();
//Retrieve the time of the most recent key down event, in the uptimeMillis(); time base.

final long getEventTime();
//Retrieve the time this event occurred, in the uptimeMillis(); time base.

final int getFlags();
//Returns the flags for this key event.

final KeyCharacterMap getKeyCharacterMap();
//Gets the KeyCharacterMap associated with the keyboard device.

final int getKeyCode();
//Retrieve the key code of the key event.

boolean getKeyData(KeyCharacterMap.KeyData results);
//This method was deprecated in API level 11. instead use getDisplayLabel();, getNumber(); or getUnicodeChar(int);.

char getMatch(char[] chars);
//Gets the first character in the character array that can be generated by the specified key code.

char getMatch(char[] chars, int metaState);
//Gets the first character in the character array that can be generated by the specified key code.

static int getMaxKeyCode();
//Returns the maximum keycode.

final int getMetaState();
//Returns the state of the meta keys.

static int getModifierMetaStateMask();
//Gets a mask that includes all valid modifier key meta state bits.

final int getModifiers();
//Returns the state of the modifier keys.

char getNumber();
//Gets the number or symbol associated with the key.

final int getRepeatCount();
//Retrieve the repeat count of the event.

final int getScanCode();
//Retrieve the hardware key id of this key event. These values are not reliable and vary from device to device.

final int getSource();
//Gets the source of the event.

int getUnicodeChar();
//Gets the Unicode character generated by the specified key and meta key state combination.

int getUnicodeChar(int metaState);
//Gets the Unicode character generated by the specified key and meta key state combination.

final boolean hasModifiers(int modifiers);
//Returns true if only the specified modifiers keys are pressed.

final boolean hasNoModifiers();
//Returns true if no modifier keys are pressed.

final boolean isAltPressed();
//Returns the pressed state of the ALT meta key.

final boolean isCanceled();
//For ACTION_UP events, indicates that the event has been canceled as per FLAG_CANCELED.

final boolean isCapsLockOn();
//Returns the locked state of the CAPS LOCK meta key.

final boolean isCtrlPressed();
//Returns the pressed state of the CTRL meta key.

final boolean isFunctionPressed();
//Returns the pressed state of the FUNCTION meta key.

final static boolean isGamepadButton(int keyCode);
//Returns true if the specified keycode is a gamepad button.

final boolean isLongPress();
//For ACTION_DOWN events, indicates that the event has been canceled as per FLAG_LONG_PRESS.

final boolean isMetaPressed();
//Returns the pressed state of the META meta key.

static boolean isModifierKey(int keyCode);
//Returns true if this key code is a modifier key.

final boolean isNumLockOn();
//Returns the locked state of the NUM LOCK meta key.

boolean isPrintingKey();
//Returns true if this key produces a glyph.

final boolean isScrollLockOn();
//Returns the locked state of the SCROLL LOCK meta key.

final boolean isShiftPressed();
//Returns the pressed state of the SHIFT meta key.

final boolean isSymPressed();
//Returns the pressed state of the SYM meta key.

final boolean isSystem();
//Is this a system key? System keys can not be used for menu shortcuts.

final boolean isTracking();
//For ACTION_UP events, indicates that the event is still being tracked from its initial down event as per FLAG_TRACKING.

static int keyCodeFromString(String symbolicName);
//Gets a keycode by its symbolic name such as "KEYCODE_A" or an equivalent numeric constant such as "1001".

static String keyCodeToString(int keyCode);
//Returns a string that represents the symbolic name of the specified keycode such as "KEYCODE_A", "KEYCODE_DPAD_UP", or an equivalent numeric constant such as "1001" if unknown.

static boolean metaStateHasModifiers(int metaState, int modifiers);
//Returns true if only the specified modifier keys are pressed according to the specified meta state.

static boolean metaStateHasNoModifiers(int metaState);
//Returns true if no modifiers keys are pressed according to the specified meta state.

static int normalizeMetaState(int metaState);
//Normalizes the specified meta state.

final void setSource(int source);
//Modifies the source of the event.

final void startTracking();
//Call this during onKeyDown(int, KeyEvent); to have the system track the key through its final up (possibly including a long press);.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

    
}

class KeyEvent$Callback{
        boolean onKeyDown(@Source(USER_INPUT) int arg0, @Source(USER_INPUT) KeyEvent arg1);
}

class LayoutInflater$Factory{
            View onCreateView(String arg0, Context arg1, AttributeSet arg2);
}

class LayoutInflater {

abstract LayoutInflater cloneInContext(Context newContext);
//Create a copy of the existing LayoutInflater object, with the copy pointing to a different Context than the original.

final View createView(String name, String prefix, AttributeSet attrs);
//Low-level function for instantiating a view by name.

static LayoutInflater from(Context context);
//Obtains the LayoutInflater from the given context.

Context getContext();
//Return the context we are running in, for access to resources, class loader, etc.

final LayoutInflater.Factory getFactory();
//Return the current LayoutInflater.Factory (or null);.

final LayoutInflater.Factory2 getFactory2();
//Return the current LayoutInflater.Factory2.

LayoutInflater.Filter getFilter();

View inflate(int resource, ViewGroup root);
//Inflate a new view hierarchy from the specified xml resource.

View inflate(XmlPullParser parser, ViewGroup root);
//Inflate a new view hierarchy from the specified xml node.

View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot);
//Inflate a new view hierarchy from the specified XML node.

View inflate(int resource, ViewGroup root, boolean attachToRoot);
//Inflate a new view hierarchy from the specified xml resource.

void setFactory(LayoutInflater.Factory factory);
//Attach a custom Factory interface for creating views while using this LayoutInflater.

void setFactory2(LayoutInflater.Factory2 factory);
//Like setFactory(LayoutInflater.Factory);, but allows you to set a LayoutInflater.Factory2 interface.

void setFilter(LayoutInflater.Filter filter);
//Sets the LayoutInflater.Filter to by this LayoutInflater.

//Protected Methods
View onCreateView(String name, AttributeSet attrs);
//This routine is responsible for creating the correct subclass of View given the xml element name.

View onCreateView(View parent, String name, AttributeSet attrs);
//Version of onCreateView(String, AttributeSet); that also takes the future parent of the view being constructure.

}

class Menu {

abstract MenuItem add(@Sink(DISPLAY) CharSequence title);
//Add a new item to the menu.

abstract MenuItem add(int groupId, int itemId, int order, int titleRes);
//Variation on add(int, int, int, CharSequence); that takes a string resource identifier instead of the string itself.

abstract MenuItem add(int titleRes);
//Add a new item to the menu.

abstract MenuItem add(int groupId, int itemId, int order, @Sink(DISPLAY) CharSequence title);
//Add a new item to the menu.

abstract int addIntentOptions(int groupId, int itemId, int order, ComponentName caller, Intent[] specifics, Intent intent, int flags, MenuItem[] outSpecificItems);
//Add a group of menu items corresponding to actions that can be performed for a particular Intent.

abstract SubMenu addSubMenu(int groupId, int itemId, int order, @Sink(DISPLAY) CharSequence title);
//Add a new sub-menu to the menu.

abstract SubMenu addSubMenu(int groupId, int itemId, int order, int titleRes);
//Variation on addSubMenu(int, int, int, CharSequence); that takes a string resource identifier for the title instead of the string itself.

abstract SubMenu addSubMenu(@Sink(DISPLAY) CharSequence title);
//Add a new sub-menu to the menu.

abstract SubMenu addSubMenu(int titleRes);
//Add a new sub-menu to the menu.

abstract void clear();
//Remove all existing items from the menu, leaving it empty as if it had just been created.

abstract void close();
//Closes the menu, if open.

abstract MenuItem findItem(int id);
//Return the menu item with a particular identifier.

abstract MenuItem getItem(int index);
//Gets the menu item at the given index.

abstract boolean hasVisibleItems();
//Return whether the menu currently has item items that are visible.

abstract boolean isShortcutKey(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Is a keypress one of the defined shortcut keys for this window.

abstract boolean performIdentifierAction(int id, int flags);
//Execute the menu item action associated with the given menu identifier.

abstract boolean performShortcut(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event, int flags);
//Execute the menu item action associated with the given shortcut character.

abstract void removeGroup(int groupId);
//Remove all items in the given group.

abstract void removeItem(int id);
//Remove the item with the given identifier.

abstract void setGroupCheckable(int group, boolean checkable, boolean exclusive);
//Control whether a particular group of items can show a check mark.

abstract void setGroupEnabled(int group, boolean enabled);
//Enable or disable all menu items that are in the given group.

abstract void setGroupVisible(int group, boolean visible);
//Show or hide all menu items that are in the given group.

abstract void setQwertyMode(boolean isQwerty);
//Control whether the menu should be running in qwerty mode (alphabetic shortcuts); or 12-key mode (numeric shortcuts);.

abstract int size();
//Get the number of items in the menu.

}


class MenuInflater {
    
void inflate(int menuRes, Menu menu);
//Inflate a menu hierarchy from the specified XML resource.



}

class MenuItem {

abstract boolean collapseActionView();
//Collapse the action view associated with this menu item.

abstract boolean expandActionView();
//Expand the action view associated with this menu item.

abstract ActionProvider getActionProvider();
//Gets the ActionProvider.

abstract View getActionView();
//Returns the currently set action view for this menu item.

abstract char getAlphabeticShortcut();
//Return the char for this menu item's alphabetic shortcut.

abstract int getGroupId();
//Return the group identifier that this menu item is part of.

abstract Drawable getIcon();
//Returns the icon for this item as a Drawable (getting it from resources if it hasn't been loaded before);.

abstract Intent getIntent();
//Return the Intent associated with this item.

abstract int getItemId();
//Return the identifier for this menu item.

abstract ContextMenu.ContextMenuInfo getMenuInfo();
//Gets the extra information linked to this menu item.

abstract char getNumericShortcut();
//Return the char for this menu item's numeric (12-key); shortcut.

abstract int getOrder();
//Return the category and order within the category of this item.

abstract SubMenu getSubMenu();
//Get the sub-menu to be invoked when this item is selected, if it has one.

abstract CharSequence getTitle();
//Retrieve the current title of the item.

abstract CharSequence getTitleCondensed();
//Retrieve the current condensed title of the item.

abstract boolean hasSubMenu();
//Check whether this item has an associated sub-menu.

abstract boolean isActionViewExpanded();
//Returns true if this menu item's action view has been expanded.

abstract boolean isCheckable();
//Return whether the item can currently display a check mark.

abstract boolean isChecked();
//Return whether the item is currently displaying a check mark.

abstract boolean isEnabled();
//Return the enabled state of the menu item.

abstract boolean isVisible();
//Return the visibility of the menu item.

abstract MenuItem setActionProvider(ActionProvider actionProvider);
//Sets the ActionProvider responsible for creating an action view if the item is placed on the action bar.

abstract MenuItem setActionView(int resId);
//Set an action view for this menu item.

abstract MenuItem setActionView(View view);
//Set an action view for this menu item.

abstract MenuItem setAlphabeticShortcut(char alphaChar);
//Change the alphabetic shortcut associated with this item.

abstract MenuItem setCheckable(boolean checkable);
//Control whether this item can display a check mark.

abstract MenuItem setChecked(@Sink(DISPLAY) boolean checked);
//Control whether this item is shown with a check mark.

abstract MenuItem setEnabled(@Sink(DISPLAY) boolean enabled);
//Sets whether the menu item is enabled.
// setting to false greys out the View

abstract MenuItem setIcon(@Sink(DISPLAY) Drawable icon);
//Change the icon associated with this item.

abstract MenuItem setIcon(int iconRes);
//Change the icon associated with this item.

abstract MenuItem setIntent(Intent intent);
//Change the Intent associated with this item.

abstract MenuItem setNumericShortcut(char numericChar);
//Change the numeric shortcut associated with this item.

abstract MenuItem setOnActionExpandListener(MenuItem.OnActionExpandListener listener);
//Set an MenuItem.OnActionExpandListener on this menu item to be notified when the associated action view is expanded or collapsed.

abstract MenuItem setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener menuItemClickListener);
//Set a custom listener for invocation of this menu item.

abstract MenuItem setShortcut(char numericChar, char alphaChar);
//Change both the numeric and alphabetic shortcut associated with this item.

abstract void setShowAsAction(int actionEnum);
//Sets how this item should display in the presence of an Action Bar.

abstract MenuItem setShowAsActionFlags(int actionEnum);
//Sets how this item should display in the presence of an Action Bar.

abstract MenuItem setTitle(@Sink(DISPLAY) CharSequence title);
//Change the title associated with this item.

abstract MenuItem setTitle(int title);
//Change the title associated with this item.

abstract MenuItem setTitleCondensed(@Sink(DISPLAY) CharSequence title);
//Change the condensed title associated with this item.

abstract MenuItem setVisible(@Sink(DISPLAY) boolean visible);
//Sets the visibility of the menu item.

}

class MotionEvent {
    //CSH: all these methods have to do with a user touching the screen, but so far we've decided that touches don't count as USER_INPUT
    
final void addBatch(long eventTime, PointerCoords[] pointerCoords, int metaState);
//Add a new movement to the batch of movements in this event.

final void addBatch(long eventTime, float x, float y, float pressure, float size, int metaState);
//Add a new movement to the batch of movements in this event.

static int axisFromString(String symbolicName);
//Gets an axis by its symbolic name such as "AXIS_X" or an equivalent numeric constant such as "42".

static String axisToString(int axis);
//Returns a string that represents the symbolic name of the specified axis such as "AXIS_X" or an equivalent numeric constant such as "42" if unknown.

final int findPointerIndex(int pointerId);
//Given a pointer identifier, find the index of its data in the event.

final int getAction();
//Return the kind of action being performed.

final int getActionIndex();
//For ACTION_POINTER_DOWN or ACTION_POINTER_UP as returned by getActionMasked();, this returns the associated pointer index.

final int getActionMasked();
//Return the masked action being performed, without pointer index information.

final float getAxisValue(int axis);
//getAxisValue(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getAxisValue(int axis, int pointerIndex);
//Returns the value of the requested axis for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final int getButtonState();
//Gets the state of all buttons that are pressed such as a mouse or stylus button.

final int getDeviceId();
//Gets the id for the device that this event came from.

final long getDownTime();
//Returns the time (in ms); when the user originally pressed down to start a stream of position events.

final int getEdgeFlags();
//Returns a bitfield indicating which edges, if any, were touched by this MotionEvent.

final @Source(FlowPermission.READ_TIME) long getEventTime();
//Retrieve the time this event occurred, in the uptimeMillis(); time base.

final int getFlags();
//Gets the motion event flags.

final float getHistoricalAxisValue(int axis, int pointerIndex, int pos);
//Returns the historical value of the requested axis, as per getAxisValue(int, int);, occurred between this event and the previous event for the given pointer.

final float getHistoricalAxisValue(int axis, int pos);
//getHistoricalAxisValue(int, int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final long getHistoricalEventTime(int pos);
//Returns the time that a historical movement occurred between this event and the previous event, in the uptimeMillis(); time base.

final float getHistoricalOrientation(int pointerIndex, int pos);
//Returns a historical orientation coordinate, as per getOrientation(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalOrientation(int pos);
//getHistoricalOrientation(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final void getHistoricalPointerCoords(int pointerIndex, int pos, MotionEvent.PointerCoords outPointerCoords);
//Populates a MotionEvent.PointerCoords object with historical pointer coordinate data, as per getPointerCoords(int, MotionEvent.PointerCoords);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalPressure(int pos);
//getHistoricalPressure(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalPressure(int pointerIndex, int pos);
//Returns a historical pressure coordinate, as per getPressure(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalSize(int pos);
//getHistoricalSize(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalSize(int pointerIndex, int pos);
//Returns a historical size coordinate, as per getSize(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalToolMajor(int pointerIndex, int pos);
//Returns a historical tool major axis coordinate, as per getToolMajor(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalToolMajor(int pos);
//getHistoricalToolMajor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalToolMinor(int pointerIndex, int pos);
//Returns a historical tool minor axis coordinate, as per getToolMinor(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalToolMinor(int pos);
//getHistoricalToolMinor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalTouchMajor(int pointerIndex, int pos);
//Returns a historical touch major axis coordinate, as per getTouchMajor(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalTouchMajor(int pos);
//getHistoricalTouchMajor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalTouchMinor(int pointerIndex, int pos);
//Returns a historical touch minor axis coordinate, as per getTouchMinor(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalTouchMinor(int pos);
//getHistoricalTouchMinor(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalX(int pos);
//getHistoricalX(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalX(int pointerIndex, int pos);
//Returns a historical X coordinate, as per getX(int);, that occurred between this event and the previous event for the given pointer.

final float getHistoricalY(int pos);
//getHistoricalY(int, int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getHistoricalY(int pointerIndex, int pos);
//Returns a historical Y coordinate, as per getY(int);, that occurred between this event and the previous event for the given pointer.

final int getHistorySize();
//Returns the number of historical points in this event.

final int getMetaState();
//Returns the state of any meta / modifier keys that were in effect when the event was generated.

final float getOrientation(int pointerIndex);
//Returns the orientation of the touch area and tool area in radians clockwise from vertical for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getOrientation();
//getOrientation(int); for the first pointer index (may be an arbitrary pointer identifier);.

final void getPointerCoords(int pointerIndex, MotionEvent.PointerCoords outPointerCoords);
//Populates a MotionEvent.PointerCoords object with pointer coordinate data for the specified pointer index.

final int getPointerCount();
//The number of pointers of data contained in this event.

final int getPointerId(int pointerIndex);
//Return the pointer identifier associated with a particular pointer data index is this event.

final void getPointerProperties(int pointerIndex, MotionEvent.PointerProperties outPointerProperties);
//Populates a MotionEvent.PointerProperties object with pointer properties for the specified pointer index.

final float getPressure();
//getPressure(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getPressure(int pointerIndex);
//Returns the current pressure of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getRawX();
//Returns the original raw X coordinate of this event.

final float getRawY();
//Returns the original raw Y coordinate of this event.

final float getSize(int pointerIndex);
//Returns a scaled value of the approximate size for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getSize();
//getSize(int); for the first pointer index (may be an arbitrary pointer identifier);.

final int getSource();
//Gets the source of the event.

final float getToolMajor(int pointerIndex);
//Returns the length of the major axis of an ellipse that describes the size of the approaching tool for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getToolMajor();
//getToolMajor(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getToolMinor();
//getToolMinor(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getToolMinor(int pointerIndex);
//Returns the length of the minor axis of an ellipse that describes the size of the approaching tool for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final int getToolType(int pointerIndex);
//Gets the tool type of a pointer for the given pointer index.

final float getTouchMajor();
//getTouchMajor(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getTouchMajor(int pointerIndex);
//Returns the length of the major axis of an ellipse that describes the touch area at the point of contact for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getTouchMinor();
//getTouchMinor(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getTouchMinor(int pointerIndex);
//Returns the length of the minor axis of an ellipse that describes the touch area at the point of contact for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getX(int pointerIndex);
//Returns the X coordinate of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getX();
//getX(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getXPrecision();
//Return the precision of the X coordinates being reported.

final float getY(int pointerIndex);
//Returns the Y coordinate of this event for the given pointer index (use getPointerId(int); to find the pointer identifier for this index);.

final float getY();
//getY(int); for the first pointer index (may be an arbitrary pointer identifier);.

final float getYPrecision();
//Return the precision of the Y coordinates being reported.

static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, PointerProperties[] pointerProperties, PointerCoords[] pointerCoords, int metaState, int buttonState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags);
//Create a new MotionEvent, filling in all of the basic values that define the motion.

static MotionEvent obtain(long downTime, long eventTime, int action, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags);
//Create a new MotionEvent, filling in all of the basic values that define the motion.

static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags);
//This method was deprecated in API level 9. Use obtain(long, long, int, float, float, float, float, int, float, float, int, int); instead.

static MotionEvent obtain(long downTime, long eventTime, int action, int pointerCount, int[] pointerIds, PointerCoords[] pointerCoords, int metaState, float xPrecision, float yPrecision, int deviceId, int edgeFlags, int source, int flags);
//This method was deprecated in API level 14. Use obtain(long, long, int, int, PointerProperties[], PointerCoords[], int, int, float, float, int, int, int, int); instead.

static MotionEvent obtain(MotionEvent other);
//Create a new MotionEvent, copying from an existing one.

static MotionEvent obtain(long downTime, long eventTime, int action, float x, float y, int metaState);
//Create a new MotionEvent, filling in a subset of the basic motion values.

static MotionEvent obtainNoHistory(MotionEvent other);
//Create a new MotionEvent, copying from an existing one, but not including any historical point information.

final void offsetLocation(float deltaX, float deltaY);
//Adjust this event's location.

final void recycle();
//Recycle the MotionEvent, to be re-used by a later caller.

final void setAction(int action);
//Sets this event's action.

final void setEdgeFlags(int flags);
//Sets the bitfield indicating which edges, if any, were touched by this MotionEvent.

final void setLocation(float x, float y);
//Set this event's location.

final void setSource(int source);
//Modifies the source of the event.

String toString();
//Returns a string containing a concise, human-readable description of this object.

final void transform(Matrix matrix);
//Applies a transformation matrix to all of the points in the event.

void writeToParcel(Parcel out, int flags);
//Flatten this object in to a Parcel.

//Protected Methods

void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

}

class SurfaceView{
//SOM
 @Sink({DISPLAY, CONDITIONAL}) SurfaceHolder getHolder ();
}        
     
class SoundEffectConstants {
    
static int getContantForFocusDirection(int direction);
//Get the sonification constant for the focus directions.


}
class SurfaceHolder {
    
    
abstract void addCallback(SurfaceHolder.Callback callback);
//Add a Callback interface for this holder.

abstract Surface getSurface();
//Direct access to the surface object.

abstract Rect getSurfaceFrame();
//Retrieve the current size of the surface.

abstract boolean isCreating();
//Use this method to find out if the surface is in the process of being created from Callback methods.

abstract Canvas lockCanvas(Rect dirty);
//Just like lockCanvas(); but allows specification of a dirty rectangle.

abstract Canvas lockCanvas();
//Start editing the pixels in the surface.

abstract void removeCallback(SurfaceHolder.Callback callback);
//Removes a previously added Callback interface from this holder.

abstract void setFixedSize(int width, int height);
//Make the surface a fixed size.

abstract void setFormat(int format);
//Set the desired PixelFormat of the surface.

abstract void setKeepScreenOn(boolean screenOn);
//Enable or disable option to keep the screen turned on while this surface is displayed.

abstract void setSizeFromLayout();
//Allow the surface to resized based on layout of its container (this is the default);.

abstract void setType(int type);
//This method was deprecated in API level 11. this is ignored, this value is set automatically when needed.

abstract void unlockCanvasAndPost(Canvas canvas);
//Finish editing pixels in the surface.



}

interface SurfaceHolder$Callback {
    void surfaceCreated(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0);
    void surfaceChanged(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0, int arg1, int arg2, int arg3);
    void surfaceDestroyed(@Sink(FlowPermission.DISPLAY) SurfaceHolder arg0);
}

class SurfaceView {
    
    
void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

boolean gatherTransparentRegion(Region region);
//This is used by the RootView to perform an optimization when the view hierarchy contains one or several SurfaceView.

SurfaceHolder getHolder();
//Return the SurfaceHolder providing access and control over this SurfaceView's underlying surface.

void setSecure(boolean isSecure);
//Control whether the surface view's content should be treated as secure, preventing it from appearing in screenshots or from being viewed on non-secure displays.

void setVisibility(int visibility);
//Set the enabled state of this view.

void setZOrderMediaOverlay(boolean isMediaOverlay);
//Control whether the surface view's surface is placed on top of another regular surface view in the window (but still behind the window itself);.

void setZOrderOnTop(boolean onTop);
//Control whether the surface view's surface is placed on top of its window.

//Protected Methods
void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onWindowVisibilityChanged(int visibility);
//Called when the window containing has change its visibility (between GONE, INVISIBLE, and VISIBLE);.



}


class VelocityTracker {

void addMovement(MotionEvent event);
//Add a user's movement to the tracker.

void clear();
//Reset the velocity tracker back to its initial state.

void computeCurrentVelocity(int units, float maxVelocity);
//Compute the current velocity based on the points that have been collected.

void computeCurrentVelocity(int units);
//Equivalent to invoking computeCurrentVelocity(int, float); with a maximum velocity of Float.MAX_VALUE.

abstract T getNextPoolable();

float getXVelocity();
//Retrieve the last computed X velocity.

float getXVelocity(int id);
//Retrieve the last computed X velocity.

float getYVelocity(int id);
//Retrieve the last computed Y velocity.

float getYVelocity();
//Retrieve the last computed Y velocity.

abstract boolean isPooled();

static VelocityTracker obtain();
//Retrieve a new VelocityTracker object to watch the velocity of a motion.

void recycle();
//Return a VelocityTracker object back to be re-used by others.

abstract void setNextPoolable(T element);

abstract void setPooled(boolean isPooled);

//Protected Methods
void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

}

class ViewManager{
            void removeView(@Sink(DISPLAY) View arg0);
}
class View {
void addChildrenForAccessibility(ArrayList<View> children);
//Adds the children of a given View for accessibility.

void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

void addFocusables(ArrayList<View> views, int direction);
//Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener);
//Add a listener for attach state changes.

void addOnLayoutChangeListener(View.OnLayoutChangeListener listener);
//Add a listener that will be called when the bounds of the view change due to layout processing.

void addTouchables(ArrayList<View> views);
//Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself); to views.

ViewPropertyAnimator animate();
//This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View.

void announceForAccessibility(CharSequence text);
//Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to make an announcement which is related to some sort of a context change for which none of the events representing UI transitions is a good fit.

void bringToFront();
//Change the view's z order in the tree, so it's on top of other sibling views

void buildDrawingCache();
//Calling this method is equivalent to calling buildDrawingCache(false);.

void buildDrawingCache(boolean autoScale);
//Forces the drawing cache to be built if the drawing cache is invalid.

void buildLayer();
//Forces this view's layer to be created and this view to be rendered into its layer.

boolean callOnClick();
//Directly call any attached OnClickListener.

boolean canScrollHorizontally(int direction);
//Check if this view can be scrolled horizontally in a certain direction.

boolean canScrollVertically(int direction);
//Check if this view can be scrolled vertically in a certain direction.

void cancelLongPress();
//Cancels a pending long press.

boolean checkInputConnectionProxy(View view);
//Called by the InputMethodManager when a view who is not the current input connection target is trying to make a call on the manager.

void clearAnimation();
//Cancels any animations for this view.

void clearFocus();
//Called when this view wants to give up focus.

static int combineMeasuredStates(int curState, int newState);
//Merge two states as returned by getMeasuredState();.

void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

AccessibilityNodeInfo createAccessibilityNodeInfo();
//Returns an AccessibilityNodeInfo representing this view from the point of view of an AccessibilityService.

void createContextMenu(@Sink(DISPLAY) ContextMenu menu);
//Show the context menu for this view.

void destroyDrawingCache();
//Frees the resources used by the drawing cache.

void dispatchConfigurationChanged(Configuration newConfig);
//Dispatch a notification about a resource configuration change down the view hierarchy.

void dispatchDisplayHint(int hint);
//Dispatch a hint about whether this view is displayed.

boolean dispatchDragEvent(DragEvent event);
//Detects if this View is enabled and has a drag event listener.

boolean dispatchGenericMotionEvent(MotionEvent event);
//Dispatch a generic motion event.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

boolean dispatchKeyEventPreIme(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event before it is processed by any input method associated with the view hierarchy.

boolean dispatchKeyShortcutEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatches a key shortcut event.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

void dispatchSystemUiVisibilityChanged(int visibility);
//Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener); down the view hierarchy.

boolean dispatchTouchEvent(MotionEvent event);
//Pass the touch screen motion event down to the target view, or this view if it is the target.

boolean dispatchTrackballEvent(MotionEvent event);
//Pass a trackball motion event down to the focused view.

boolean dispatchUnhandledMove(View focused, int direction);
//This method is the last chance for the focused view and its ancestors to respond to an arrow key.

void dispatchWindowFocusChanged(boolean hasFocus);
//Called when the window containing this view gains or loses window focus.

void dispatchWindowSystemUiVisiblityChanged(int visible);
//Dispatch callbacks to onWindowSystemUiVisibilityChanged(int); down the view hierarchy.

void dispatchWindowVisibilityChanged(int visibility);
//Dispatch a window visibility change down the view hierarchy.

void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

View findFocus();
//Find the view in the hierarchy rooted at this view that currently has focus.

final View findViewById(int id);
//Look for a child view with the given id.

final View findViewWithTag(Object tag);
//Look for a child view with the given tag.

void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags);
//Finds the Views that contain given text.

View focusSearch(int direction);
//Find the nearest view in the specified direction that can take focus.

void forceLayout();
//Forces this view to be laid out during the next layout pass.

static int generateViewId();
//Generate a value suitable for use in setId(int);.

AccessibilityNodeProvider getAccessibilityNodeProvider();
//Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.

float getAlpha();
//The opacity of the view.

Animation getAnimation();
//Get the animation currently associated with this view.

IBinder getApplicationWindowToken();
//Retrieve a unique token identifying the top-level "real" window of the window that this view is attached to.

Drawable getBackground();
//Gets the background drawable

int getBaseline();
//Return the offset of the widget's text baseline from the widget's top boundary.

final int getBottom();
//Bottom position of this view relative to its parent.

float getCameraDistance();
//Gets the distance along the Z axis from the camera to this view.

CharSequence getContentDescription();
//Gets the View description.

final Context getContext();
//Returns the context the view is running in, through which it can access the current theme, resources, etc.

static int getDefaultSize(int size, int measureSpec);
//Utility to return a default size.

Display getDisplay();
//Gets the logical display to which the view's window has been attached.

final int[] getDrawableState();
//Return an array of resource IDs of the drawable states representing the current state of the view.

Bitmap getDrawingCache(boolean autoScale);
//Returns the bitmap in which this view drawing is cached.

Bitmap getDrawingCache();
//Calling this method is equivalent to calling getDrawingCache(false);.

int getDrawingCacheBackgroundColor();

int getDrawingCacheQuality();
//Returns the quality of the drawing cache.

void getDrawingRect(Rect outRect);
//Return the visible drawing bounds of your view.

long getDrawingTime();
//Return the time at which the drawing of the view hierarchy started.

boolean getFilterTouchesWhenObscured();
//Gets whether the framework should discard touches when the view's window is obscured by another visible window.

boolean getFitsSystemWindows();
//Check for state of If this method returns true, the default implementation of {@link #fitSystemWindows(Rect); will be executed.

ArrayList<View> getFocusables(int direction);
//Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself.

void getFocusedRect(Rect r);
//When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.

boolean getGlobalVisibleRect(Rect r, Point globalOffset);
//If some part of this view is not clipped by any of its parents, then return that area in r in global (root); coordinates.

final boolean getGlobalVisibleRect(Rect r);

Handler getHandler();

final int getHeight();
//Return the height of your view.

void getHitRect(Rect outRect);
//Hit rectangle in parent's coordinates

int getHorizontalFadingEdgeLength();
//Returns the size of the horizontal faded edges used to indicate that more content in this view is visible.

int getId();
//Returns this view's identifier.

int getImportantForAccessibility();
//Gets the mode for determining whether this View is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.

boolean getKeepScreenOn();
//Returns whether the screen should remain on, corresponding to the current value of KEEP_SCREEN_ON.

KeyEvent.DispatcherState getKeyDispatcherState();
//Return the global KeyEvent.DispatcherState for this view's window.

int getLabelFor();
//Gets the id of a view for which this view serves as a label for accessibility purposes.

int getLayerType();
//Indicates what type of layer is currently associated with this view.

int getLayoutDirection();
//Returns the resolved layout direction for this view.

ViewGroup.LayoutParams getLayoutParams();
//Get the LayoutParams associated with this view.

final int getLeft();
//Left position of this view relative to its parent.

final boolean getLocalVisibleRect(Rect r);

void getLocationInWindow(int[] location);
//Computes the coordinates of this view in its window.

void getLocationOnScreen(int[] location);
//Computes the coordinates of this view on the screen.

Matrix getMatrix();
//The transform matrix of this view, which is calculated based on the current roation, scale, and pivot properties.

final int getMeasuredHeight();
//Like getMeasuredHeightAndState();, but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK);.

final int getMeasuredHeightAndState();
//Return the full height measurement information for this view as computed by the most recent call to measure(int, int);.

final int getMeasuredState();
//Return only the state bits of getMeasuredWidthAndState(); and getMeasuredHeightAndState();, combined into one integer.

final int getMeasuredWidth();
//Like getMeasuredWidthAndState();, but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK);.

final int getMeasuredWidthAndState();
//Return the full width measurement information for this view as computed by the most recent call to measure(int, int);.

int getMinimumHeight();
//Returns the minimum height of the view.

int getMinimumWidth();
//Returns the minimum width of the view.

int getNextFocusDownId();
//Gets the id of the view to use when the next focus is FOCUS_DOWN.

int getNextFocusForwardId();
//Gets the id of the view to use when the next focus is FOCUS_FORWARD.

int getNextFocusLeftId();
//Gets the id of the view to use when the next focus is FOCUS_LEFT.

int getNextFocusRightId();
//Gets the id of the view to use when the next focus is FOCUS_RIGHT.

int getNextFocusUpId();
//Gets the id of the view to use when the next focus is FOCUS_UP.

View.OnFocusChangeListener getOnFocusChangeListener();
//Returns the focus-change callback registered for this view.

int getOverScrollMode();
//Returns the over-scroll mode for this view.

int getPaddingBottom();
//Returns the bottom padding of this view.

int getPaddingEnd();
//Returns the end padding of this view depending on its resolved layout direction.

int getPaddingLeft();
//Returns the left padding of this view.

int getPaddingRight();
//Returns the right padding of this view.

int getPaddingStart();
//Returns the start padding of this view depending on its resolved layout direction.

int getPaddingTop();
//Returns the top padding of this view.

final ViewParent getParent();
//Gets the parent of this view.

ViewParent getParentForAccessibility();
//Gets the parent for accessibility purposes.

float getPivotX();
//The x location of the point around which the view is rotated and scaled.

float getPivotY();
//The y location of the point around which the view is rotated and scaled.

Resources getResources();
//Returns the resources associated with this view.

final int getRight();
//Right position of this view relative to its parent.

View getRootView();
//Finds the topmost view in the current view hierarchy.

float getRotation();
//The degrees that the view is rotated around the pivot point.

float getRotationX();
//The degrees that the view is rotated around the horizontal axis through the pivot point.

float getRotationY();
//The degrees that the view is rotated around the vertical axis through the pivot point.

float getScaleX();
//The amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width.

float getScaleY();
//The amount that the view is scaled in y around the pivot point, as a proportion of the view's unscaled height.

int getScrollBarDefaultDelayBeforeFade();
//Returns the delay before scrollbars fade.

int getScrollBarFadeDuration();
//Returns the scrollbar fade duration.

int getScrollBarSize();
//Returns the scrollbar size.

int getScrollBarStyle();
//Returns the current scrollbar style.

final int getScrollX();
//Return the scrolled left position of this view.

final int getScrollY();
//Return the scrolled top position of this view.

int getSolidColor();
//Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.

int getSystemUiVisibility();
//Returns the last {@link #setSystemUiVisibility(int); that this view has requested.

Object getTag(int key);
//Returns the tag associated with this view and the specified key.

Object getTag();
//Returns this view's tag.

int getTextAlignment();
//Return the resolved text alignment.

int getTextDirection();
//Return the resolved text direction.

final int getTop();
//Top position of this view relative to its parent.

TouchDelegate getTouchDelegate();
//Gets the TouchDelegate for this View.

ArrayList<View> getTouchables();
//Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself.

float getTranslationX();
//The horizontal location of this view relative to its left position.

float getTranslationY();
//The horizontal location of this view relative to its top position.

int getVerticalFadingEdgeLength();
//Returns the size of the vertical faded edges used to indicate that more content in this view is visible.

int getVerticalScrollbarPosition();

int getVerticalScrollbarWidth();
//Returns the width of the vertical scrollbar.

ViewTreeObserver getViewTreeObserver();
//Returns the ViewTreeObserver for this view's hierarchy.

int getVisibility();
//Returns the visibility status for this view.

final int getWidth();
//Return the width of the your view.

int getWindowSystemUiVisibility();
//Returns the current system UI visibility that is currently set for the entire window.

IBinder getWindowToken();
//Retrieve a unique token identifying the window this view is attached to.

int getWindowVisibility();
//Returns the current visibility of the window this view is attached to (either GONE, INVISIBLE, or VISIBLE);.

void getWindowVisibleDisplayFrame(Rect outRect);
//Retrieve the overall visible display size in which the window this view is attached to has been positioned in.

float getX();
//The visual x position of this view, in pixels.

float getY();
//The visual y position of this view, in pixels.

boolean hasFocus();
//Returns true if this view has focus iteself, or is the ancestor of the view that has focus.

boolean hasFocusable();
//Returns true if this view is focusable or if it contains a reachable View for which hasFocusable(); returns true.

boolean hasOnClickListeners();
//Return whether this view has an attached OnClickListener.

boolean hasOverlappingRendering();
//Returns whether this View has content which overlaps.

boolean hasTransientState();
//Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible.

boolean hasWindowFocus();
//Returns true if this view is in a window that currently has window focus.

static View inflate(Context context, int resource, ViewGroup root);
//Inflate a view from an XML resource.

void invalidate(Rect dirty);
//Mark the area defined by dirty as needing to be drawn.

void invalidate(int l, int t, int r, int b);
//Mark the area defined by the rect (l,t,r,b); as needing to be drawn.

void invalidate();
//Invalidate the whole view.

void invalidateDrawable(Drawable drawable);
//Invalidates the specified Drawable.

boolean isActivated();
//Indicates the activation state of this view.

boolean isClickable();
//Indicates whether this view reacts to click events or not.

boolean isDirty();
//True if this view has changed since the last time being drawn.

boolean isDrawingCacheEnabled();
//Indicates whether the drawing cache is enabled for this view.

boolean isDuplicateParentStateEnabled();
//Indicates whether this duplicates its drawable state from its parent.

boolean isEnabled();
//Returns the enabled status for this view.

final boolean isFocusable();
//Returns whether this View is able to take focus.

final boolean isFocusableInTouchMode();
//When a view is focusable, it may not want to take focus when in touch mode.

boolean isFocused();
//Returns true if this view has focus

boolean isHapticFeedbackEnabled();

boolean isHardwareAccelerated();
//Indicates whether this view is attached to a hardware accelerated window or not.

boolean isHorizontalFadingEdgeEnabled();
//Indicate whether the horizontal edges are faded when the view is scrolled horizontally.

boolean isHorizontalScrollBarEnabled();
//Indicate whether the horizontal scrollbar should be drawn or not.

boolean isHovered();
//Returns true if the view is currently hovered.

boolean isInEditMode();
//Indicates whether this View is currently in edit mode.

boolean isInTouchMode();
//Returns whether the device is currently in touch mode.

boolean isLayoutRequested();
//Indicates whether or not this view's layout will be requested during the next hierarchy layout pass.

boolean isLongClickable();
//Indicates whether this view reacts to long click events or not.

boolean isOpaque();
//Indicates whether this View is opaque.

boolean isPaddingRelative();
//Return if the padding as been set thru relative values setPaddingRelative(int, int, int, int); or thru

boolean isPressed();
//Indicates whether the view is currently in pressed state.

boolean isSaveEnabled();
//Indicates whether this view will save its state (that is, whether its onSaveInstanceState(); method will be called);.

boolean isSaveFromParentEnabled();
//Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.

boolean isScrollContainer();
//Indicates whether this view is one of the set of scrollable containers in its window.

boolean isScrollbarFadingEnabled();
//Returns true if scrollbars will fade when this view is not scrolling

boolean isSelected();
//Indicates the selection state of this view.

boolean isShown();
//Returns the visibility of this view and all of its ancestors

boolean isSoundEffectsEnabled();

boolean isVerticalFadingEdgeEnabled();
//Indicate whether the vertical edges are faded when the view is scrolled horizontally.

boolean isVerticalScrollBarEnabled();
//Indicate whether the vertical scrollbar should be drawn or not.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

void layout(int l, int t, int r, int b);
//Assign a size and position to a view and all of its descendants
//This is the second phase of the layout mechanism.

final void measure(int widthMeasureSpec, int heightMeasureSpec);
//This is called to find out how big a view should be.

void offsetLeftAndRight(int offset);
//Offset this view's horizontal location by the specified amount of pixels.

void offsetTopAndBottom(int offset);
//Offset this view's vertical location by the specified number of pixels.

boolean onCheckIsTextEditor();
//Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it.

InputConnection onCreateInputConnection(EditorInfo outAttrs);
//Create a new InputConnection for an InputMethod to interact with the view.

boolean onDragEvent(DragEvent event);
//Handles drag events sent by the system following a call to startDrag();.

boolean onFilterTouchEventForSecurity(MotionEvent event);
//Filter the touch event to apply security policies.

void onFinishTemporaryDetach();
//Called after onStartTemporaryDetach(); when the container is done changing the view.

boolean onGenericMotionEvent(MotionEvent event);
//Implement this method to handle generic motion events.

void onHoverChanged(boolean hovered);
//Implement this method to handle hover state changes.

boolean onHoverEvent(MotionEvent event);
//Implement this method to handle hover events.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onKeyLongPress(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyLongPress();: always returns false (doesn't handle the event);.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyPreIme(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Handle a key event before it is processed by any input method associated with the view hierarchy.

boolean onKeyShortcut(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called on the focused view when a key shortcut event is not handled.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyUp();: perform clicking of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

void onRtlPropertiesChanged(int layoutDirection);
//Called when any RTL property (layout direction or text direction or text alignment); has been changed.

void onScreenStateChanged(int screenState);
//This method is called whenever the state of the screen this view is attached to changes.

void onStartTemporaryDetach();
//This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.

boolean onTrackballEvent(MotionEvent event);
//Implement this method to handle trackball motion events.

void onWindowFocusChanged(boolean hasWindowFocus);
//Called when the window containing this view gains or loses focus.

void onWindowSystemUiVisibilityChanged(int visible);
//Override to find out when the window's requested system UI visibility has changed, that is the value returned by getWindowSystemUiVisibility();.

boolean performAccessibilityAction(int action, Bundle arguments);
//Performs the specified accessibility action on the view.

boolean performClick();
//Call this view's OnClickListener, if it is defined.

boolean performHapticFeedback(@Sink(VIBRATE) int feedbackConstant);
//BZZZTT!!1!
//Provide haptic feedback to the user for this view.

boolean performHapticFeedback(@Sink(VIBRATE) int feedbackConstant, int flags);
//BZZZTT!!1!
//Like performHapticFeedback(int);, with additional options.

boolean performLongClick();
//Call this view's OnLongClickListener, if it is defined.

void playSoundEffect(int soundConstant);
//Play a sound effect for this view.

boolean post(Runnable action);
//Causes the Runnable to be added to the message queue.

boolean postDelayed(Runnable action, long delayMillis);
//Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses.

void postInvalidate(int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.

void postInvalidate();
//Cause an invalidate to happen on a subsequent cycle through the event loop.

void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.

void postInvalidateDelayed(long delayMilliseconds);
//Cause an invalidate to happen on a subsequent cycle through the event loop.

void postInvalidateOnAnimation(int left, int top, int right, int bottom);
//Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame.

void postInvalidateOnAnimation();
//Cause an invalidate to happen on the next animation time step, typically the next display frame.

void postOnAnimation(Runnable action);
//Causes the Runnable to execute on the next animation time step.

void postOnAnimationDelayed(Runnable action, long delayMillis);
//Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses.

void refreshDrawableState();
//Call this to force a view to update its drawable state.

boolean removeCallbacks(Runnable action);
//Removes the specified Runnable from the message queue.

void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener);
//Remove a listener for attach state changes.

void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener);
//Remove a listener for layout changes.

void requestFitSystemWindows();
//Ask that a new dispatch of fitSystemWindows(Rect); be performed.

boolean requestFocus(int direction, Rect previouslyFocusedRect);
//Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from.

final boolean requestFocus(int direction);
//Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading.

final boolean requestFocus();
//Call this to try to give focus to a specific view or to one of its descendants.

final boolean requestFocusFromTouch();
//Call this to try to give focus to a specific view or to one of its descendants.

void requestLayout();
//Call this when something has changed which has invalidated the layout of this view.

boolean requestRectangleOnScreen(Rect rectangle);
//Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.

boolean requestRectangleOnScreen(Rect rectangle, boolean immediate);
//Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.

static int resolveSize(int size, int measureSpec);
//Version of resolveSizeAndState(int, int, int); returning only the MEASURED_SIZE_MASK bits of the result.

static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState);
//Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec.

void restoreHierarchyState(SparseArray<Parcelable> container);
//Restore this view hierarchy's frozen state from the given container.

void saveHierarchyState(SparseArray<Parcelable> container);
//Store this view hierarchy's frozen state into the given container.

void scheduleDrawable(Drawable who, Runnable what, long when);
//Schedules an action on a drawable to occur at a specified time.

void scrollBy(int x, int y);
//Move the scrolled position of your view.

void scrollTo(int x, int y);
//Set the scrolled position of your view.

void sendAccessibilityEvent(int eventType);
//Sends an accessibility event of the given type.

void sendAccessibilityEventUnchecked(AccessibilityEvent event);
//This method behaves exactly as sendAccessibilityEvent(int); but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled.

void setAccessibilityDelegate(View.AccessibilityDelegate delegate);
//Sets a delegate for implementing accessibility support via composition as opposed to inheritance.

void setActivated(boolean activated);
//Changes the activated state of this view.

void setAlpha(float alpha);
//Sets the opacity of the view.

void setAnimation(@Sink(DISPLAY) Animation animation);
//Sets the next animation to play for this view.

void setBackground(@Sink(DISPLAY) Drawable background);
//Set the background to a given Drawable, or remove the background.

void setBackgroundColor(int color);
//Sets the background color for this view.

void setBackgroundDrawable(@Sink(DISPLAY) Drawable background);
//This method was deprecated in API level 16. use setBackground(Drawable); instead

void setBackgroundResource(int resid);
//Set the background to a given resource.

final void setBottom(int bottom);
//Sets the bottom position of this view relative to its parent.

void setCameraDistance(float distance);
//Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn); from the camera to this view.

void setClickable(boolean clickable);
//Enables or disables click events for this view.

void setContentDescription(CharSequence contentDescription);
//Sets the View description.

void setDrawingCacheBackgroundColor(int color);
//Setting a solid background color for the drawing cache's bitmaps will improve performance and memory usage.

void setDrawingCacheEnabled(boolean enabled);
//Enables or disables the drawing cache.

void setDrawingCacheQuality(int quality);
//Set the drawing cache quality of this view.

void setDuplicateParentStateEnabled(boolean enabled);
//Enables or disables the duplication of the parent's state into this view.

void setEnabled(@Sink(DISPLAY) boolean enabled);
//Set the enabled state of this view.

void setFadingEdgeLength(int length);
//Set the size of the faded edge used to indicate that more content in this view is available.

void setFilterTouchesWhenObscured(boolean enabled);
//Sets whether the framework should discard touches when the view's window is obscured by another visible window.

void setFitsSystemWindows(boolean fitSystemWindows);
//Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(Rect); will be executed.

void setFocusable(boolean focusable);
//Set whether this view can receive the focus.

void setFocusableInTouchMode(boolean focusableInTouchMode);
//Set whether this view can receive focus while in touch mode.

void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled);
//Set whether this view should have haptic feedback for events such as long presses.

void setHasTransientState(boolean hasTransientState);
//Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible.

void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled);
//Define whether the horizontal edges should be faded when this view is scrolled horizontally.

void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled);
//Define whether the horizontal scrollbar should be drawn or not.

void setHovered(boolean hovered);
//Sets whether the view is currently hovered.

void setId(int id);
//Sets the identifier for this view.

void setImportantForAccessibility(int mode);
//Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.

void setKeepScreenOn(boolean keepScreenOn);
//Controls whether the screen should remain on, modifying the value of KEEP_SCREEN_ON.

void setLabelFor(int id);
//Sets the id of a view for which this view serves as a label for accessibility purposes.

void setLayerPaint(Paint paint);
//Updates the Paint object used with the current layer (used only if the current layer type is not set to LAYER_TYPE_NONE);.

void setLayerType(int layerType, Paint paint);
//Specifies the type of layer backing this view.

void setLayoutDirection(int layoutDirection);
//Set the layout direction for this view.

void setLayoutParams(ViewGroup.LayoutParams params);
//Set the layout parameters associated with this view.

final void setLeft(int left);
//Sets the left position of this view relative to its parent.

void setLongClickable(boolean longClickable);
//Enables or disables long click events for this view.

void setMinimumHeight(int minHeight);
//Sets the minimum height of the view.

void setMinimumWidth(int minWidth);
//Sets the minimum width of the view.

void setNextFocusDownId(int nextFocusDownId);
//Sets the id of the view to use when the next focus is FOCUS_DOWN.

void setNextFocusForwardId(int nextFocusForwardId);
//Sets the id of the view to use when the next focus is FOCUS_FORWARD.

void setNextFocusLeftId(int nextFocusLeftId);
//Sets the id of the view to use when the next focus is FOCUS_LEFT.

void setNextFocusRightId(int nextFocusRightId);
//Sets the id of the view to use when the next focus is FOCUS_RIGHT.

void setNextFocusUpId(int nextFocusUpId);
//Sets the id of the view to use when the next focus is FOCUS_UP.

void setOnClickListener(View.OnClickListener l);
//Register a callback to be invoked when this view is clicked.

void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l);
//Register a callback to be invoked when the context menu for this view is being built.

void setOnDragListener(View.OnDragListener l);
//Register a drag event listener callback object for this View.

void setOnFocusChangeListener(View.OnFocusChangeListener l);
//Register a callback to be invoked when focus of this view changed.

void setOnGenericMotionListener(View.OnGenericMotionListener l);
//Register a callback to be invoked when a generic motion event is sent to this view.

void setOnHoverListener(View.OnHoverListener l);
//Register a callback to be invoked when a hover event is sent to this view.

void setOnKeyListener(View.OnKeyListener l);
//Register a callback to be invoked when a hardware key is pressed in this view.

void setOnLongClickListener(View.OnLongClickListener l);
//Register a callback to be invoked when this view is clicked and held.

void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l);
//Set a listener to receive callbacks when the visibility of the system bar changes.

void setOnTouchListener(View.OnTouchListener l);
//Register a callback to be invoked when a touch event is sent to this view.

void setOverScrollMode(int overScrollMode);
//Set the over-scroll mode for this view.

void setPadding(int left, int top, int right, int bottom);
//Sets the padding.

void setPaddingRelative(int start, int top, int end, int bottom);
//Sets the relative padding.

void setPivotX(float pivotX);
//Sets the x location of the point around which the view is rotated and scaled.

void setPivotY(float pivotY);
//Sets the y location of the point around which the view is rotated and scaled.

void setPressed(boolean pressed);
//Sets the pressed state for this view.

final void setRight(int right);
//Sets the right position of this view relative to its parent.

void setRotation(float rotation);
//Sets the degrees that the view is rotated around the pivot point.

void setRotationX(float rotationX);
//Sets the degrees that the view is rotated around the horizontal axis through the pivot point.

void setRotationY(float rotationY);
//Sets the degrees that the view is rotated around the vertical axis through the pivot point.

void setSaveEnabled(boolean enabled);
//Controls whether the saving of this view's state is enabled (that is, whether its onSaveInstanceState(); method will be called);.

void setSaveFromParentEnabled(boolean enabled);
//Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.

void setScaleX(float scaleX);
//Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width.

void setScaleY(float scaleY);
//Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view's unscaled width.

void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade);
//Define the delay before scrollbars fade.

void setScrollBarFadeDuration(int scrollBarFadeDuration);
//Define the scrollbar fade duration.

void setScrollBarSize(int scrollBarSize);
//Define the scrollbar size.

void setScrollBarStyle(int style);
//Specify the style of the scrollbars.

void setScrollContainer(boolean isScrollContainer);
//Change whether this view is one of the set of scrollable containers in its window.

void setScrollX(int value);
//Set the horizontal scrolled position of your view.

void setScrollY(int value);
//Set the vertical scrolled position of your view.

void setScrollbarFadingEnabled(boolean fadeScrollbars);
//Define whether scrollbars will fade when the view is not scrolling.

void setSelected(boolean selected);
//Changes the selection state of this view.

void setSoundEffectsEnabled(boolean soundEffectsEnabled);
//Set whether this view should have sound effects enabled for events such as clicking and touching.

void setSystemUiVisibility(int visibility);
//Request that the visibility of the status bar or other screen/window decorations be changed.

void setTag(int key, Object tag);
//Sets a tag associated with this view and a key.

void setTag(Object tag);
//Sets the tag associated with this view.

void setTextAlignment(int textAlignment);
//Set the text alignment.

void setTextDirection(int textDirection);
//Set the text direction.

final void setTop(int top);
//Sets the top position of this view relative to its parent.

void setTouchDelegate(TouchDelegate delegate);
//Sets the TouchDelegate for this View.

void setTranslationX(float translationX);
//Sets the horizontal location of this view relative to its left position.

void setTranslationY(float translationY);
//Sets the vertical location of this view relative to its top position.

void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled);
//Define whether the vertical edges should be faded when this view is scrolled vertically.

void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled);
//Define whether the vertical scrollbar should be drawn or not.

void setVerticalScrollbarPosition(int position);
//Set the position of the vertical scroll bar.

void setVisibility(int visibility);
//Set the enabled state of this view.

void setWillNotCacheDrawing(boolean willNotCacheDrawing);
//When a View's drawing cache is enabled, drawing is redirected to an offscreen bitmap.

void setWillNotDraw(boolean willNotDraw);
//If this view doesn't do any drawing on its own, set this flag to allow further optimizations.

void setX(float x);
//Sets the visual x position of this view, in pixels.

void setY(float y);
//Sets the visual y position of this view, in pixels.

boolean showContextMenu();
//Bring up the context menu for this view.

ActionMode startActionMode(ActionMode.Callback callback);
//Start an action mode.

void startAnimation(@Sink(DISPLAY) Animation animation);
//Start the specified animation now.

final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags);
//Starts a drag and drop operation.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void unscheduleDrawable(Drawable who);
//Unschedule any events associated with the given Drawable.

void unscheduleDrawable(Drawable who, Runnable what);
//Cancels a scheduled action on a drawable.

boolean willNotCacheDrawing();
//Returns whether or not this View can cache its drawing or not.

boolean willNotDraw();
//Returns whether or not this View draws on its own.

//Protected Methods
boolean awakenScrollBars(int startDelay);
//Trigger the scrollbars to draw.

boolean awakenScrollBars(int startDelay, boolean invalidate);
//Trigger the scrollbars to draw.

boolean awakenScrollBars();
//Trigger the scrollbars to draw.

int computeHorizontalScrollExtent();
//Compute the horizontal extent of the horizontal scrollbar's thumb within the horizontal range.

int computeHorizontalScrollOffset();
//Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range.

int computeHorizontalScrollRange();
//Compute the horizontal range that the horizontal scrollbar represents.

int computeVerticalScrollExtent();
//Compute the vertical extent of the horizontal scrollbar's thumb within the vertical range.

int computeVerticalScrollOffset();
//Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range.

int computeVerticalScrollRange();
//Compute the vertical range that the vertical scrollbar represents.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

boolean dispatchGenericFocusedEvent(MotionEvent event);
//Dispatch a generic motion event to the currently focused view.

boolean dispatchGenericPointerEvent(MotionEvent event);
//Dispatch a generic motion event to the view under the first pointer.

boolean dispatchHoverEvent(MotionEvent event);
//Dispatch a hover event.

void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
//Called by restoreHierarchyState(android.util.SparseArray); to retrieve the state for this view and its children.

void dispatchSaveInstanceState(SparseArray<Parcelable> container);
//Called by saveHierarchyState(android.util.SparseArray); to store the state for this view and its children.

void dispatchSetActivated(boolean activated);
//Dispatch setActivated to all of this View's children.

void dispatchSetPressed(boolean pressed);
//Dispatch setPressed to all of this View's children.

void dispatchSetSelected(boolean selected);
//Dispatch setSelected to all of this View's children.

void dispatchVisibilityChanged(View changedView, int visibility);
//Dispatch a view visibility change down the view hierarchy.

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

boolean fitSystemWindows(Rect insets);
//Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows.

float getBottomFadingEdgeStrength();
//Returns the strength, or intensity, of the bottom faded edge.

int getBottomPaddingOffset();
//Amount by which to extend the bottom fading region.

ContextMenu.ContextMenuInfo getContextMenuInfo();
//Views should implement this if they have extra information to associate with the context menu.

int getHorizontalScrollbarHeight();
//Returns the height of the horizontal scrollbar.

float getLeftFadingEdgeStrength();
//Returns the strength, or intensity, of the left faded edge.

int getLeftPaddingOffset();
//Amount by which to extend the left fading region.

float getRightFadingEdgeStrength();
//Returns the strength, or intensity, of the right faded edge.

int getRightPaddingOffset();
//Amount by which to extend the right fading region.

int getSuggestedMinimumHeight();
//Returns the suggested minimum height that the view should use.

int getSuggestedMinimumWidth();
//Returns the suggested minimum width that the view should use.

float getTopFadingEdgeStrength();
//Returns the strength, or intensity, of the top faded edge.

int getTopPaddingOffset();
//Amount by which to extend the top fading region.

int getWindowAttachCount();

void initializeFadingEdge(TypedArray a);
//Initializes the fading edges from a given set of styled attributes.

void initializeScrollbars(TypedArray a);
//Initializes the scrollbars from a given set of styled attributes.

boolean isPaddingOffsetRequired();
//If the View draws content inside its padding and enables fading edges, it needs to support padding offsets.

static int[] mergeDrawableStates(int[] baseState, int[] additionalState);
//Merge your own state values in additionalState into the base state values baseState that were returned by onCreateDrawableState(int);.

void onAnimationEnd();
//Invoked by a parent ViewGroup to notify the end of the animation currently associated with this view.

void onAnimationStart();
//Invoked by a parent ViewGroup to notify the start of the animation currently associated with this view.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onConfigurationChanged(Configuration newConfig);
//Called when the current configuration of the resources being used by the application have changed.

void onCreateContextMenu(ContextMenu menu);
//Views should implement this if the view itself is going to add items to the context menu.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDisplayHint(int hint);
//Gives this view a hint about whether is displayed or not.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

final void onDrawScrollBars(Canvas canvas);
//Request the drawing of the horizontal and the vertical scrollbar.

void onFinishInflate();
//Finalize inflating a view from XML.

void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect);
//Called by the view system when the focus state of this view changes.

void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY);
//Called by overScrollBy(int, int, int, int, int, int, int, int, boolean); to respond to the results of an over-scroll operation.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

void onScrollChanged(int l, int t, int oldl, int oldt);
//This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents);.

boolean onSetAlpha(int alpha);
//Invoked if there is a Transform that involves alpha.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

void onVisibilityChanged(View changedView, int visibility);
//Called when the visibility of the view or an ancestor of the view is changed.

void onWindowVisibilityChanged(int visibility);
//Called when the window containing has change its visibility (between GONE, INVISIBLE, and VISIBLE);.

boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent);
//Scroll the view with standard behavior for scrolling beyond the normal content boundaries.

final void setMeasuredDimension(int measuredWidth, int measuredHeight);
//This mehod must be called by onMeasure(int, int); to store the measured width and measured height.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.

}
class View$BaseSavedState{
        BaseSavedState(Parcelable superState);
        BaseSavedState(Parcel source);
}
class View$MeasureSpec {
    
static int getMode(int measureSpec);
//Extracts the mode from the supplied measure specification.

static int getSize(int measureSpec);
//Extracts the size from the supplied measure specification.

static int makeMeasureSpec(int size, int mode);
//Creates a measure specification based on the supplied size and mode.

static String toString(int measureSpec);
//Returns a String representation of the specified measure specification.



}
class View$AccessibilityDelegate{
        boolean onRequestSendAccessibilityEvent(ViewGroup host, View child, AccessibilityEvent event);
        void onPopulateAccessibilityEvent(View host, AccessibilityEvent event);
        AccessibilityDelegate();
        void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfo info);
        void onInitializeAccessibilityEvent(View host, AccessibilityEvent event);
        boolean dispatchPopulateAccessibilityEvent(View host, AccessibilityEvent event);
        void sendAccessibilityEventUnchecked(View host, AccessibilityEvent event);
        void sendAccessibilityEvent(View host, int eventType);
}

class View$OnClickListener{
        void onClick(View arg0);
}

class View$OnCreateContextMenuListener{
        void onCreateContextMenu(ContextMenu arg0, View arg1, ContextMenuInfo arg2);
}


class View$OnTouchListener{
        boolean onTouch(View arg0, MotionEvent arg1);
}

class ViewConfiguration {
    
static ViewConfiguration get(Context context);
//Returns a configuration for the specified context.

static int getDoubleTapTimeout();

static int getEdgeSlop();
//This method was deprecated in API level 3. Use getScaledEdgeSlop(); instead.

static int getFadingEdgeLength();
//This method was deprecated in API level 3. Use getScaledFadingEdgeLength(); instead.

static long getGlobalActionKeyTimeout();
//The amount of time a user needs to press the relevant key to bring up the global actions dialog.

static int getJumpTapTimeout();

static int getKeyRepeatDelay();

static int getKeyRepeatTimeout();

static int getLongPressTimeout();

static int getMaximumDrawingCacheSize();
//This method was deprecated in API level 3. Use getScaledMaximumDrawingCacheSize(); instead.

static int getMaximumFlingVelocity();
//This method was deprecated in API level 4. Use getScaledMaximumFlingVelocity(); instead.

static int getMinimumFlingVelocity();
//This method was deprecated in API level 3. Use getScaledMinimumFlingVelocity(); instead.

static int getPressedStateDuration();

int getScaledDoubleTapSlop();

int getScaledEdgeSlop();

int getScaledFadingEdgeLength();

int getScaledMaximumDrawingCacheSize();
//The maximum drawing cache size expressed in bytes.

int getScaledMaximumFlingVelocity();

int getScaledMinimumFlingVelocity();

int getScaledOverflingDistance();

int getScaledOverscrollDistance();

int getScaledPagingTouchSlop();

int getScaledScrollBarSize();

int getScaledTouchSlop();

int getScaledWindowTouchSlop();

static int getScrollBarFadeDuration();

static int getScrollBarSize();
//This method was deprecated in API level 3. Use getScaledScrollBarSize(); instead.

static int getScrollDefaultDelay();

static float getScrollFriction();
//The amount of friction applied to scrolls and flings.

static int getTapTimeout();

static int getTouchSlop();
//This method was deprecated in API level 3. Use getScaledTouchSlop(); instead.

static int getWindowTouchSlop();
//This method was deprecated in API level 3. Use getScaledWindowTouchSlop(); instead.

static long getZoomControlsTimeout();
//The amount of time that the zoom controls should be displayed on the screen expressed in milliseconds.

boolean hasPermanentMenuKey();
//Report if the device has a permanent menu key available to the user.

    
}

class ViewGroup$MarginLayoutParams{
        MarginLayoutParams(Context c, AttributeSet attrs);
        MarginLayoutParams(int width, int height);
        MarginLayoutParams(MarginLayoutParams source);
        MarginLayoutParams(LayoutParams source);
}
class ViewGroup$LayoutParams {
    
void resolveLayoutDirection(int layoutDirection);
//Resolve layout parameters depending on the layout direction.

//Protected Methods
void setBaseAttributes(TypedArray a, int widthAttr, int heightAttr);
//Extracts the layout parameters from the supplied attributes.



}

class ViewGroup {
addChildrenForAccessibility(ArrayList<View> childrenForAccessibility);
//Adds the children of a given View for accessibility.

void addFocusables(ArrayList<View> views, int direction, int focusableMode);
//Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself); to views.

boolean addStatesFromChildren();
//Returns whether this ViewGroup's drawable states also include its children's drawable states.

void addTouchables(ArrayList<View> views);
//Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself); to views.

void addView(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

void addView(@Sink(DISPLAY) View child, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

void addView(@Sink(DISPLAY) View child, int index);
//Adds a child view.

void addView(@Sink(DISPLAY) View child);
//Adds a child view.

void addView(@Sink(DISPLAY) View child, int width, int height);
//Adds a child view with this ViewGroup's default layout parameters and the specified width and height.

void bringChildToFront(@Sink(DISPLAY) View child);
//Change the z order of the child so it's on top of all other children

void childDrawableStateChanged(View child);
//If addStatesFromChildren(); is true, refreshes this group's drawable state (to include the states from its children);.

void clearChildFocus(View child);
//Called when a child of this parent is giving up focus

void clearDisappearingChildren();
//Removes any pending animations for views that have been removed.

void clearFocus();
//Called when this view wants to give up focus.

void dispatchConfigurationChanged(Configuration newConfig);
//Dispatch a notification about a resource configuration change down the view hierarchy.

void dispatchDisplayHint(int hint);
//Dispatch a hint about whether this view is displayed.

boolean dispatchDragEvent(DragEvent event);
//Detects if this View is enabled and has a drag event listener.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

boolean dispatchKeyEventPreIme(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event before it is processed by any input method associated with the view hierarchy.

boolean dispatchKeyShortcutEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatches a key shortcut event.

void dispatchSetActivated(boolean activated);
//Dispatch setActivated to all of this View's children.

void dispatchSetSelected(boolean selected);
//Dispatch setSelected to all of this View's children.

void dispatchSystemUiVisibilityChanged(int visible);
//Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener); down the view hierarchy.

boolean dispatchTouchEvent(MotionEvent ev);
//Pass the touch screen motion event down to the target view, or this view if it is the target.

boolean dispatchTrackballEvent(MotionEvent event);
//Pass a trackball motion event down to the focused view.

boolean dispatchUnhandledMove(View focused, int direction);
//This method is the last chance for the focused view and its ancestors to respond to an arrow key.

void dispatchWindowFocusChanged(boolean hasFocus);
//Called when the window containing this view gains or loses window focus.

void dispatchWindowSystemUiVisiblityChanged(int visible);
//Dispatch callbacks to onWindowSystemUiVisibilityChanged(int); down the view hierarchy.

void dispatchWindowVisibilityChanged(int visibility);
//Dispatch a window visibility change down the view hierarchy.

void endViewTransition(View view);
//This method should always be called following an earlier call to startViewTransition(View);.

View findFocus();
//Find the view in the hierarchy rooted at this view that currently has focus.

void findViewsWithText(ArrayList<View> outViews, CharSequence text, int flags);
//Finds the Views that contain given text.

View focusSearch(View focused, int direction);
//Find the nearest view in the specified direction that wants to take focus.

void focusableViewAvailable(View v);
//Tells the parent that a new focusable view has become available.

boolean gatherTransparentRegion(Region region);
//This is used by the RootView to perform an optimization when the view hierarchy contains one or several SurfaceView.

ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

View getChildAt(int index);
//Returns the view at the specified position in the group.

int getChildCount();
//Returns the number of children in the group.

static int getChildMeasureSpec(int spec, int padding, int childDimension);
//Does the hard part of measureChildren: figuring out the MeasureSpec to pass to a particular child.

boolean getChildVisibleRect(View child, Rect r, Point offset);
//Compute the visible part of a rectangular region defined in terms of a child view's coordinates.

int getDescendantFocusability();
//Gets the descendant focusability of this view group.

View getFocusedChild();
//Returns the focused child of this view, if any.

LayoutAnimationController getLayoutAnimation();
//Returns the layout animation controller used to animate the group's children.

Animation.AnimationListener getLayoutAnimationListener();
//Returns the animation listener to which layout animation events are sent.

LayoutTransition getLayoutTransition();
//Gets the LayoutTransition object for this ViewGroup.

int getPersistentDrawingCache();
//Returns an integer indicating what types of drawing caches are kept in memory.

boolean hasFocus();
//Returns true if this view has or contains focus

boolean hasFocusable();
//Returns true if this view is focusable or if it contains a reachable View for which hasFocusable(); returns true.

int indexOfChild(View child);
//Returns the position in the group of the specified child view.

final void invalidateChild(View child, Rect dirty);
//Don't call or override this method.

ViewParent invalidateChildInParent(int[] location, Rect dirty);
//Don't call or override this method.

boolean isAlwaysDrawnWithCacheEnabled();
//Indicates whether this ViewGroup will always try to draw its children using their drawing cache.

boolean isAnimationCacheEnabled();
//Indicates whether the children's drawing cache is used during a layout animation.

boolean isMotionEventSplittingEnabled();
//Returns true if MotionEvents dispatched to this ViewGroup can be split to multiple children.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

final void layout(int l, int t, int r, int b);
//Assign a size and position to a view and all of its descendants
//This is the second phase of the layout mechanism.

final void offsetDescendantRectToMyCoords(View descendant, Rect rect);
//Offset a rectangle that is in a descendant's coordinate space into our coordinate space.

final void offsetRectIntoDescendantCoords(View descendant, Rect rect);
//Offset a rectangle that is in our coordinate space into an ancestor's coordinate space.

boolean onInterceptHoverEvent(MotionEvent event);
//Implement this method to intercept hover events before they are handled by child views.

boolean onInterceptTouchEvent(MotionEvent ev);
//Implement this method to intercept all touch screen motion events.

boolean onRequestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called when a child has requested sending an AccessibilityEvent and gives an opportunity to its parent to augment the event.

void recomputeViewAttributes(View child);
//Tell view hierarchy that the global view attributes need to be re-evaluated.

void removeAllViews();
//Call this method to remove all child views from the ViewGroup.

void removeAllViewsInLayout();
//Called by a ViewGroup subclass to remove child views from itself, when it must first know its size on screen before it can calculate how many child views it will render.

void removeView(View view);
//Note: do not invoke this method from draw(android.graphics.Canvas);, onDraw(android.graphics.Canvas);, dispatchDraw(android.graphics.Canvas); or any related method.

void removeViewAt(int index);
//Removes the view at the specified position in the group.

void removeViewInLayout(View view);
//Removes a view during layout.

void removeViews(int start, int count);
//Removes the specified range of views from the group.

void removeViewsInLayout(int start, int count);
//Removes a range of views during layout.

void requestChildFocus(View child, View focused);
//Called when a child of this parent wants focus

boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
//Called when a child does not want this parent and its ancestors to intercept touch events with onInterceptTouchEvent(MotionEvent);.

boolean requestFocus(int direction, Rect previouslyFocusedRect);
//Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. Looks for a view to give focus to respecting the setting specified by getDescendantFocusability();.

boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called by a child to request from its parent to send an AccessibilityEvent.

void requestTransparentRegion(View child);
//Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor.

void scheduleLayoutAnimation();
//Schedules the layout animation to be played after the next layout pass of this view group.

void setAddStatesFromChildren(boolean addsStates);
//Sets whether this ViewGroup's drawable states also include its children's drawable states.

void setAlwaysDrawnWithCacheEnabled(boolean always);
//Indicates whether this ViewGroup will always try to draw its children using their drawing cache.

void setAnimationCacheEnabled(boolean enabled);
//Enables or disables the children's drawing cache during a layout animation.

void setClipChildren(boolean clipChildren);
//By default, children are clipped to their bounds before drawing.

void setClipToPadding(boolean clipToPadding);
//By default, children are clipped to the padding of the ViewGroup.

void setDescendantFocusability(int focusability);
//Set the descendant focusability of this view group.

void setLayoutAnimation(LayoutAnimationController controller);
//Sets the layout animation controller used to animate the group's children after the first layout.

void setLayoutAnimationListener(Animation.AnimationListener animationListener);
//Specifies the animation listener to which layout animation events must be sent.

void setLayoutTransition(LayoutTransition transition);
//Sets the LayoutTransition object for this ViewGroup.

void setMotionEventSplittingEnabled(boolean split);
//Enable or disable the splitting of MotionEvents to multiple children during touch event dispatch.

void setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener);
//Register a callback to be invoked when a child is added to or removed from this view.

void setPersistentDrawingCache(int drawingCacheToKeep);
//Indicates what types of drawing caches should be kept in memory after they have been created.

boolean shouldDelayChildPressedState();
//Return true if the pressed state should be delayed for children or descendants of this ViewGroup.

boolean showContextMenuForChild(@Sink(DISPLAY) View originalView);
//Bring up a context menu for the specified view or its ancestors.

ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback);
//Start an action mode for the specified view.

void startLayoutAnimation();
//Runs the layout animation.

void startViewTransition(View view);
//This method tells the ViewGroup that the given View object, which should have this ViewGroup as its parent, should be kept around (re-displayed when the ViewGroup draws its children); even if it is removed from its parent.

void updateViewLayout(View view, ViewGroup.LayoutParams params);

//Protected Methods
boolean addViewInLayout(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params, boolean preventRequestLayout);
//Adds a view during layout.

boolean addViewInLayout(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a view during layout.

void attachLayoutAnimationParameters(View child, ViewGroup.LayoutParams params, int index, int count);
//Subclasses should override this method to set layout animation parameters on the supplied child.

void attachViewToParent(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Attaches a view to this view group.

boolean canAnimate();
//Indicates whether the view group has the ability to animate its children after the first layout.

boolean checkLayoutParams(ViewGroup.LayoutParams p);

void cleanupLayoutState(View child);
//Prevents the specified child to be laid out during the next layout pass.

void debug(int depth);
//Prints information about this view in the log output, with the tag VIEW_LOG_TAG.

void detachAllViewsFromParent();
//Detaches all views from the parent.

void detachViewFromParent(View child);
//Detaches a view from its parent.

void detachViewFromParent(int index);
//Detaches a view from its parent.

void detachViewsFromParent(int start, int count);
//Detaches a range of views from their parents.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

void dispatchFreezeSelfOnly(SparseArray<Parcelable> container);
//Perform dispatching of a saveHierarchyState(android.util.SparseArray); freeze();} to only this view, not to its children.

boolean dispatchGenericFocusedEvent(MotionEvent event);
//Dispatch a generic motion event to the currently focused view.

boolean dispatchGenericPointerEvent(MotionEvent event);
//Dispatch a generic motion event to the view under the first pointer.

boolean dispatchHoverEvent(MotionEvent event);
//Dispatch a hover event.

void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
//Called by restoreHierarchyState(android.util.SparseArray); to retrieve the state for this view and its children.

void dispatchSaveInstanceState(SparseArray<Parcelable> container);
//Called by saveHierarchyState(android.util.SparseArray); to store the state for this view and its children.

void dispatchSetPressed(boolean pressed);
//Dispatch setPressed to all of this View's children.

void dispatchThawSelfOnly(SparseArray<Parcelable> container);
//Perform dispatching of a restoreHierarchyState(android.util.SparseArray); to only this view, not to its children.

void dispatchVisibilityChanged(View changedView, int visibility);
//Dispatch a view visibility change down the view hierarchy.

boolean drawChild(Canvas canvas, @Sink(DISPLAY) View child, long drawingTime);
//Draw one child of this View Group.

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

boolean fitSystemWindows(Rect insets);
//Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows.

ViewGroup.LayoutParams generateDefaultLayoutParams();
//Returns a set of default layout parameters.

ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

int getChildDrawingOrder(int childCount, int i);
//Returns the index of the child to draw for this iteration.

boolean getChildStaticTransformation(View child, Transformation t);
//Sets t to be the static transformation of the child, if set, returning a boolean to indicate whether a static transform was set.

boolean isChildrenDrawingOrderEnabled();
//Indicates whether the ViewGroup is drawing its children in the order defined by getChildDrawingOrder(int, int);.

boolean isChildrenDrawnWithCacheEnabled();
//Indicates whether the ViewGroup is currently drawing its children using their drawing cache.

void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec);
//Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding.

void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed);
//Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins.

void measureChildren(int widthMeasureSpec, int heightMeasureSpec);
//Ask all of the children of this view to measure themselves, taking into account both the MeasureSpec requirements for this view and its padding.

void onAnimationEnd();
//Invoked by a parent ViewGroup to notify the end of the animation currently associated with this view.

void onAnimationStart();
//Invoked by a parent ViewGroup to notify the start of the animation currently associated with this view.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

abstract void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect);
//Look for a descendant to call requestFocus(); on.

void removeDetachedView(View child, boolean animate);
//Finishes the removal of a detached view.

void setChildrenDrawingCacheEnabled(boolean enabled);
//Enables or disables the drawing cache for each child of this view group.

void setChildrenDrawingOrderEnabled(boolean enabled);
//Tells the ViewGroup whether to draw its children in the order defined by the method getChildDrawingOrder(int, int);.

void setChildrenDrawnWithCacheEnabled(boolean enabled);
//Tells the ViewGroup to draw its children using their drawing cache.

void setStaticTransformationsEnabled(boolean enabled);
//When this property is set to true, this ViewGroup supports static transformations on children; this causes getChildStaticTransformation(View, android.view.animation.Transformation); to be invoked when a child is drawn.
}

class ViewParent {
 
//abstract void bringChildToFront(View child);
//Change the z order of the child so it's on top of all other children

//abstract void childDrawableStateChanged(View child);
//This method is called on the parent when a child's drawable state has changed.

//abstract void clearChildFocus(View child);
//Called when a child of this parent is giving up focus

//abstract void createContextMenu(ContextMenu menu);
//Have the parent populate the specified context menu if it has anything to add (and then recurse on its parent);.

//abstract View focusSearch(View v, int direction);
//Find the nearest view in the specified direction that wants to take focus

//abstract void focusableViewAvailable(View v);
//Tells the parent that a new focusable view has become available.

//abstract boolean getChildVisibleRect(View child, Rect r, Point offset);
//Compute the visible part of a rectangular region defined in terms of a child view's coordinates.

//abstract ViewParent getParent();
//Returns the parent if it exists, or null.

//abstract ViewParent getParentForAccessibility();
//Gets the parent of a given View for accessibility.

//abstract void invalidateChild(View child, Rect r);
//All or part of a child is dirty and needs to be redrawn.

//abstract ViewParent invalidateChildInParent(int[] location, Rect r);
//All or part of a child is dirty and needs to be redrawn.

//abstract boolean isLayoutRequested();
//Indicates whether layout was requested on this view parent.

//abstract void recomputeViewAttributes(View child);
//Tell view hierarchy that the global view attributes need to be re-evaluated.

//abstract void requestChildFocus(View child, View focused);
//Called when a child of this parent wants focus

//abstract boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

//abstract void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
//Called when a child does not want this parent and its ancestors to intercept touch events with onInterceptTouchEvent(MotionEvent);.

//abstract void requestFitSystemWindows();
//Ask that a new dispatch of View.fitSystemWindows(Rect); be performed.

abstract void requestLayout();
//Called when something has changed which has invalidated the layout of a child of this view parent.

//abstract boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called by a child to request from its parent to send an AccessibilityEvent.

//abstract void requestTransparentRegion(View child);
//Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor.

//abstract boolean showContextMenuForChild(View originalView);
//Bring up a context menu for the specified view or its ancestors.

//abstract ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback);
//Start an action mode for the specified view.
}

class Window {
    
    
abstract void addContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Variation on setContentView(View, android.view.ViewGroup.LayoutParams); to add an additional content view to the screen.

void addFlags(int flags);
//Convenience function to set the flag bits as specified in flags, as per setFlags(int, int);.

void clearFlags(int flags);
//Convenience function to clear the flag bits as specified in flags, as per setFlags(int, int);.

abstract void closeAllPanels();

abstract void closePanel(int featureId);

View findViewById(int id);
//Finds a view that was identified by the id attribute from the XML that was processed in onCreate(Bundle);.

final WindowManager.LayoutParams getAttributes();
//Retrieve the current window attributes associated with this panel.

final Window.Callback getCallback();
//Return the current Callback interface for this window.

final Window getContainer();
//Return the container for this Window.

final Context getContext();
//Return the Context this window policy is running in, for retrieving resources and other information.

abstract View getCurrentFocus();
//Return the view in this Window that currently has focus, or null if there are none.

abstract View getDecorView();
//Retrieve the top-level window decor view (containing the standard window frame/decorations and the client's content inside of that);, which can be added as a window to the window manager.

abstract LayoutInflater getLayoutInflater();
//Quick access to the LayoutInflater instance that this Window retrieved from its Context.

abstract int getVolumeControlStream();

WindowManager getWindowManager();
//Return the window manager allowing this Window to display its own windows.

final TypedArray getWindowStyle();
//Return the Window attributes from this window's theme.

final boolean hasChildren();

boolean hasFeature(int feature);
//Query for the availability of a certain feature.

abstract void invalidatePanelMenu(int featureId);

final boolean isActive();

abstract boolean isFloating();
//Return whether this window is being displayed with a floating style (based on the windowIsFloating attribute in the style/theme);.

abstract boolean isShortcutKey(int keyCode, KeyEvent event);
//Is a keypress one of the defined shortcut keys for this window.

final void makeActive();

abstract void onConfigurationChanged(Configuration newConfig);
//Should be called when the configuration is changed.

abstract void openPanel(int featureId, KeyEvent event);

abstract View peekDecorView();
//Retrieve the current decor view, but only if it has already been created; otherwise returns null.

abstract boolean performContextMenuIdentifierAction(int id, int flags);

abstract boolean performPanelIdentifierAction(int featureId, int id, int flags);

abstract boolean performPanelShortcut(int featureId, int keyCode, KeyEvent event, int flags);

boolean requestFeature(int featureId);
//Enable extended screen features.

abstract void restoreHierarchyState(Bundle savedInstanceState);

abstract Bundle saveHierarchyState();

void setAttributes(WindowManager.LayoutParams a);
//Specify custom window attributes.

abstract void setBackgroundDrawable(Drawable drawable);
//Change the background of this window to a custom Drawable.

void setBackgroundDrawableResource(int resid);
//Change the background of this window to a Drawable resource.

void setCallback(Window.Callback callback);
//Set the Callback interface for this window, used to intercept key events and other dynamic operations in the window.

abstract void setChildDrawable(int featureId, Drawable drawable);

abstract void setChildInt(int featureId, int value);

void setContainer(Window container);
//Set the container for this window.

abstract void setContentView(@Sink(DISPLAY) View view);
//Convenience for setContentView(View, android.view.ViewGroup.LayoutParams); set the screen content to an explicit view.

abstract void setContentView(int layoutResID);
//Convenience for setContentView(View, android.view.ViewGroup.LayoutParams); to set the screen content from a layout resource.

abstract void setContentView(@Sink(DISPLAY) View view, ViewGroup.LayoutParams params);
//Set the screen content to an explicit view.

void setDimAmount(float amount);
//Set the amount of dim behind the window when using FLAG_DIM_BEHIND.

abstract void setFeatureDrawable(int featureId, Drawable drawable);
//Set an explicit Drawable value for feature of this window.

abstract void setFeatureDrawableAlpha(int featureId, int alpha);
//Set a custom alpha value for the given drawale feature, controlling how much the background is visible through it.

abstract void setFeatureDrawableResource(int featureId, int resId);
//Set the value for a drawable feature of this window, from a resource identifier.

abstract void setFeatureDrawableUri(int featureId, Uri uri);
//Set the value for a drawable feature of this window, from a URI.

abstract void setFeatureInt(int featureId, int value);
//Set the integer value for a feature.

void setFlags(int flags, int mask);
//Set the flags of the window, as per the WindowManager.LayoutParams flags.

void setFormat(int format);
//Set the format of window, as per the PixelFormat types.

void setGravity(int gravity);
//Set the gravity of the window, as per the Gravity constants.

void setLayout(int width, int height);
//Set the width and height layout parameters of the window.

void setSoftInputMode(int mode);
//Specify an explicit soft input mode to use for the window, as per WindowManager.LayoutParams.softInputMode.

abstract void setTitle(CharSequence title);

abstract void setTitleColor(int textColor);

void setType(int type);
//Set the type of the window, as per the WindowManager.LayoutParams types.

void setUiOptions(int uiOptions);
//Set extra options that will influence the UI for this window.

void setUiOptions(int uiOptions, int mask);
//Set extra options that will influence the UI for this window.

abstract void setVolumeControlStream(int streamType);

void setWindowAnimations(int resId);
//Specify custom animations to use for the window, as per WindowManager.LayoutParams.windowAnimations.

void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated);
//Set the window manager for use by this Window to, for example, display panels.

void setWindowManager(WindowManager wm, IBinder appToken, String appName);
//Set the window manager for use by this Window to, for example, display panels.

abstract boolean superDispatchGenericMotionEvent(MotionEvent event);
//Used by custom windows, such as Dialog, to pass the generic motion event further down the view hierarchy.

abstract boolean superDispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Used by custom windows, such as Dialog, to pass the key press event further down the view hierarchy.

abstract boolean superDispatchKeyShortcutEvent(@Source(USER_INPUT) KeyEvent event);
//Used by custom windows, such as Dialog, to pass the key shortcut press event further down the view hierarchy.

abstract boolean superDispatchTouchEvent(MotionEvent event);
//Used by custom windows, such as Dialog, to pass the touch screen event further down the view hierarchy.

abstract boolean superDispatchTrackballEvent(MotionEvent event);
//Used by custom windows, such as Dialog, to pass the trackball event further down the view hierarchy.

abstract void takeInputQueue(InputQueue.Callback callback);
//Take ownership of this window's InputQueue.

abstract void takeKeyEvents(boolean get);
//Request that key events come to this activity.

abstract void takeSurface(SurfaceHolder.Callback2 callback);
//Take ownership of this window's surface.

abstract void togglePanel(int featureId, KeyEvent event);


//Protected Methods
final int getFeatures();
//Return the feature bits that are enabled.

final int getForcedWindowFlags();
//Return the window flags that have been explicitly set by the client, so will not be modified by getDecorView();.

final int getLocalFeatures();
//Return the feature bits that are being implemented by this Window.

final boolean hasSoftInputMode();
//Has the app specified their own soft input mode?

abstract void onActive();

void setDefaultWindowFormat(int format);
//Set the default format of window, as per the PixelFormat types.

    
}

class Window$Callback{
        boolean onMenuItemSelected(int arg0, MenuItem arg1);
            boolean dispatchKeyEvent(KeyEvent arg0);
}

class WindowManager {
    
    
abstract Display getDefaultDisplay();
//Returns the Display upon which this WindowManager instance will create new windows.

abstract void removeViewImmediate(View view);
//Special variation of removeView(View); that immediately invokes the given view hierarchy's View.onDetachedFromWindow(); methods before returning.



}


class KeyEvent {
    @Source(FlowPermission.USER_INPUT) int getKeyCode();
}

package android.view.animation;

class AccelerateInterpolator {

float getInterpolation(float input);
//Maps a value representing the elapsed fraction of an animation to a value that represents the interpolated fraction.

}

class AlphaAnimation {
    
boolean willChangeBounds();
//Indicates whether or not this animation will affect the bounds of the animated view.

boolean willChangeTransformationMatrix();
//Indicates whether or not this animation will affect the transformation matrix.

//Protected Methods
void applyTransformation(float interpolatedTime, Transformation t);
//Changes the alpha property of the supplied Transformation


}
class Animation {
    
void cancel();
//Cancel the animation.

long computeDurationHint();
//Compute a hint at how long the entire animation may last, in milliseconds.

int getBackgroundColor();
//Returns the background color behind the animation.

boolean getDetachWallpaper();
//Return value of setDetachWallpaper(boolean);.

long getDuration();
//How long this animation should last

boolean getFillAfter();
//If fillAfter is true, this animation will apply its transformation after the end time of the animation.

boolean getFillBefore();
//If fillBefore is true, this animation will apply its transformation before the start time of the animation.

Interpolator getInterpolator();
//Gets the acceleration curve type for this animation.

int getRepeatCount();
//Defines how many times the animation should repeat.

int getRepeatMode();
//Defines what this animation should do when it reaches the end.

long getStartOffset();
//When this animation should start, relative to StartTime

long getStartTime();
//When this animation should start.

boolean getTransformation(long currentTime, Transformation outTransformation, float scale);
//Gets the transformation to apply at a specified point in time.

boolean getTransformation(long currentTime, Transformation outTransformation);
//Gets the transformation to apply at a specified point in time.

int getZAdjustment();
//Returns the Z ordering mode to use while running the animation as previously set by setZAdjustment(int);.

boolean hasEnded();
//Indicates whether this animation has ended or not.

boolean hasStarted();
//Indicates whether this animation has started or not.

void initialize(int width, int height, int parentWidth, int parentHeight);
//Initialize this animation with the dimensions of the object being animated as well as the objects parents.

boolean isFillEnabled();
//If fillEnabled is true, this animation will apply the value of fillBefore.

boolean isInitialized();
//Whether or not the animation has been initialized.

void reset();
//Reset the initialization state of this animation.

void restrictDuration(long durationMillis);
//Ensure that the duration that this animation will run is not longer than durationMillis.

void scaleCurrentDuration(float scale);
//How much to scale the duration by.

void setAnimationListener(Animation.AnimationListener listener);
//Binds an animation listener to this animation.

void setBackgroundColor(int bg);
//Set background behind animation.

void setDetachWallpaper(boolean detachWallpaper);
//If detachWallpaper is true, and this is a window animation of a window that has a wallpaper background, then the window will be detached from the wallpaper while it runs.

void setDuration(long durationMillis);
//How long this animation should last.

void setFillAfter(boolean fillAfter);
//If fillAfter is true, the transformation that this animation performed will persist when it is finished.

void setFillBefore(boolean fillBefore);
//If fillBefore is true, this animation will apply its transformation before the start time of the animation.

void setFillEnabled(boolean fillEnabled);
//If fillEnabled is true, the animation will apply the value of fillBefore.

void setInterpolator(Context context, int resID);
//Sets the acceleration curve for this animation.

void setInterpolator(Interpolator i);
//Sets the acceleration curve for this animation.

void setRepeatCount(@Sink(DISPLAY) int repeatCount);
//Sets how many times the animation should be repeated.

void setRepeatMode(int repeatMode);
//Defines what this animation should do when it reaches the end.

void setStartOffset(long startOffset);
//When this animation should start relative to the start time.

void setStartTime(long startTimeMillis);
//When this animation should start.

void setZAdjustment(int zAdjustment);
//Set the Z ordering mode to use while running the animation.

void start();
//Convenience method to start the animation the first time getTransformation(long, Transformation); is invoked.

void startNow();
//Convenience method to start the animation at the current time in milliseconds.

boolean willChangeBounds();
//Indicates whether or not this animation will affect the bounds of the animated view.

boolean willChangeTransformationMatrix();
//Indicates whether or not this animation will affect the transformation matrix.

//Protected Methods
void applyTransformation(float interpolatedTime, Transformation t);
//Helper for getTransformation.

Animation clone();
//Creates and returns a copy of this Object.

void ensureInterpolator();
//Gurantees that this animation has an interpolator.

void finalize();
//Invoked when the garbage collector has detected that this instance is no longer reachable.

float getScaleFactor();
//The scale factor is set by the call to getTransformation.

float resolveSize(int type, float value, int size, int parentSize);
//Convert the information in the description of a size to an actual dimension
    
}
class Animation$AnimationListener {
    void onAnimationRepeat(Animation arg0);
    void onAnimationStart(Animation arg0);
    void onAnimationEnd(Animation arg0);
}

class AnimationSet {
    
void addAnimation(@Sink(DISPLAY) Animation a);
//Add a child animation to this animation set.

long computeDurationHint();
//The duration hint of an animation set is the maximum of the duration hints of all of its component animations.

List<Animation> getAnimations();

long getDuration();
//The duration of an AnimationSet is defined to be the duration of the longest child animation.

long getStartTime();
//When this animation should start.

boolean getTransformation(long currentTime, Transformation t);
//The transformation of an animation set is the concatenation of all of its component animations.

void initialize(int width, int height, int parentWidth, int parentHeight);
//Initialize this animation with the dimensions of the object being animated as well as the objects parents.

void reset();
//Reset the initialization state of this animation.

void restrictDuration(long durationMillis);
//Ensure that the duration that this animation will run is not longer than durationMillis.

void scaleCurrentDuration(float scale);
//How much to scale the duration by.

void setDuration(long durationMillis);
//Sets the duration of every child animation.

void setFillAfter(boolean fillAfter);
//If fillAfter is true, the transformation that this animation performed will persist when it is finished.

void setFillBefore(boolean fillBefore);
//If fillBefore is true, this animation will apply its transformation before the start time of the animation.

void setRepeatMode(int repeatMode);
//Defines what this animation should do when it reaches the end.

void setStartOffset(long startOffset);
//When this animation should start relative to the start time.

void setStartTime(long startTimeMillis);
//Sets the start time of this animation and all child animations

boolean willChangeBounds();
//Indicates whether or not this animation will affect the bounds of the animated view.

boolean willChangeTransformationMatrix();
//Indicates whether or not this animation will affect the transformation matrix.

//Protected Methods
AnimationSet clone();
//Creates and returns a copy of this Object.

    
    
}

class AnimationUtils {


static long currentAnimationTimeMillis();
//Returns the current animation time in milliseconds.

static Animation loadAnimation(Context context, int id);
//Loads an Animation object from a resource

static Interpolator loadInterpolator(Context context, int id);
//Loads an Interpolator object from a resource

static LayoutAnimationController loadLayoutAnimation(Context context, int id);
//Loads a LayoutAnimationController object from a resource

static Animation makeInAnimation(Context c, boolean fromLeft);
//Make an animation for objects becoming visible.

static Animation makeInChildBottomAnimation(Context c);
//Make an animation for objects becoming visible.

static Animation makeOutAnimation(Context c, boolean toRight);
//Make an animation for objects becoming invisible.

}
class DecelerateInterpolator {
    
float getInterpolation(float input);
//Maps a value representing the elapsed fraction of an animation to a value that represents the interpolated fraction.


}
class ScaleAnimation {
    
    
void initialize(int width, int height, int parentWidth, int parentHeight);
//Initialize this animation with the dimensions of the object being animated as well as the objects parents.

//Protected Methods
void applyTransformation(float interpolatedTime, Transformation t);
//Helper for getTransformation.


}

package android.view.accessibility;
class AccessibilityManager$AccessibilityStateChangeListener{
        void onAccessibilityStateChanged(boolean arg0);
}

package android.view.inputmethod;

class CompletionInfo {
    
int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

long getId();
//Return the abstract identifier for this completion, typically corresponding to the id associated with it in the original adapter.

CharSequence getLabel();
//Return the user-visible label for the completion, or null if the plain text should be shown.

int getPosition();
//Return the original position of this completion, typically corresponding to its position in the original adapter.

CharSequence getText();
//Return the actual text associated with this completion.

String toString();
//Returns a string containing a concise, human-readable description of this object.

void writeToParcel(Parcel dest, int flags);
//Used to package this object into a Parcel.



}

class InputConnection {
    
abstract boolean beginBatchEdit();
//Tell the editor that you are starting a batch of editor operations.

abstract boolean clearMetaKeyStates(int states);
//Clear the given meta key pressed states in the given input connection.

abstract boolean commitCompletion(CompletionInfo text);
//Commit a completion the user has selected from the possible ones previously reported to InputMethodSession.displayCompletions();.

abstract boolean commitCorrection(CorrectionInfo correctionInfo);
//Commit a correction automatically performed on the raw user's input.

abstract boolean commitText(CharSequence text, int newCursorPosition);
//Commit text to the text box and set the new cursor position.

abstract boolean deleteSurroundingText(int beforeLength, int afterLength);
//Delete beforeLength characters of text before the current cursor position, and delete afterLength characters of text after the current cursor position, excluding composing text.

abstract boolean endBatchEdit();
//Tell the editor that you are done with a batch edit previously initiated with beginBatchEdit();.

abstract boolean finishComposingText();
//Have the text editor finish whatever composing text is currently active.

abstract int getCursorCapsMode(int reqModes);
//Retrieve the current capitalization mode in effect at the current cursor position in the text.

abstract ExtractedText getExtractedText(ExtractedTextRequest request, int flags);
//Retrieve the current text in the input connection's editor, and monitor for any changes to it.

abstract CharSequence getSelectedText(int flags);
//Gets the selected text, if any.

abstract CharSequence getTextAfterCursor(int n, int flags);
//Get n characters of text after the current cursor position.

abstract CharSequence getTextBeforeCursor(int n, int flags);
//Get n characters of text before the current cursor position.

abstract boolean performContextMenuAction(int id);
//Perform a context menu action on the field.

abstract boolean performEditorAction(int editorAction);
//Have the editor perform an action it has said it can do.

abstract boolean performPrivateCommand(String action, Bundle data);
//API to send private commands from an input method to its connected editor.

abstract boolean reportFullscreenMode(boolean enabled);
//Called by the IME to tell the client when it switches between fullscreen and normal modes.

abstract boolean sendKeyEvent(KeyEvent event);
//Send a key event to the process that is currently attached through this input connection.

abstract boolean setComposingRegion(int start, int end);
//Mark a certain region of text as composing text.

abstract boolean setComposingText(CharSequence text, int newCursorPosition);
//Set composing text around the current cursor position with the given text, and set the new cursor position.

abstract boolean setSelection(int start, int end);
//Set the selection of the text editor.


}

class InputMethodManager {
    
void displayCompletions(View view, CompletionInfo[] completions);

InputMethodSubtype getCurrentInputMethodSubtype();
//Returns the current input method subtype.

List<InputMethodInfo> getEnabledInputMethodList();

List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo imi, boolean allowsImplicitlySelectedSubtypes);
//Returns a list of enabled input method subtypes for the specified input method info.

List<InputMethodInfo> getInputMethodList();

InputMethodSubtype getLastInputMethodSubtype();

Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes();
//Returns a map of all shortcut input method info and their subtypes.

void hideSoftInputFromInputMethod(IBinder token, int flags);
//Close/hide the input method's soft input area, so the user no longer sees it or can interact with it.

boolean hideSoftInputFromWindow(IBinder windowToken, int flags);
//Synonym for hideSoftInputFromWindow(IBinder, int, ResultReceiver); without a result: request to hide the soft input window from the context of the window that is currently accepting input.

boolean hideSoftInputFromWindow(IBinder windowToken, int flags, ResultReceiver resultReceiver);
//Request to hide the soft input window from the context of the window that is currently accepting input.

void hideStatusIcon(IBinder imeToken);

boolean isAcceptingText();
//Return true if the currently served view is accepting full text edits.

boolean isActive(View view);
//Return true if the given view is the currently active view for the input method.

boolean isActive();
//Return true if any view is currently active in the input method.

boolean isFullscreenMode();
//Allows you to discover whether the attached input method is running in fullscreen mode.

boolean isWatchingCursor(View view);
//Returns true if the current input method wants to watch the location of the input editor's cursor in its window.

void restartInput(View view);
//If the input method is currently connected to the given view, restart it with its new contents.

void sendAppPrivateCommand(View view, String action, Bundle data);
//Call InputMethodSession.appPrivateCommand(); on the current Input Method.

void setAdditionalInputMethodSubtypes(String imiId, InputMethodSubtype[] subtypes);
//Set additional input method subtypes.

boolean setCurrentInputMethodSubtype(InputMethodSubtype subtype);
//Switch to a new input method subtype of the current input method.

void setInputMethod(IBinder token, String id);
//Force switch to a new input method component.

void setInputMethodAndSubtype(IBinder token, String id, InputMethodSubtype subtype);
//Force switch to a new input method and subtype.

void showInputMethodAndSubtypeEnabler(String imiId);
//Show the settings for enabling subtypes of the specified input method.

void showInputMethodPicker();

boolean showSoftInput(View view, int flags, ResultReceiver resultReceiver);
//Explicitly request that the current input method's soft input area be shown to the user, if needed.

boolean showSoftInput(View view, int flags);
//Synonym for showSoftInput(View, int, ResultReceiver); without a result receiver: explicitly request that the current input method's soft input area be shown to the user, if needed.

void showSoftInputFromInputMethod(IBinder token, int flags);
//Show the input method's soft input area, so the user sees the input method window and can interact with it.

void showStatusIcon(IBinder imeToken, String packageName, int iconId);

boolean switchToLastInputMethod(IBinder imeToken);
//Force switch to the last used input method and subtype.

boolean switchToNextInputMethod(IBinder imeToken, boolean onlyCurrentIme);
//Force switch to the next input method and subtype.

void toggleSoftInput(int showFlags, int hideFlags);

void toggleSoftInputFromWindow(IBinder windowToken, int showFlags, int hideFlags);
//This method toggles the input method window display.

void updateCursor(View view, int left, int top, int right, int bottom);
//Report the current cursor location in its window.

void updateExtractedText(View view, int token, ExtractedText text);

void updateSelection(View view, int selStart, int selEnd, int candidatesStart, int candidatesEnd);
//Report the current selection range.

void viewClicked(View view);
//Notify the event when the user tapped or clicked the text view.



}

class InputMethodSubtype {
    
    
boolean containsExtraValueKey(String key);
//The string of ExtraValue in subtype should be defined as follows: example: key0,key1=value1,key2,key3,key4=value4

int describeContents();
//Describe the kinds of special objects contained in this Parcelable's marshalled representation.

boolean equals(Object o);
//Compares this instance with the specified object and indicates if they are equal.

CharSequence getDisplayName(Context context, String packageName, ApplicationInfo appInfo);

String getExtraValue();

String getExtraValueOf(String key);
//The string of ExtraValue in subtype should be defined as follows: example: key0,key1=value1,key2,key3,key4=value4

int getIconResId();

String getLocale();

String getMode();

int getNameResId();

int hashCode();
//Returns an integer hash code for this object.

boolean isAuxiliary();

boolean overridesImplicitlyEnabledSubtype();

void writeToParcel(Parcel dest, int parcelableFlags);
//Flatten this object in to a Parcel.



}
package android.webkit;

class MimeTypeMap {
    
String getExtensionFromMimeType(String mimeType);
//Return the registered extension for the given MIME type.

static String getFileExtensionFromUrl(String url);
//Returns the file extension or an empty string iff there is no extension.

String getMimeTypeFromExtension(String extension);
//Return the MIME type for the given extension.

static MimeTypeMap getSingleton();
//Get the singleton instance of MimeTypeMap.

boolean hasExtension(String extension);
//Return true if the given extension has a registered MIME type.

boolean hasMimeType(String mimeType);
//Return true if the given MIME type has an entry in the map.



}


class WebView {
//CHS: This whole class needs the INTERNET permission


void addJavascriptInterface(Object object, String name);
//Injects the supplied Java object into this WebView.

boolean canGoBack();
//Gets whether this WebView has a back history item.

boolean canGoBackOrForward(int steps);
//Gets whether the page can go back or forward the given number of steps.

boolean canGoForward();
//Gets whether this WebView has a forward history item.

boolean canZoomIn();
//This method was deprecated in API level 17. This method is prone to inaccuracy due to race conditions between the web rendering and UI threads; prefer onScaleChanged(WebView, float, float);.

boolean canZoomOut();
//This method was deprecated in API level 17. This method is prone to inaccuracy due to race conditions between the web rendering and UI threads; prefer onScaleChanged(WebView, float, float);.

Picture capturePicture();
//Gets a new picture that captures the current contents of this WebView.

void clearCache(boolean includeDiskFiles);
//Clears the resource cache.

void clearFormData();
//Removes the autocomplete popup from the currently focused form field, if present.

void clearHistory();
//Tells this WebView to clear its internal back/forward list.

void clearMatches();
//Clears the highlighting surrounding text matches created by findAllAsync(String);.

void clearSslPreferences();
//Clears the SSL preferences table stored in response to proceeding with SSL certificate errors.

void clearView();
//Clears this WebView so that onDraw(); will draw nothing but white background, and onMeasure(); will return 0 if MeasureSpec is not MeasureSpec.EXACTLY.

void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

WebBackForwardList copyBackForwardList();
//Gets the WebBackForwardList for this WebView.

void destroy();
//Destroys the internal state of this WebView.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

void documentHasImages(Message response);
//Queries the document to see if it contains any image references.

abstract void dumpViewHierarchyWithProperties(BufferedWriter out, int level);
//Dumps custom children to hierarchy viewer.

static String findAddress(String addr);
//Gets the first substring consisting of the address of a physical location.

int findAll(String find);
//This method was deprecated in API level 16. findAllAsync(String); is preferred.

void findAllAsync(String find);
//Finds all instances of find on the page and highlights them, asynchronously.

abstract View findHierarchyView(String className, int hashCode);
//Returns a View to enable grabbing screenshots from custom children returned in dumpViewHierarchyWithProperties.

void findNext(boolean forward);
//Highlights and scrolls to the next match found by findAllAsync(String);, wrapping around page boundaries as necessary.

void flingScroll(int vx, int vy);
//void freeMemory();
//Informs this WebView that memory is low so that it can free any available memory.

SslCertificate getCertificate();
//Gets the SSL certificate for the main top-level page or null if there is no certificate (the site is not secure);.

int getContentHeight();
//Gets the height of the HTML content.

Bitmap getFavicon();
//Gets the favicon for the current page.

WebView.HitTestResult getHitTestResult();
//Gets a HitTestResult based on the current cursor node.

String[] getHttpAuthUsernamePassword(@Source(INTERNET) String host, @Source(INTERNET) String realm);
//Retrieves HTTP authentication credentials for a given host and realm.

String getOriginalUrl();
//Gets the original URL for the current page.

int getProgress();
//Gets the progress for the current page.

float getScale();
//This method was deprecated in API level 17. This method is prone to inaccuracy due to race conditions between the web rendering and UI threads; prefer onScaleChanged(WebView, float, float);.

WebSettings getSettings();
//Gets the WebSettings object used to control the settings for this WebView.

String getTitle();
//Gets the title for the current page.

String getUrl();
//Gets the URL for the current page.

void goBack();
//Goes back in the history of this WebView.

void goBackOrForward(int steps);
//Goes to the history item that is the number of steps away from the current item.

void goForward();
//Goes forward in the history of this WebView.

void invokeZoomPicker();
//Invokes the graphical zoom picker widget for this WebView.

boolean isPrivateBrowsingEnabled();
//Gets whether private browsing is enabled in this WebView.

void loadData(@Source(INTERNET) String data, @Source(INTERNET) String mimeType, @Source(INTERNET) String encoding);
//Loads the given data into this WebView using a 'data' scheme URL.

void loadDataWithBaseURL(@Source(INTERNET) String baseUrl, @Source(INTERNET) String data, @Source(INTERNET) String mimeType, @Source(INTERNET) String encoding, @Source(INTERNET) String historyUrl);
//Loads the given data into this WebView, using baseUrl as the base URL for the content.

void loadUrl(@Source(INTERNET) String url);
//Loads the given URL.

void loadUrl(@Source(INTERNET) String url, @Source(INTERNET) Map<String, String> additionalHttpHeaders);
//Loads the given URL with the specified additional HTTP headers.

void onChildViewAdded(View parent, View child);
//This method was deprecated in API level 8. WebView no longer needs to implement ViewGroup.OnHierarchyChangeListener. This method does nothing now.

void onChildViewRemoved(View p, View child);
//This method was deprecated in API level 8. WebView no longer needs to implement ViewGroup.OnHierarchyChangeListener. This method does nothing now.

InputConnection onCreateInputConnection(EditorInfo outAttrs);
//Create a new InputConnection for an InputMethod to interact with the view.

boolean onGenericMotionEvent(MotionEvent event);
//Implement this method to handle generic motion events.

void onGlobalFocusChanged(View oldFocus, View newFocus);
//This method was deprecated in API level 3. WebView should not have implemented ViewTreeObserver.OnGlobalFocusChangeListener. This method does nothing now.

boolean onHoverEvent(MotionEvent event);
//Implement this method to handle hover events.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyUp();: perform clicking of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.

void onPause();
//Pauses any extra processing associated with this WebView and its associated DOM, plugins, JavaScript etc.

void onResume();
//Resumes a WebView after a previous call to onPause();.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.

boolean onTrackballEvent(MotionEvent event);
//Implement this method to handle trackball motion events.

void onWindowFocusChanged(boolean hasWindowFocus);
//Called when the window containing this view gains or loses focus.

boolean overlayHorizontalScrollbar();
//Gets whether horizontal scrollbar has overlay style.

boolean overlayVerticalScrollbar();
//Gets whether vertical scrollbar has overlay style.

boolean pageDown(boolean bottom);
//Scrolls the contents of this WebView down by half the page size.

boolean pageUp(boolean top);
//Scrolls the contents of this WebView up by half the view size.

void pauseTimers();
//Pauses all layout, parsing, and JavaScript timers for all WebViews.

boolean performAccessibilityAction(int action, Bundle arguments);
//Performs the specified accessibility action on the view.

boolean performLongClick();
//Call this view's OnLongClickListener, if it is defined.

void postUrl(@Sink(INTERNET) String url, @Sink(INTERNET) byte[] postData);
//Loads the URL with postData using "POST" method into this WebView.

void reload() @Source(INTERNET);
//Reloads the current URL.

void removeJavascriptInterface(String name);
//Removes a previously injected Java object from this WebView.

boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

boolean requestFocus(int direction, Rect previouslyFocusedRect);
//Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. Looks for a view to give focus to respecting the setting specified by getDescendantFocusability();.

void requestFocusNodeHref(Message hrefMsg);
//Requests the anchor or image element URL at the last tapped point.

void requestImageRef(Message msg);
//Requests the URL of the image last touched by the user.

WebBackForwardList restoreState(Bundle inState);
//Restores the state of this WebView from the given Bundle.

void resumeTimers();
//Resumes all layout, parsing, and JavaScript timers for all WebViews.

void savePassword(String host, String username, String password);
//Sets a username and password pair for the specified host.

WebBackForwardList saveState(Bundle outState);
//Saves the state of this WebView used in onSaveInstanceState(Bundle);.

void saveWebArchive(String filename);
//Saves the current view as a web archive.

void saveWebArchive(String basename, boolean autoname, ValueCallback<String> callback);
//Saves the current view as a web archive.

void setBackgroundColor(int color);
//Sets the background color for this view.

void setCertificate(SslCertificate certificate);
//This method was deprecated in API level 17. Calling this function has no useful effect, and will be ignored in future releases.

void setDownloadListener(DownloadListener listener);
//Registers the interface to be used when content can not be handled by the rendering engine, and should be downloaded instead.

void setFindListener(WebView.FindListener listener);
//Registers the listener to be notified as find-on-page operations progress.

void setHorizontalScrollbarOverlay(boolean overlay);
//Specifies whether the horizontal scrollbar has overlay style.

void setHttpAuthUsernamePassword(String host, String realm, String username, String password);
//Stores HTTP authentication credentials for a given host and realm.

void setInitialScale(int scaleInPercent);
//Sets the initial scale for this WebView.

void setLayerType(int layerType, Paint paint);
//Specifies the type of layer backing this view.

void setLayoutParams(ViewGroup.LayoutParams params);
//Set the layout parameters associated with this view.

void setMapTrackballToArrowKeys(boolean setMap);
//This method was deprecated in API level 17. Only the default case, true, will be supported in a future version.

void setNetworkAvailable(boolean networkUp);
//Informs WebView of the network state.

void setOverScrollMode(int mode);
//Set the over-scroll mode for this view.

void setPictureListener(WebView.PictureListener listener);
//This method was deprecated in API level 12. This method is now obsolete.

void setScrollBarStyle(int style);
//Specify the style of the scrollbars.

void setVerticalScrollbarOverlay(boolean overlay);
//Specifies whether the vertical scrollbar has overlay style.

void setWebChromeClient(WebChromeClient client);
//Sets the chrome handler.

void setWebViewClient(WebViewClient client);
//Sets the WebViewClient that will receive various notifications and requests.

boolean shouldDelayChildPressedState();
//Return true if the pressed state should be delayed for children or descendants of this ViewGroup.

boolean showFindDialog(String text, boolean showIme);
//Starts an ActionMode for finding text in this WebView.

void stopLoading();
//Stops the current load.

boolean zoomIn();
//Performs zoom in in this WebView.

boolean zoomOut();
//Performs zoom out in this WebView.

//Protected Methods
int computeHorizontalScrollOffset();
//Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range.

int computeHorizontalScrollRange();
//Compute the horizontal range that the horizontal scrollbar represents.

int computeVerticalScrollExtent();
//Compute the vertical extent of the horizontal scrollbar's thumb within the vertical range.

int computeVerticalScrollOffset();
//Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range.

int computeVerticalScrollRange();
//Compute the vertical range that the vertical scrollbar represents.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onConfigurationChanged(Configuration newConfig);
//Called when the current configuration of the resources being used by the application have changed.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect);
//Called by the view system when the focus state of this view changes.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY);
//Called by overScrollBy(int, int, int, int, int, int, int, int, boolean); to respond to the results of an over-scroll operation.

void onScrollChanged(int l, int t, int oldl, int oldt);
//This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents);.

void onSizeChanged(int w, int h, int ow, int oh);
//This is called during layout when the size of this view has changed.

void onVisibilityChanged(View changedView, int visibility);
//Called when the visibility of the view or an ancestor of the view is changed.

void onWindowVisibilityChanged(int visibility);
//Called when the window containing has change its visibility (between GONE, INVISIBLE, and VISIBLE);.



    
}

class WebViewClient{
            boolean shouldOverrideUrlLoading(WebView view, String url);
            WebViewClient();
}

package android.widget;


class AbsListView$MultiChoiceModeListener{
            void onItemCheckedStateChanged(ActionMode arg0, int arg1, long arg2, boolean arg3);
}

class AbsListView {
    
void addTouchables(ArrayList<View> views);
//Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself); to views.

void afterTextChanged(Editable s);
//For our text watcher that is associated with the text filter.

void beforeTextChanged(CharSequence s, int start, int count, int after);
//For our text watcher that is associated with the text filter.

boolean checkInputConnectionProxy(View view);
//For filtering we proxy an input connection to an internal text editor, and this allows the proxying to happen.

void clearChoices();
//Clear any choices previously set

void clearTextFilter();
//Clear the text filter.

void deferNotifyDataSetChanged();
//This defers a notifyDataSetChanged on the pending RemoteViewsAdapter if it has not connected yet.

void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

AbsListView.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

int getCacheColorHint();
//When set to a non-zero value, the cache color hint indicates that this list is always drawn on top of a solid, single-color, opaque background

int getCheckedItemCount();
//Returns the number of items currently selected.

long[] getCheckedItemIds();
//Returns the set of checked items ids.

int getCheckedItemPosition();
//Returns the currently checked item.

SparseBooleanArray getCheckedItemPositions();
//Returns the set of checked items in the list.

int getChoiceMode();

void getFocusedRect(Rect r);
//When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.

int getListPaddingBottom();
//List padding is the maximum of the normal view's padding and the padding of the selector.

int getListPaddingLeft();
//List padding is the maximum of the normal view's padding and the padding of the selector.

int getListPaddingRight();
//List padding is the maximum of the normal view's padding and the padding of the selector.

int getListPaddingTop();
//List padding is the maximum of the normal view's padding and the padding of the selector.

View getSelectedView();

Drawable getSelector();
//Returns the selector Drawable that is used to draw the selection in the list.

int getSolidColor();
//Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.

CharSequence getTextFilter();
//Returns the list's text filter, if available.

int getTranscriptMode();
//Returns the current transcript mode.

int getVerticalScrollbarWidth();
//Returns the width of the vertical scrollbar.

boolean hasTextFilter();
//Returns if the ListView currently has a text filter.

void invalidateViews();
//Causes all the views to be rebuilt and redrawn.

boolean isFastScrollAlwaysVisible();
//Returns true if the fast scroller is set to always show on this view rather than fade out when not in use.

boolean isFastScrollEnabled();
//Returns the current state of the fast scroll feature.

boolean isItemChecked(int position);
//Returns the checked state of the specified position.

boolean isScrollingCacheEnabled();
//Indicates whether the children's drawing cache is used during a scroll.

boolean isSmoothScrollbarEnabled();
//Returns the current state of the fast scroll feature.

boolean isStackFromBottom();
//Indicates whether the content of this view is pinned to, or stacked from, the bottom edge.

boolean isTextFilterEnabled();
//Indicates whether type filtering is enabled for this view

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

InputConnection onCreateInputConnection(EditorInfo outAttrs);
//Return an InputConnection for editing of the filter text.

void onFilterComplete(int count);
//Notifies the end of a filtering operation.

boolean onGenericMotionEvent(MotionEvent event);
//Implement this method to handle generic motion events.

void onGlobalLayout();
//Callback method to be invoked when the global layout state or the visibility of views within the view tree changes

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onInterceptTouchEvent(MotionEvent ev);
//Implement this method to intercept all touch screen motion events.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyUp();: perform clicking of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.

boolean onRemoteAdapterConnected();
//Called back when the adapter connects to the RemoteViewsService.

void onRemoteAdapterDisconnected();
//Called back when the adapter disconnects from the RemoteViewsService.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

void onTextChanged(CharSequence s, int start, int before, int count);
//For our text watcher that is associated with the text filter.

boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

void onTouchModeChanged(boolean isInTouchMode);
//Callback method to be invoked when the touch mode changes.

void onWindowFocusChanged(boolean hasWindowFocus);
//Called when the window containing this view gains or loses focus.

boolean performAccessibilityAction(int action, Bundle arguments);
//Performs the specified accessibility action on the view.

boolean performItemClick(View view, int position, long id);
//Call the OnItemClickListener, if it is defined.

int pointToPosition(int x, int y);
//Maps a point to a position in the list.

long pointToRowId(int x, int y);
//Maps a point to a the rowId of the item which intersects that point.

void reclaimViews(List<View> views);
//Move all views (excluding headers and footers); held by this AbsListView into the supplied List.

void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
//Called when a child does not want this parent and its ancestors to intercept touch events with onInterceptTouchEvent(MotionEvent);.

void requestLayout();
//Call this when something has changed which has invalidated the layout of this view.

void sendAccessibilityEvent(int eventType);
//Sends an accessibility event of the given type.

void setAdapter(ListAdapter adapter);
//Sets the adapter that provides the data and the views to represent the data in this widget.

void setCacheColorHint(int color);
//When set to a non-zero value, the cache color hint indicates that this list is always drawn on top of a solid, single-color, opaque background.

void setChoiceMode(int choiceMode);
//Defines the choice behavior for the List.

void setDrawSelectorOnTop(boolean onTop);
//Controls whether the selection highlight drawable should be drawn on top of the item or behind it.

void setFastScrollAlwaysVisible(boolean alwaysShow);
//Set whether or not the fast scroller should always be shown in place of the standard scrollbars.

void setFastScrollEnabled(boolean enabled);
//Enables fast scrolling by letting the user quickly scroll through lists by dragging the fast scroll thumb.

void setFilterText(String filterText);
//Sets the initial value for the text filter.

void setFriction(float friction);
//The amount of friction applied to flings.

void setItemChecked(int position, boolean value);
//Sets the checked state of the specified position.

void setMultiChoiceModeListener(AbsListView.MultiChoiceModeListener listener);
//Set a AbsListView.MultiChoiceModeListener that will manage the lifecycle of the selection ActionMode.

void setOnScrollListener(AbsListView.OnScrollListener l);
//Set the listener that will receive notifications every time the list scrolls.

void setOverScrollMode(int mode);
//Set the over-scroll mode for this view.

void setRecyclerListener(AbsListView.RecyclerListener listener);
//Sets the recycler listener to be notified whenever a View is set aside in the recycler for later reuse.

void setRemoteViewsAdapter(Intent intent);
//Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService through the specified intent.

void setScrollIndicators(View up, View down);

void setScrollingCacheEnabled(boolean enabled);
//Enables or disables the children's drawing cache during a scroll.

void setSelector(Drawable sel);

void setSelector(int resID);
//Set a Drawable that should be used to highlight the currently selected item.

void setSmoothScrollbarEnabled(boolean enabled);
//When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed based on the number of visible pixels in the visible items.

void setStackFromBottom(boolean stackFromBottom);
//When stack from bottom is set to true, the list fills its content starting from the bottom of the view.

void setTextFilterEnabled(boolean textFilterEnabled);
//Enables or disables the type filter window.

void setTranscriptMode(int mode);
//Puts the list or grid into transcript mode.

void setVelocityScale(float scale);
//Sets a scale factor for the fling velocity.

void setVerticalScrollbarPosition(int position);
//Set the position of the vertical scroll bar.

boolean showContextMenuForChild(View originalView);
//Bring up a context menu for the specified view or its ancestors.

void smoothScrollBy(int distance, int duration);
//Smoothly scroll by distance pixels over duration milliseconds.

void smoothScrollToPosition(int position);
//Smoothly scroll to the specified adapter position.

void smoothScrollToPosition(int position, int boundPosition);
//Smoothly scroll to the specified adapter position.

void smoothScrollToPositionFromTop(int position, int offset, int duration);
//Smoothly scroll to the specified adapter position.

void smoothScrollToPositionFromTop(int position, int offset);
//Smoothly scroll to the specified adapter position.

boolean verifyDrawable(Drawable dr);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.

//Protected Methods
boolean checkLayoutParams(ViewGroup.LayoutParams p);

int computeVerticalScrollExtent();
//Compute the vertical extent of the horizontal scrollbar's thumb within the vertical range.

int computeVerticalScrollOffset();
//Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range.

int computeVerticalScrollRange();
//Compute the vertical range that the vertical scrollbar represents.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

void dispatchSetPressed(boolean pressed);
//Dispatch setPressed to all of this View's children.

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

ViewGroup.LayoutParams generateDefaultLayoutParams();
//Returns a set of default layout parameters.

ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

float getBottomFadingEdgeStrength();
//Returns the strength, or intensity, of the bottom faded edge.

int getBottomPaddingOffset();
//Amount by which to extend the bottom fading region.

ContextMenu.ContextMenuInfo getContextMenuInfo();
//Views should implement this if they have extra information to associate with the context menu.

int getLeftPaddingOffset();
//Amount by which to extend the left fading region.

int getRightPaddingOffset();
//Amount by which to extend the right fading region.

float getTopFadingEdgeStrength();
//Returns the strength, or intensity, of the top faded edge.

int getTopPaddingOffset();
//Amount by which to extend the top fading region.

void handleDataChanged();

boolean isInFilterMode();
//Indicates whether this view is in filter mode.

boolean isPaddingOffsetRequired();
//If the View draws content inside its padding and enables fading edges, it needs to support padding offsets.

void layoutChildren();
//Subclasses must override this method to layout their children.

void onAttachedToWindow();
//This is called when the view is attached to a window.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDisplayHint(int hint);
//Gives this view a hint about whether is displayed or not.

void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect);
//Called by the view system when the focus state of this view changes.

void onLayout(boolean changed, int l, int t, int r, int b);
//Subclasses should NOT override this method but layoutChildren(); instead.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY);
//Called by overScrollBy(int, int, int, int, int, int, int, int, boolean); to respond to the results of an over-scroll operation.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.


}


class AbsSpinner{
        void setSelection(int position);
}

class AdapterView$OnItemClickListener{
        Object getSelectedItem();
        void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3);
}
class Adapter{
        boolean hasStableIds();
    int getCount();
    @PolyFlowReceiver
    long getItemId(int arg0);
    @PolyFlowReceiver
    Object getItem(int arg0);
    @PolyFlowReceiver
    View getView(int arg0, View arg1, ViewGroup arg2);
    Object getSelectedItem();

}

class AdapterView {
        Object getSelectedItem();
      long getItemIdAtPosition(int position);
            int getCount();
            int getFirstVisiblePosition();

//void addView(View child);
//This method is not supported and throws an UnsupportedOperationException when called.

//void addView(View child, int index);
//This method is not supported and throws an UnsupportedOperationException when called.

//void addView(View child, int index, ViewGroup.LayoutParams params);
//This method is not supported and throws an UnsupportedOperationException when called.

//void addView(View child, ViewGroup.LayoutParams params);
//This method is not supported and throws an UnsupportedOperationException when called.

//boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

//abstract T getAdapter();
//Returns the adapter currently associated with this widget.

//int getCount();

//View getEmptyView();
//When the current adapter is empty, the AdapterView can display a special view call the empty view.

//int getFirstVisiblePosition();
//Returns the position within the adapter's data set for the first item displayed on screen.

@PolySource @PolySink Object getItemAtPosition(@Sink(FlowPermission.CONDITIONAL) int position) @PolySource @PolySink;
//Gets the data associated with the specified position in the list.

//long getItemIdAtPosition(int position);

//int getLastVisiblePosition();
//Returns the position within the adapter's data set for the last item displayed on screen.

//final AdapterView.OnItemClickListener getOnItemClickListener();

//final AdapterView.OnItemLongClickListener getOnItemLongClickListener();

//final AdapterView.OnItemSelectedListener getOnItemSelectedListener();

//int getPositionForView(View view);
//Get the position within the adapter's data set for the view, where view is a an adapter item or a descendant of an adapter item.

//Object getSelectedItem();

long getSelectedItemId();

int getSelectedItemPosition();
//Return the position of the currently selected item within the adapter's data set

//abstract View getSelectedView();

//void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

//void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

//boolean onRequestSendAccessibilityEvent(View child, AccessibilityEvent event);
//Called when a child has requested sending an AccessibilityEvent and gives an opportunity to its parent to augment the event.

//boolean performItemClick(View view, int position, long id);
//Call the OnItemClickListener, if it is defined.

//void removeAllViews();
//This method is not supported and throws an UnsupportedOperationException when called.

//void removeView(View child);
//This method is not supported and throws an UnsupportedOperationException when called.

//void removeViewAt(int index);
//This method is not supported and throws an UnsupportedOperationException when called.

//abstract void setAdapter(T adapter);
//Sets the adapter that provides the data and the views to represent the data in this widget.

void setEmptyView(@Sink(FlowPermission.DISPLAY) View emptyView);
//Sets the view to show if the adapter is empty

//void setFocusable(boolean focusable);
//Set whether this view can receive the focus.

//void setFocusableInTouchMode(boolean focusable);
//Set whether this view can receive focus while in touch mode.

//void setOnClickListener(View.OnClickListener l);
//Register a callback to be invoked when this view is clicked.

void setOnItemClickListener(AdapterView.OnItemClickListener listener);
//Register a callback to be invoked when an item in this AdapterView has been clicked.

void setOnItemLongClickListener(AdapterView.OnItemLongClickListener listener);
//Register a callback to be invoked when an item in this AdapterView has been clicked and held

void setOnItemSelectedListener(AdapterView.OnItemSelectedListener listener);
//Register a callback to be invoked when an item in this AdapterView has been selected.

//abstract void setSelection(int position);
//Sets the currently selected item.


//PROTECTED
//boolean canAnimate();
//Indicates whether the view group has the ability to animate its children after the first layout.

//void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
//Override to prevent thawing of any views created by the adapter.

//void dispatchSaveInstanceState(SparseArray<Parcelable> container);
//Override to prevent freezing of any views created by the adapter.

//void onDetachedFromWindow();
//This is called when the view is detached from a window.

//void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.


}

class AdapterView$OnItemSelectedListener{
        void onNothingSelected(AdapterView<?> arg0);
        void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3);
		void onItemClick(@Source(FlowPermission.USER_INPUT)AdapterView<?> arg0,
   	 	@Source(FlowPermission.USER_INPUT)View arg1, @Source(FlowPermission.USER_INPUT)int arg2,
   		@Source(FlowPermission.USER_INPUT)long arg3);
                    void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3);

}

class ArrayAdapter<T> {
        ArrayAdapter(Context context, int textViewResourceId, List<T> objects);
        ArrayAdapter(Context context, int textViewResourceId);

void add(T object);
//Adds the specified object at the end of the array.

void addAll(Collection<? extends T> collection);
//Adds the specified Collection at the end of the array.

void addAll(T... items);
//Adds the specified items at the end of the array.

void clear();
//Remove all elements from the list.

static ArrayAdapter<CharSequence> createFromResource(Context context, int textArrayResId, int textViewResId);
//Creates a new ArrayAdapter from external resources.

Context getContext();
//Returns the context associated with this array adapter.

int getCount();

@Sink(CONDITIONAL) View getDropDownView(int position, View convertView, ViewGroup parent);
//Get a View that displays in the drop down popup the data at the specified position in the data set.

Filter getFilter();
//Returns a filter that can be used to constrain data with a filtering pattern.

T getItem(int position);

long getItemId(int position);

int getPosition(T item);
//Returns the position of the specified item in the array.

View getView(int position, View convertView, ViewGroup parent);

void insert(T object, int index);
//Inserts the specified object at the specified index in the array.

void notifyDataSetChanged();
//Notifies the attached observers that the underlying data has been changed and any View reflecting the data set should refresh itself.

void remove(T object);
//Removes the specified object from the array.

void setDropDownViewResource(int resource);
//Sets the layout resource to create the drop down views.

void setNotifyOnChange(boolean notifyOnChange);
//Control whether methods that change the list (add(T);, insert(T, int);, remove(T);, clear();); automatically call notifyDataSetChanged();.

void sort(Comparator<? super T> comparator);
//Sorts the content of this adapter using the specified comparator.

}

class BaseAdapter {
    
boolean areAllItemsEnabled();
//Indicates whether all the items in this adapter are enabled.

@Sink(CONDITIONAL)  View getDropDownView(int position, View convertView, ViewGroup parent);
//Get a View that displays in the drop down popup the data at the specified position in the data set.

int getItemViewType(int position);
//Get the type of View that will be created by getView(int, View, ViewGroup); for the specified item.

int getViewTypeCount();
//Returns the number of types of Views that will be created by getView(int, View, ViewGroup);.

boolean hasStableIds();
//Indicates whether the item ids are stable across changes to the underlying data.

boolean isEmpty();

boolean isEnabled(int position);
//Returns true if the item at the specified position is not a separator.

void notifyDataSetChanged();
//Notifies the attached observers that the underlying data has been changed and any View reflecting the data set should refresh itself.

void notifyDataSetInvalidated();
//Notifies the attached observers that the underlying data is no longer valid or available.

void registerDataSetObserver(DataSetObserver observer);
//Register an observer that is called when changes happen to the data used by this adapter.

void unregisterDataSetObserver(DataSetObserver observer);
//Unregister an observer that has previously been registered with this adapter via registerDataSetObserver(DataSetObserver);.

}

class BaseExpandableListAdapter{
BaseExpandableListAdapter();
void notifyDataSetChanged();
}

class Button {

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

}


interface Checkable {
abstract boolean isChecked();

abstract void setChecked(boolean checked);
//Change the checked state of the view

//abstract void toggle();
//Change the checked state of the view to the inverse of its current state
}

class CheckBox {

//void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

//void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

}

class CompoundButton {

//int getCompoundPaddingLeft();
//Returns the left padding of the view, plus space for the left Drawable if any.

//int getCompoundPaddingRight();
//Returns the right padding of the view, plus space for the right Drawable if any.

boolean isChecked();

//void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

//void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

//void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

//void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

//Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

//boolean performClick();
//Call this view's OnClickListener, if it is defined.

//void setButtonDrawable(int resid);
//Set the background to a given Drawable, identified by its resource id.

//void setButtonDrawable(Drawable d);
//Set the background to a given Drawable

void setChecked(@Sink(DISPLAY) boolean checked);
//Changes the checked state of this button.

void setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener listener);
//Register a callback to be invoked when the checked state of this button changes.

//void toggle();
//Change the checked state of the view to the inverse of its current state

//Protected Methods
//void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

//int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

//void onDraw(Canvas canvas);
//Implement this to do your drawing.

//boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.

}

class CompoundButton$OnCheckedChangeListener{
            void onCheckedChanged(CompoundButton arg0, boolean arg1);
}

class CursorAdapter {
    
    
abstract void bindView(View view, Context context, Cursor cursor);
//Bind an existing view to the data pointed to by cursor

void changeCursor(Cursor cursor);
//Change the underlying cursor to a new cursor.

CharSequence convertToString(Cursor cursor);
//Converts the cursor into a CharSequence.

int getCount();

Cursor getCursor();
//Returns the cursor.

@Sink(CONDITIONAL) View getDropDownView(int position, View convertView, ViewGroup parent);
//Get a View that displays in the drop down popup the data at the specified position in the data set.

Filter getFilter();
//Returns a filter that can be used to constrain data with a filtering pattern.

FilterQueryProvider getFilterQueryProvider();
//Returns the query filter provider used for filtering.

Object getItem(int position);

long getItemId(int position);

View getView(int position, View convertView, ViewGroup parent);

boolean hasStableIds();
//Indicates whether the item ids are stable across changes to the underlying data.

View newDropDownView(Context context, Cursor cursor, ViewGroup parent);
//Makes a new drop down view to hold the data pointed to by cursor.

abstract View newView(Context context, Cursor cursor, ViewGroup parent);
//Makes a new view to hold the data pointed to by cursor.

Cursor runQueryOnBackgroundThread(CharSequence constraint);
//Runs a query with the specified constraint.

void setFilterQueryProvider(FilterQueryProvider filterQueryProvider);
//Sets the query filter provider used to filter the current Cursor.

Cursor swapCursor(Cursor newCursor);
//Swap in a new Cursor, returning the old Cursor.

//Protected Methods
void init(Context context, Cursor c, boolean autoRequery);
//This method was deprecated in API level 11. Don't use this, use the normal constructor. This will be removed in the future.

void onContentChanged();
//Called when the ContentObserver on the cursor receives a change notification.




}

class DatePicker {
    
boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

CalendarView getCalendarView();
//Gets the CalendarView.

boolean getCalendarViewShown();
//Gets whether the CalendarView is shown.

int getDayOfMonth();

long getMaxDate();
//Gets the maximal date supported by this DatePicker in milliseconds since January 1, 1970 00:00:00 in getDefault(); time zone.

long getMinDate();
//Gets the minimal date supported by this DatePicker in milliseconds since January 1, 1970 00:00:00 in getDefault(); time zone.

int getMonth();

boolean getSpinnersShown();
//Gets whether the spinners are shown.

int getYear();

void init(int year, int monthOfYear, int dayOfMonth, DatePicker.OnDateChangedListener onDateChangedListener);
//Initialize the state.

boolean isEnabled();
//Returns the enabled status for this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

void setCalendarViewShown(boolean shown);
//Sets whether the CalendarView is shown.

void setEnabled(@Sink(DISPLAY) boolean enabled);
//Set the enabled state of this view.

void setMaxDate(long maxDate);
//Sets the maximal date supported by this DatePicker in milliseconds since January 1, 1970 00:00:00 in getDefault(); time zone.

void setMinDate(long minDate);
//Sets the minimal date supported by this NumberPicker in milliseconds since January 1, 1970 00:00:00 in getDefault(); time zone.

void setSpinnersShown(@Sink(DISPLAY) boolean shown);
//Sets whether the spinners are shown.

void updateDate(@Sink(DISPLAY) int year, @Sink(DISPLAY) int month, @Sink(DISPLAY) int dayOfMonth);
//Updates the current date.

//Protected Methods
void dispatchRestoreInstanceState(SparseArray<Parcelable> container);
//Called by restoreHierarchyState(android.util.SparseArray); to retrieve the state for this view and its children.

void onConfigurationChanged(Configuration newConfig);
//Called when the current configuration of the resources being used by the application have changed.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.




}

class EditText {
    
void extendSelection(int index);
//Convenience for extendSelection(Spannable, int);.

@Source(USER_INPUT) Editable getText();
//Return the text the TextView is displaying.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void selectAll();
//Convenience for selectAll(Spannable);.

void setEllipsize(TextUtils.TruncateAt ellipsis);
//Causes words in the text that are longer than the view is wide to be ellipsized instead of broken in the middle.

void setSelection(int index);
//Convenience for setSelection(Spannable, int);.

void setSelection(int start, int stop);
//Convenience for setSelection(Spannable, int, int);.

void setText(@Sink(DISPLAY )CharSequence text, TextView.BufferType type);
//Sets the text that this TextView is to display (see setText(CharSequence);); and also sets whether it is stored in a styleable/spannable buffer and whether it is editable.

}

class ExpandableListAdapter{
Object getChild(int arg0, int arg1);
boolean hasStableIds();
long getChildId(int arg0, int arg1);
long getGroupId(int arg0);
int getGroupCount();
int getChildrenCount(int arg0);
View getGroupView(int arg0, boolean arg1, View arg2, ViewGroup arg3);
boolean isChildSelectable(int arg0, int arg1);
Object getGroup(int arg0);
View getChildView(int arg0, int arg1, boolean arg2, View arg3, ViewGroup arg4);
}

class ExpandableListView{
static int getPackedPositionChild(long packedPosition);
static int getPackedPositionGroup(long packedPosition);
static int getPackedPositionType(long packedPosition);
}

class ExpandableListView$OnChildClickListener{
        boolean onChildClick(ExpandableListView arg0, View arg1, int arg2, int arg3, long arg4);
}
class FrameLayout$LayoutParams{
        LayoutParams(int width, int height);
}

class Filter {
    
CharSequence convertResultToString(Object resultValue);
//Converts a value from the filtered set into a CharSequence.

final void filter(CharSequence constraint, Filter.FilterListener listener);
//Starts an asynchronous filtering operation.

final void filter(CharSequence constraint);
//Starts an asynchronous filtering operation.

//Protected Methods
abstract Filter.FilterResults performFiltering(CharSequence constraint);
//Invoked in a worker thread to filter the data according to the constraint.

abstract void publishResults(CharSequence constraint, Filter.FilterResults results);
//Invoked in the UI thread to publish the filtering results in the user interface.

}

class Filter$FilterResults{
        FilterResults();
}

class Filterable{
        Filter getFilter();
}

class FilterQueryProvider {
    
    
abstract Cursor runQuery(CharSequence constraint);
//Runs a query with the specified constraint.

    
    
}

class FrameLayout {
void draw(Canvas canvas);
//Manually render this view (and all of its children); to the given Canvas.

boolean gatherTransparentRegion(Region region);
//This is used by the RootView to perform an optimization when the view hierarchy contains one or several SurfaceView.

FrameLayout.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

boolean getConsiderGoneChildrenWhenMeasuring();
//This method was deprecated in API level 14. This method is deprecated in favor of getMeasureAllChildren();, which was renamed for consistency with setMeasureAllChildren();.

Drawable getForeground();
//Returns the drawable used as the foreground of this FrameLayout.

int getForegroundGravity();
//Describes how the foreground is positioned.

boolean getMeasureAllChildren();
//Determines whether all children, or just those in the VISIBLE or INVISIBLE state, are considered when measuring.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void setForeground(@Sink(DISPLAY) Drawable drawable);
//Supply a Drawable that is to be rendered on top of all of the child views in the frame layout.

void setForegroundGravity(int foregroundGravity);
//Describes how the foreground is positioned.

void setMeasureAllChildren(boolean measureAll);
//Sets whether to consider all children, or just those in the VISIBLE or INVISIBLE state, when measuring.

boolean shouldDelayChildPressedState();
//Return true if the pressed state should be delayed for children or descendants of this ViewGroup.

//Protected Methods
boolean checkLayoutParams(ViewGroup.LayoutParams p);

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

FrameLayout.LayoutParams generateDefaultLayoutParams();
//Returns a set of layout parameters with a width of MATCH_PARENT, and a height of MATCH_PARENT.

ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.

}

class FrameLayout$LayoutParams {
    
    
    
}

class ImageButton {
    
    
void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

//Protected Methods
boolean onSetAlpha(int alpha);
//Invoked if there is a Transform that involves alpha.


}

class ImageView {

final void clearColorFilter();

boolean getAdjustViewBounds();
//True when ImageView is adjusting its bounds to preserve the aspect ratio of its drawable

int getBaseline();
//Return the offset of the widget's text baseline from the widget's top boundary.

boolean getBaselineAlignBottom();
//Return whether this view's baseline will be considered the bottom of the view.

ColorFilter getColorFilter();
//Returns the active color filter for this ImageView.

boolean getCropToPadding();
//Return whether this ImageView crops to padding.

Drawable getDrawable();
//Return the view's drawable, or null if no drawable has been assigned.

int getImageAlpha();
//Returns the alpha that will be applied to the drawable of this ImageView.

Matrix getImageMatrix();
//Return the view's optional matrix.

int getMaxHeight();
//The maximum height of this view.

int getMaxWidth();
//The maximum width of this view.

ImageView.ScaleType getScaleType();
//Return the current scale type in use by this ImageView.

boolean hasOverlappingRendering();
//Returns whether this View has content which overlaps.

void invalidateDrawable(Drawable dr);
//Invalidates the specified Drawable.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

void setAdjustViewBounds(boolean adjustViewBounds);
//Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable.

void setAlpha(int alpha);
//This method was deprecated in API level 16. use #setImageAlpha(int); instead

void setBaseline(int baseline);
//Set the offset of the widget's text baseline from the widget's top boundary.

void setBaselineAlignBottom(boolean aligned);
//Set whether to set the baseline of this view to the bottom of the view.

final void setColorFilter(int color);
//Set a tinting option for the image.

void setColorFilter(ColorFilter cf);
//Apply an arbitrary colorfilter to the image.

final void setColorFilter(int color, PorterDuff.Mode mode);
//Set a tinting option for the image.

void setCropToPadding(boolean cropToPadding);
//Sets whether this ImageView will crop to padding.

void setImageAlpha(int alpha);
//Sets the alpha value that should be applied to the image.

void setImageBitmap(@Sink(DISPLAY) Bitmap bm);
//Sets a Bitmap as the content of this ImageView.

void setImageDrawable(@Sink(DISPLAY) Drawable drawable);
//Sets a drawable as the content of this ImageView.

void setImageLevel(int level);
//Sets the image level, when it is constructed from a LevelListDrawable.

void setImageMatrix(Matrix matrix);

void setImageResource(int resId);
//Sets a drawable as the content of this ImageView.

void setImageState(int[] state, boolean merge);

void setImageURI(Uri uri);
//Sets the content of this ImageView to the specified Uri.

void setMaxHeight(int maxHeight);
//An optional argument to supply a maximum height for this view.

void setMaxWidth(int maxWidth);
//An optional argument to supply a maximum width for this view.

void setScaleType(ImageView.ScaleType scaleType);
//Controls how the image should be resized or moved to match the size of this ImageView.

void setSelected(@Sink(DISPLAY) boolean selected);
//Changes the selection state of this view.

void setVisibility(int visibility);
//Set the enabled state of this view.

//Protected Methods
void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

boolean setFrame(int l, int t, int r, int b);
//Assign a size and position to this view.

boolean verifyDrawable(Drawable dr);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.

}

class LinearLayout {

LinearLayout.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

int getBaseline();
//Return the offset of the widget's text baseline from the widget's top boundary.

int getBaselineAlignedChildIndex();
//Drawable getDividerDrawable();

int getDividerPadding();
//Get the padding size used to inset dividers in pixels

int getOrientation();
//Returns the current orientation.

int getShowDividers();

float getWeightSum();
//Returns the desired weights sum.

boolean isBaselineAligned();
//Indicates whether widgets contained within this layout are aligned on their baseline or not.

boolean isMeasureWithLargestChildEnabled();
//When true, all children with a weight will be considered having the minimum size of the largest child.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void setBaselineAligned(boolean baselineAligned);
//Defines whether widgets contained in this layout are baseline-aligned or not.

void setBaselineAlignedChildIndex(int i);

void setDividerDrawable(@Sink(DISPLAY) Drawable divider);
//Set a drawable to be used as a divider between items.

void setDividerPadding(int padding);
//Set padding displayed on both ends of dividers.

void setGravity(int gravity);
//Describes how the child views are positioned.

void setHorizontalGravity(int horizontalGravity);

void setMeasureWithLargestChildEnabled(boolean enabled);
//When set to true, all children with a weight will be considered having the minimum size of the largest child.

void setOrientation(int orientation);
//Should the layout be a column or a row.

void setShowDividers(int showDividers);
//Set how dividers should be shown between items in this layout

void setVerticalGravity(int verticalGravity);

void setWeightSum(float weightSum);
//Defines the desired weights sum.

boolean shouldDelayChildPressedState();
//Return true if the pressed state should be delayed for children or descendants of this ViewGroup.


//Protected
boolean checkLayoutParams(ViewGroup.LayoutParams p);

LinearLayout.LayoutParams generateDefaultLayoutParams();
//Returns a set of layout parameters with a width of MATCH_PARENT and a height of WRAP_CONTENT when the layout's orientation is VERTICAL.

LinearLayout.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p);
//Returns a safe set of layout parameters based on the supplied layout params.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

}

class LinearLayout$LayoutParams{
        LayoutParams(int width, int height, float weight);
String debug(String output);
//Returns a String representation of this set of layout parameters.
}


class ListAdapter {
    
abstract boolean areAllItemsEnabled();
//Indicates whether all the items in this adapter are enabled.

abstract boolean isEnabled(int position);
//Returns true if the item at the specified position is not a separator.



}

class ListView {
void addFooterView(@Sink(DISPLAY) View v);
//Add a fixed view to appear at the bottom of the list.

void addFooterView(@Sink(DISPLAY) View v, Object data, boolean isSelectable);
//Add a fixed view to appear at the bottom of the list.

void addHeaderView(@Sink(DISPLAY) View v, Object data, boolean isSelectable);
//Add a fixed view to appear at the top of the list.

void addHeaderView(@Sink(DISPLAY) View v);
//Add a fixed view to appear at the top of the list.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

ListAdapter getAdapter();
//Returns the adapter currently in use in this ListView.

long[] getCheckItemIds();
//This method was deprecated in API level 8. Use getCheckedItemIds(); instead.

Drawable getDivider();
//Returns the drawable that will be drawn between each item in the list.

int getDividerHeight();

int getFooterViewsCount();
//Returns the number of footer views in the list.

int getHeaderViewsCount();
//Returns the number of header views in the list.

boolean getItemsCanFocus();

int getMaxScrollAmount();

Drawable getOverscrollFooter();

Drawable getOverscrollHeader();

boolean isOpaque();
//Indicates whether this View is opaque.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyUp();: perform clicking of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.

boolean removeFooterView(View v);
//Removes a previously-added footer view.

boolean removeHeaderView(View v);
//Removes a previously-added header view.

boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate);
//Called when a child of this group wants a particular rectangle to be positioned onto the screen.

void setAdapter(@Sink(FlowPermission.DISPLAY) ListAdapter adapter);
//Sets the data behind this ListView.

void setCacheColorHint(int color);
//When set to a non-zero value, the cache color hint indicates that this list is always drawn on top of a solid, single-color, opaque background.

void setDivider(Drawable divider);
//Sets the drawable that will be drawn between each item in the list.

void setDividerHeight(int height);
//Sets the height of the divider that will be drawn between each item in the list.

void setFooterDividersEnabled(boolean footerDividersEnabled);
//Enables or disables the drawing of the divider for footer views.

void setHeaderDividersEnabled(boolean headerDividersEnabled);
//Enables or disables the drawing of the divider for header views.

void setItemsCanFocus(boolean itemsCanFocus);
//Indicates that the views created by the ListAdapter can contain focusable items.

void setOverscrollFooter(@Sink(DISPLAY) Drawable footer);
//Sets the drawable that will be drawn below all other list content.

void setOverscrollHeader(@Sink(DISPLAY) Drawable header);
//Sets the drawable that will be drawn above all other list content.

void setRemoteViewsAdapter(Intent intent);
//Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService through the specified intent.

void setSelection(@Sink(DISPLAY) int position);
//Sets the currently selected item.

void setSelectionAfterHeaderView();
//setSelectionAfterHeaderView set the selection to be the first list item after the header views.

void setSelectionFromTop(int position, int y);
//Sets the selected item and positions the selection y pixels from the top edge of the ListView.

void smoothScrollByOffset(int offset);
//Smoothly scroll to the specified adapter position offset.

void smoothScrollToPosition(int position);
//Smoothly scroll to the specified adapter position.



//Protected
boolean canAnimate();
//Indicates whether the view group has the ability to animate its children after the first layout.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

boolean drawChild(Canvas canvas, View child, long drawingTime);
//Draw one child of this View Group.

View findViewTraversal(int id);

View findViewWithTagTraversal(Object tag);

void layoutChildren();
//Subclasses must override this method to layout their children.

void onFinishInflate();
//Finalize inflating a view from XML.

void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect);
//Called by the view system when the focus state of this view changes.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

}

class MediaController {
    
    
boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

void hide();
//Remove the controller from the screen.

boolean isShowing();

void onFinishInflate();
//Finalize inflating a view from XML.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.

boolean onTrackballEvent(MotionEvent ev);
//Implement this method to handle trackball motion events.

void setAnchorView(View view);
//Set the view that acts as the anchor for the control view.

void setEnabled(boolean enabled);
//Set the enabled state of this view.

void setMediaPlayer(MediaController.MediaPlayerControl player);

void setPrevNextListeners(View.OnClickListener next, View.OnClickListener prev);

void show(int timeout);
//Show the controller on screen.

void show() @Sink(DISPLAY);
//Show the controller on screen.



}

class NumberPicker {
    
void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

boolean dispatchTouchEvent(MotionEvent event);
//Pass the touch screen motion event down to the target view, or this view if it is the target.

boolean dispatchTrackballEvent(MotionEvent event);
//Pass a trackball motion event down to the focused view.

AccessibilityNodeProvider getAccessibilityNodeProvider();
//Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.

String[] getDisplayedValues();
//Gets the values to be displayed instead of string values.

int getMaxValue();
//Returns the max value of the picker.

int getMinValue();
//Returns the min value of the picker.

int getSolidColor();
//Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.

int getValue();
//Returns the value of the picker.

boolean getWrapSelectorWheel();
//Gets whether the selector wheel wraps when reaching the min/max value.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

boolean onInterceptTouchEvent(MotionEvent event);
//Implement this method to intercept all touch screen motion events.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.

void scrollBy(int x, int y);
//Move the scrolled position of your view.

void setDisplayedValues(@Sink(DISPLAY) String[] displayedValues);
//Sets the values to be displayed.

void setEnabled(@Sink(DISPLAY) boolean enabled);
//Set the enabled state of this view.

void setFormatter(NumberPicker.Formatter formatter);
//Set the formatter to be used for formatting the current value.

void setMaxValue(@Sink(DISPLAY) int maxValue);
//Sets the max value of the picker.

void setMinValue(@Sink(DISPLAY) int minValue);
//Sets the min value of the picker.

void setOnLongPressUpdateInterval(long intervalMillis);
//Sets the speed at which the numbers be incremented and decremented when the up and down buttons are long pressed respectively.

void setOnScrollListener(NumberPicker.OnScrollListener onScrollListener);
//Set listener to be notified for scroll state changes.

void setOnValueChangedListener(NumberPicker.OnValueChangeListener onValueChangedListener);
//Sets the listener to be notified on change of the current value.

void setValue(@Sink(DISPLAY) int value);
//Set the current value for the number picker.

void setWrapSelectorWheel(boolean wrapSelectorWheel);
//Sets whether the selector wheel shown during flinging/scrolling should wrap around the getMinValue(); and getMaxValue(); values.

//Protected Methods
boolean dispatchHoverEvent(MotionEvent event);
//Dispatch a hover event.

float getBottomFadingEdgeStrength();
//Returns the strength, or intensity, of the bottom faded edge.

float getTopFadingEdgeStrength();
//Returns the strength, or intensity, of the top faded edge.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.



}

class PopupMenu {
    

void dismiss();
//Dismiss the menu popup.

Menu getMenu();

MenuInflater getMenuInflater();

void inflate(int menuRes);
//Inflate a menu resource into this PopupMenu.

void setOnDismissListener(PopupMenu.OnDismissListener listener);
//Set a listener that will be notified when this menu is dismissed.

void setOnMenuItemClickListener(PopupMenu.OnMenuItemClickListener listener);
//Set a listener that will be notified when the user selects an item from the menu.

void show() @Sink(DISPLAY);
//Show the menu popup anchored to the view specified during construction.



}

class ProgressBar {
    
    
Drawable getIndeterminateDrawable();
//Get the drawable used to draw the progress bar in indeterminate mode.

Interpolator getInterpolator();
//Gets the acceleration curve type for the indeterminate animation.

synchronized int getMax();
//Return the upper limit of this progress bar's range.

synchronized int getProgress();
//Get the progress bar's current level of progress.

Drawable getProgressDrawable();
//Get the drawable used to draw the progress bar in progress mode.

synchronized int getSecondaryProgress();
//Get the progress bar's current level of secondary progress.

synchronized final void incrementProgressBy(@Sink(DISPLAY) int diff);
//Increase the progress bar's progress by the specified amount.

synchronized final void incrementSecondaryProgressBy(@Sink(DISPLAY) int diff);
//Increase the progress bar's secondary progress by the specified amount.

void invalidateDrawable(Drawable dr);
//Invalidates the specified Drawable.

synchronized boolean isIndeterminate();
//Indicate whether this progress bar is in indeterminate mode.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

void postInvalidate();
//Cause an invalidate to happen on a subsequent cycle through the event loop.

synchronized void setIndeterminate(@Sink(DISPLAY) boolean indeterminate);
//Change the indeterminate mode for this progress bar.

void setIndeterminateDrawable(@Sink(DISPLAY) Drawable d);
//Define the drawable used to draw the progress bar in indeterminate mode.

void setInterpolator(Context context, int resID);
//Sets the acceleration curve for the indeterminate animation.

void setInterpolator(Interpolator interpolator);
//Sets the acceleration curve for the indeterminate animation.

synchronized void setMax(@Sink(DISPLAY) int max);
//Set the range of the progress bar to 0...

synchronized void setProgress(@Sink(DISPLAY) int progress);
//Set the current progress to the specified value.

void setProgressDrawable(@Sink(DISPLAY) Drawable d);
//Define the drawable used to draw the progress bar in progress mode.

synchronized void setSecondaryProgress(@Sink(DISPLAY) int secondaryProgress);
//Set the current secondary progress to the specified value.

void setVisibility(@Sink(DISPLAY) int v);
//Set the enabled state of this view.

//Protected Methods
void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

synchronized void onDraw(Canvas canvas);
//Implement this to do your drawing.

synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.

void onVisibilityChanged(View changedView, int visibility);
//Called when the visibility of the view or an ancestor of the view is changed.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.



}

class RadioButton {
    
void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void toggle();
//Change the checked state of the view to the inverse of its current state
//If the radio button is already checked, this method will not toggle the radio button.



}

class RadioGroup {
    
void addView(@Sink(DISPLAY) View child, int index, ViewGroup.LayoutParams params);
//Adds a child view with the specified layout parameters.

void check(int id);
//Sets the selection to the radio button whose identifier is passed in parameter.

void clearCheck();
//Clears the selection.

RadioGroup.LayoutParams generateLayoutParams(AttributeSet attrs);
//Returns a new set of layout parameters based on the supplied attributes set.

int getCheckedRadioButtonId();
//Returns the identifier of the selected radio button in this group.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void setOnCheckedChangeListener(RadioGroup.OnCheckedChangeListener listener);
//Register a callback to be invoked when the checked radio button changes in this group.

void setOnHierarchyChangeListener(ViewGroup.OnHierarchyChangeListener listener);
//Register a callback to be invoked when a child is added to or removed from this view.

//Protected Methods
boolean checkLayoutParams(ViewGroup.LayoutParams p);

LinearLayout.LayoutParams generateDefaultLayoutParams();
//Returns a set of layout parameters with a width of MATCH_PARENT and a height of WRAP_CONTENT when the layout's orientation is VERTICAL.

void onFinishInflate();
//Finalize inflating a view from XML.



}

class RatingBar {
    
int getNumStars();
//Returns the number of stars shown.

RatingBar.OnRatingBarChangeListener getOnRatingBarChangeListener();

float getRating();
//Gets the current rating (number of stars filled);.

float getStepSize();
//Gets the step size of this rating bar.

boolean isIndicator();

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void setIsIndicator(boolean isIndicator);
//Whether this rating bar should only be an indicator (thus non-changeable by the user);.

synchronized void setMax(@Sink(DISPLAY) int max);
//Set the range of the progress bar to 0...

void setNumStars(@Sink(DISPLAY) int numStars);
//Sets the number of stars to show.

void setOnRatingBarChangeListener(RatingBar.OnRatingBarChangeListener listener);
//Sets the listener to be called when the rating changes.

void setRating(@Sink(DISPLAY) float rating);
//Sets the rating (the number of stars filled);.

void setStepSize(@Sink(DISPLAY) float stepSize);
//Sets the step size (granularity); of this rating bar.

//Protected Methods
synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.




}

class ShareActionProvider{
            void setShareIntent(Intent shareIntent);
            void setShareHistoryFileName(String shareHistoryFile);
}

class Scroller {
void abortAnimation();
//Stops the animation.

boolean computeScrollOffset();
//Call this when you want to know the new location.

void extendDuration(int extend);
//Extend the scroll animation.

void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY);
//Start scrolling based on a fling gesture.

final void forceFinished(boolean finished);
//Force the finished field to a particular value.

float getCurrVelocity();
//Returns the current velocity.

final int getCurrX();
//Returns the current X offset in the scroll.

final int getCurrY();
//Returns the current Y offset in the scroll.

final int getDuration();
//Returns how long the scroll event will take, in milliseconds.

final int getFinalX();
//Returns where the scroll will end.

final int getFinalY();
//Returns where the scroll will end.

final int getStartX();
//Returns the start X offset in the scroll.

final int getStartY();
//Returns the start Y offset in the scroll.

final boolean isFinished();
//Returns whether the scroller has finished scrolling.

void setFinalX(int newX);
//Sets the final position (X); for this scroller.

void setFinalY(int newY);
//Sets the final position (Y); for this scroller.

final void setFriction(float friction);
//The amount of friction applied to flings.

void startScroll(int startX, int startY, int dx, int dy);
//Start scrolling by providing a starting point and the distance to travel.

void startScroll(int startX, int startY, int dx, int dy, int duration);
//Start scrolling by providing a starting point, the distance to travel, and the duration of the scroll.

int timePassed();
//Returns the time elapsed since the beginning of the scrolling.

}

class SearchView {
    
    
int getImeOptions();
//Returns the IME options set on the query text field.

int getInputType();
//Returns the input type set on the query text field.

int getMaxWidth();
//Gets the specified maximum width in pixels, if set.

CharSequence getQuery();
//Returns the query string currently in the text field.

CharSequence getQueryHint();
//Gets the hint text to display in the query text field.

CursorAdapter getSuggestionsAdapter();
//Returns the adapter used for suggestions, if any.

boolean isIconfiedByDefault();
//Returns the default iconified state of the search field.

boolean isIconified();
//Returns the current iconified state of the SearchView.

boolean isQueryRefinementEnabled();
//Returns whether query refinement is enabled for all items or only specific ones.

boolean isSubmitButtonEnabled();
//Returns whether the submit button is enabled when necessary or never displayed.

void onActionViewCollapsed();
//Called when this view is collapsed as an action view.

void onActionViewExpanded();
//Called when this view is expanded as an action view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(int keyCode, KeyEvent event);
//Handles the key down event for dealing with action keys.

void onRtlPropertiesChanged(int layoutDirection);
//Called when any RTL property (layout direction or text direction or text alignment); has been changed.

void onWindowFocusChanged(boolean hasWindowFocus);
//Called when the window containing this view gains or loses focus.

void setIconified(boolean iconify);
//Iconifies or expands the SearchView.

void setIconifiedByDefault(boolean iconified);
//Sets the default or resting state of the search field.

void setImeOptions(int imeOptions);
//Sets the IME options on the query text field.

void setInputType(int inputType);
//Sets the input type on the query text field.

void setMaxWidth(int maxpixels);
//Makes the view at most this many pixels wide

void setOnCloseListener(SearchView.OnCloseListener listener);
//Sets a listener to inform when the user closes the SearchView.

void setOnQueryTextFocusChangeListener(View.OnFocusChangeListener listener);
//Sets a listener to inform when the focus of the query text field changes.

void setOnQueryTextListener(SearchView.OnQueryTextListener listener);
//Sets a listener for user actions within the SearchView.

void setOnSearchClickListener(View.OnClickListener listener);
//Sets a listener to inform when the search button is pressed.

void setOnSuggestionListener(SearchView.OnSuggestionListener listener);
//Sets a listener to inform when a suggestion is focused or clicked.

void setQuery(CharSequence query, boolean submit);
//Sets a query string in the text field and optionally submits the query as well.

void setQueryHint(CharSequence hint);
//Sets the hint text to display in the query text field.

void setQueryRefinementEnabled(boolean enable);
//Specifies if a query refinement button should be displayed alongside each suggestion or if it should depend on the flags set in the individual items retrieved from the suggestions provider.

void setSearchableInfo(SearchableInfo searchable);
//Sets the SearchableInfo for this SearchView.

void setSubmitButtonEnabled(boolean enabled);
//Enables showing a submit button when the query is non-empty.

void setSuggestionsAdapter(CursorAdapter adapter);
//You can set a custom adapter if you wish.

//Protected Methods
void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.



}

class ShareActionProvider {
    
boolean hasSubMenu();
//Determines if this ActionProvider has a submenu associated with it.

View onCreateActionView();
//This method was deprecated in API level . use onCreateActionView(MenuItem);

void onPrepareSubMenu(SubMenu subMenu);
//Called to prepare an associated submenu for the menu item backed by this ActionProvider.

void setOnShareTargetSelectedListener(ShareActionProvider.OnShareTargetSelectedListener listener);
//Sets a listener to be notified when a share target has been selected.

void setShareHistoryFileName(String shareHistoryFile);
//Sets the file name of a file for persisting the share history which history will be used for ordering share targets.

void setShareIntent(Intent shareIntent);
//Sets an intent with information about the share action.


}

class TabHost{
            void addTab(@Sink(DISPLAY) TabSpec tabSpec);
            void setCurrentTab(int index);
            TabSpec newTabSpec(String tag);
}

class TabHost$OnTabChangeListener {
    
abstract void onTabChanged(String tabId);    
    
}

class TabHost$TabSpec{
            TabSpec setIndicator(@Sink(DISPLAY) CharSequence label);
            TabSpec setContent(Intent intent);
}


class TextView {
void addTextChangedListener(TextWatcher watcher);
//Adds a TextWatcher to the list of those whose methods are called whenever this TextView's text changes.

final void append(@Sink(DISPLAY) CharSequence text);
//Convenience method: Append the specified text to the TextView's display buffer, upgrading it to BufferType.EDITABLE if it was not already editable.

void append(@Sink(DISPLAY)CharSequence text, int start, int end);
//Convenience method: Append the specified text slice to the TextView's display buffer, upgrading it to BufferType.EDITABLE if it was not already editable.

void beginBatchEdit();
//boolean bringPointIntoView(int offset);
//Move the point, specified by the offset, into the view if it is needed.

void cancelLongPress();
//Cancels a pending long press.

void clearComposingText();
//Use BaseInputConnection.removeComposingSpans(); to remove any IME composing state from this text view.

void computeScroll();
//Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.

void debug(int depth);
//Prints information about this view in the log output, with the tag VIEW_LOG_TAG.

boolean didTouchFocusSelect();
//Returns true, only while processing a touch gesture, if the initial touch down event caused focus to move to the text view and as a result its selection changed.

void endBatchEdit();

boolean extractText(ExtractedTextRequest request, ExtractedText outText);
//If this TextView contains editable content, extract a portion of it based on the information in request in to outText.

void findViewsWithText(ArrayList<View> outViews, CharSequence searched, int flags);
//Finds the Views that contain given text.

final int getAutoLinkMask();
//Gets the autolink mask of the text.

int getBaseline();
//Return the offset of the widget's text baseline from the widget's top boundary.

int getCompoundDrawablePadding();
//Returns the padding between the compound drawables and the text.

Drawable[] getCompoundDrawables();
//Returns drawables for the left, top, right, and bottom borders.

Drawable[] getCompoundDrawablesRelative();
//Returns drawables for the start, top, end, and bottom borders.

int getCompoundPaddingBottom();
//Returns the bottom padding of the view, plus space for the bottom Drawable if any.

int getCompoundPaddingEnd();
//Returns the end padding of the view, plus space for the end Drawable if any.

int getCompoundPaddingLeft();
//Returns the left padding of the view, plus space for the left Drawable if any.

int getCompoundPaddingRight();
//Returns the right padding of the view, plus space for the right Drawable if any.

int getCompoundPaddingStart();
//Returns the start padding of the view, plus space for the start Drawable if any.

int getCompoundPaddingTop();
//Returns the top padding of the view, plus space for the top Drawable if any.

final int getCurrentHintTextColor();
//Return the current color selected to paint the hint text.

final int getCurrentTextColor();
//Return the current color selected for normal text.

ActionMode.Callback getCustomSelectionActionModeCallback();
//Retrieves the value set in setCustomSelectionActionModeCallback(ActionMode.Callback);.

Editable getEditableText();
//Return the text the TextView is displaying as an Editable object.

TextUtils.TruncateAt getEllipsize();
//Returns where, if anywhere, words that are longer than the view is wide should be ellipsized.

CharSequence getError();
//Returns the error message that was set to be displayed with setError(CharSequence);, or null if no error was set or if it the error was cleared by the widget after user input.

int getExtendedPaddingBottom();
//Returns the extended bottom padding of the view, including both the bottom Drawable if any and any extra space to keep more than maxLines of text from showing.

int getExtendedPaddingTop();
//Returns the extended top padding of the view, including both the top Drawable if any and any extra space to keep more than maxLines of text from showing.

InputFilter[] getFilters();
//Returns the current list of input filters.

void getFocusedRect(Rect r);
//When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.

boolean getFreezesText();
//Return whether this text view is including its entire text contents in frozen icicles.

int getGravity();
//Returns the horizontal and vertical alignment of this TextView.

int getHighlightColor();

CharSequence getHint();
//Returns the hint that is displayed when the text of the TextView is empty.

final ColorStateList getHintTextColors();

int getImeActionId();
//Get the IME action ID previous set with setImeActionLabel(CharSequence, int);.

CharSequence getImeActionLabel();
//Get the IME action label previous set with setImeActionLabel(CharSequence, int);.

int getImeOptions();
//Get the type of the IME editor.

boolean getIncludeFontPadding();
//Gets whether the TextView includes extra top and bottom padding to make room for accents that go above the normal ascent and descent.

Bundle getInputExtras(boolean create);
//Retrieve the input extras currently associated with the text view, which can be viewed as well as modified.

int getInputType();
//Get the type of the editable content.

final KeyListener getKeyListener();

final Layout getLayout();

int getLineBounds(int line, Rect bounds);
//Return the baseline for the specified line (0...getLineCount(); - 1); If bounds is not null, return the top, left, right, bottom extents of the specified line in it.

int getLineCount();
//Return the number of lines of text, or 0 if the internal Layout has not been built.

int getLineHeight();

float getLineSpacingExtra();
//Gets the line spacing extra space

float getLineSpacingMultiplier();
//Gets the line spacing multiplier

final ColorStateList getLinkTextColors();

final boolean getLinksClickable();
//Returns whether the movement method will automatically be set to LinkMovementMethod if setAutoLinkMask(int); has been set to nonzero and links are detected in setText(char[], int, int);.

int getMarqueeRepeatLimit();
//Gets the number of times the marquee animation is repeated.

int getMaxEms();

int getMaxHeight();

int getMaxLines();

int getMaxWidth();

int getMinEms();

int getMinHeight();

int getMinLines();

int getMinWidth();

final MovementMethod getMovementMethod();

int getOffsetForPosition(float x, float y);
//Get the character offset closest to the specified absolute position.

TextPaint getPaint();

int getPaintFlags();

String getPrivateImeOptions();
//Get the private type of the content.

int getSelectionEnd();
//Convenience for getSelectionEnd(CharSequence);.

int getSelectionStart();
//Convenience for getSelectionStart(CharSequence);.

int getShadowColor();

float getShadowDx();

float getShadowDy();

float getShadowRadius();
//Gets the radius of the shadow layer.

CharSequence getText();
//Return the text the TextView is displaying.

static int getTextColor(Context context, TypedArray attrs, int def);
//Returns the default color from the TextView_textColor attribute from the AttributeSet, if set, or the default color from the TextAppearance_textColor from the TextView_textAppearance attribute, if TextView_textColor was not set directly.

final ColorStateList getTextColors();
//Gets the text colors for the different states (normal, selected, focused); of the TextView.

static ColorStateList getTextColors(Context context, TypedArray attrs);
//Returns the TextView_textColor attribute from the Resources.StyledAttributes, if set, or the TextAppearance_textColor from the TextView_textAppearance attribute, if TextView_textColor was not set directly.

Locale getTextLocale();
//Get the default Locale of the text in this TextView.

float getTextScaleX();

float getTextSize();

int getTotalPaddingBottom();
//Returns the total bottom padding of the view, including the bottom Drawable if any, the extra space to keep more than maxLines from showing, and the vertical offset for gravity, if any.

int getTotalPaddingEnd();
//Returns the total end padding of the view, including the end Drawable if any.

int getTotalPaddingLeft();
//Returns the total left padding of the view, including the left Drawable if any.

int getTotalPaddingRight();
//Returns the total right padding of the view, including the right Drawable if any.

int getTotalPaddingStart();
//Returns the total start padding of the view, including the start Drawable if any.

int getTotalPaddingTop();
//Returns the total top padding of the view, including the top Drawable if any, the extra space to keep more than maxLines from showing, and the vertical offset for gravity, if any.

final TransformationMethod getTransformationMethod();

Typeface getTypeface();

URLSpan[] getUrls();
//Returns the list of URLSpans attached to the text (by Linkify or otherwise); if any.

boolean hasOverlappingRendering();
//Returns whether this View has content which overlaps.

boolean hasSelection();
//Return true iff there is a selection inside this text view.

void invalidateDrawable(Drawable drawable);
//Invalidates the specified Drawable.

boolean isCursorVisible();

boolean isInputMethodTarget();
//Returns whether this text view is a current input method target.

boolean isSuggestionsEnabled();
//Return whether or not suggestions are enabled on this TextView.

boolean isTextSelectable();
//Returns the state of the textIsSelectable flag (See setTextIsSelectable(););.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

int length();
//Returns the length, in characters, of the text managed by this TextView

boolean moveCursorToVisibleOffset();
//Move the cursor, if needed, so that it is at an offset that is visible to the user.

void onBeginBatchEdit();
//Called by the framework in response to a request to begin a batch of edit operations through a call to link beginBatchEdit();.

boolean onCheckIsTextEditor();
//Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it.

void onCommitCompletion(CompletionInfo text);
//Called by the framework in response to a text completion from the current input method, provided by it calling InputConnection.commitCompletion();.

void onCommitCorrection(CorrectionInfo info);
//Called by the framework in response to a text auto-correction (such as fixing a typo using a a dictionnary); from the current input method, provided by it calling commitCorrection(CorrectionInfo); InputConnection.commitCorrection();}.

InputConnection onCreateInputConnection(EditorInfo outAttrs);
//Create a new InputConnection for an InputMethod to interact with the view.

boolean onDragEvent(DragEvent event);
//Handles drag events sent by the system following a call to startDrag();.

void onEditorAction(int actionCode);
//Called when an attached input method calls InputConnection.performEditorAction(); for this text view.

void onEndBatchEdit();
//Called by the framework in response to a request to end a batch of edit operations through a call to link endBatchEdit();.

void onFinishTemporaryDetach();
//Called after onStartTemporaryDetach(); when the container is done changing the view.

boolean onGenericMotionEvent(MotionEvent event);
//Implement this method to handle generic motion events.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onKeyMultiple(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) int repeatCount, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyMultiple();: always returns false (doesn't handle the event);.

boolean onKeyPreIme(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Handle a key event before it is processed by any input method associated with the view hierarchy.

boolean onKeyShortcut(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Called on the focused view when a key shortcut event is not handled.

boolean onKeyUp(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyUp();: perform clicking of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

boolean onPreDraw();
//Callback method to be invoked when the view tree is about to be drawn.

boolean onPrivateIMECommand(String action, Bundle data);
//Called by the framework in response to a private command from the current method, provided by it calling InputConnection.performPrivateCommand();.

void onRestoreInstanceState(Parcelable state);
//Hook allowing a view to re-apply a representation of its internal state that had previously been generated by onSaveInstanceState();.

void onRtlPropertiesChanged(int layoutDirection);
//Called when any RTL property (layout direction or text direction or text alignment); has been changed.

Parcelable onSaveInstanceState();
//Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state.

void onScreenStateChanged(int screenState);
//This method is called whenever the state of the screen this view is attached to changes.

void onStartTemporaryDetach();
//This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent.

boolean onTextContextMenuItem(int id);
//Called when a context menu option for the text view is selected.

boolean onTouchEvent(MotionEvent event);
//Implement this method to handle touch screen motion events.

boolean onTrackballEvent(MotionEvent event);
//Implement this method to handle trackball motion events.

void onWindowFocusChanged(boolean hasWindowFocus);
//Called when the window containing this view gains or loses focus.

boolean performLongClick();
//Call this view's OnLongClickListener, if it is defined.

void removeTextChangedListener(TextWatcher watcher);
//Removes the specified TextWatcher from the list of those whose methods are called whenever this TextView's text changes.

void sendAccessibilityEvent(int eventType);
//Sends an accessibility event of the given type.

void setAllCaps(boolean allCaps);
//Sets the properties of this field to transform input to ALL CAPS display.

final void setAutoLinkMask(int mask);
//Sets the autolink mask of the text.

void setCompoundDrawablePadding(int pad);
//Sets the size of the padding between the compound drawables and the text.

void setCompoundDrawables(@Sink(DISPLAY) Drawable left, @Sink(DISPLAY) Drawable top, @Sink(DISPLAY) Drawable right, @Sink(DISPLAY) Drawable bottom);
//Sets the Drawables (if any); to appear to the left of, above, to the right of, and below the text.

void setCompoundDrawablesRelative(@Sink(DISPLAY) Drawable start, @Sink(DISPLAY) Drawable top, @Sink(DISPLAY) Drawable end, @Sink(DISPLAY) Drawable bottom);
//Sets the Drawables (if any); to appear to the start of, above, to the end of, and below the text.

void setCompoundDrawablesRelativeWithIntrinsicBounds(@Sink(DISPLAY) Drawable start, @Sink(DISPLAY) Drawable top, @Sink(DISPLAY) Drawable end, @Sink(DISPLAY) Drawable bottom);
//Sets the Drawables (if any); to appear to the start of, above, to the end of, and below the text.

void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom);
//Sets the Drawables (if any); to appear to the start of, above, to the end of, and below the text.

void setCompoundDrawablesWithIntrinsicBounds(@Sink(DISPLAY) Drawable left, @Sink(DISPLAY) Drawable top, @Sink(DISPLAY) Drawable right, @Sink(DISPLAY) Drawable bottom);
//Sets the Drawables (if any); to appear to the left of, above, to the right of, and below the text.

void setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom);
//Sets the Drawables (if any); to appear to the left of, above, to the right of, and below the text.

void setCursorVisible(boolean visible);
//Set whether the cursor is visible.

void setCustomSelectionActionModeCallback(ActionMode.Callback actionModeCallback);
//If provided, this ActionMode.Callback will be used to create the ActionMode when text selection is initiated in this View.

final void setEditableFactory(Editable.Factory factory);
//Sets the Factory used to create new Editables.

void setEllipsize(TextUtils.TruncateAt where);
//Causes words in the text that are longer than the view is wide to be ellipsized instead of broken in the middle.

void setEms(int ems);
//Makes the TextView exactly this many ems wide

void setEnabled(@Sink(DISPLAY) boolean enabled);
//Set the enabled state of this view.

void setError(@Sink(DISPLAY) CharSequence error);
//Sets the right-hand compound drawable of the TextView to the "error" icon and sets an error message that will be displayed in a popup when the TextView has focus.

void setError(@Sink(DISPLAY) CharSequence error, @Sink(DISPLAY) Drawable icon);
//Sets the right-hand compound drawable of the TextView to the specified icon and sets an error message that will be displayed in a popup when the TextView has focus.

void setExtractedText(ExtractedText text);
//Apply to this text view the given extracted text, as previously returned by extractText(ExtractedTextRequest, ExtractedText);.

void setFilters(InputFilter[] filters);
//Sets the list of input filters that will be used if the buffer is Editable.

void setFreezesText(boolean freezesText);
//Control whether this text view saves its entire text contents when freezing to an icicle, in addition to dynamic state such as cursor position.

void setGravity(int gravity);
//Sets the horizontal alignment of the text and the vertical gravity that will be used when there is extra space in the TextView beyond what is required for the text itself.

void setHeight(int pixels);
//Makes the TextView exactly this many pixels tall.

void setHighlightColor(int color);
//Sets the color used to display the selection highlight.

final void setHint(CharSequence hint);
//Sets the text to be displayed when the text of the TextView is empty.

final void setHint(int resid);
//Sets the text to be displayed when the text of the TextView is empty, from a resource.

final void setHintTextColor(ColorStateList colors);
//Sets the color of the hint text.

final void setHintTextColor(int color);
//Sets the color of the hint text for all the states (disabled, focussed, selected...); of this TextView.

void setHorizontallyScrolling(boolean whether);
//Sets whether the text should be allowed to be wider than the View is.

void setImeActionLabel(CharSequence label, int actionId);
//Change the custom IME action associated with the text view, which will be reported to an IME with actionLabel and actionId when it has focus.

void setImeOptions(int imeOptions);
//Change the editor type integer associated with the text view, which will be reported to an IME with imeOptions when it has focus.

void setIncludeFontPadding(boolean includepad);
//Set whether the TextView includes extra top and bottom padding to make room for accents that go above the normal ascent and descent.

void setInputExtras(int xmlResId);
//Set the extra input data of the text, which is the TextBoxAttribute.extras Bundle that will be filled in when creating an input connection.

void setInputType(int type);
//Set the type of the content with a constant as defined for inputType.

void setKeyListener(KeyListener input);
//Sets the key listener to be used with this TextView.

void setLineSpacing(float add, float mult);
//Sets line spacing for this TextView.

void setLines(@Sink(DISPLAY) int lines);
//Makes the TextView exactly this many lines tall.

final void setLinkTextColor(ColorStateList colors);
//Sets the color of links in the text.

final void setLinkTextColor(int color);
//Sets the color of links in the text.

final void setLinksClickable(boolean whether);
//Sets whether the movement method will automatically be set to LinkMovementMethod if setAutoLinkMask(int); has been set to nonzero and links are detected in setText(char[], int, int);.

void setMarqueeRepeatLimit(int marqueeLimit);
//Sets how many times to repeat the marquee animation.

void setMaxEms(int maxems);
//Makes the TextView at most this many ems wide

void setMaxHeight(int maxHeight);
//Makes the TextView at most this many pixels tall.

void setMaxLines(int maxlines);
//Makes the TextView at most this many lines tall.

void setMaxWidth(int maxpixels);
//Makes the TextView at most this many pixels wide

void setMinEms(int minems);
//Makes the TextView at least this many ems wide

void setMinHeight(int minHeight);
//Makes the TextView at least this many pixels tall.

void setMinLines(int minlines);
//Makes the TextView at least this many lines tall.

void setMinWidth(int minpixels);
//Makes the TextView at least this many pixels wide

final void setMovementMethod(MovementMethod movement);
//Sets the movement method (arrow key handler); to be used for this TextView.

void setOnEditorActionListener(TextView.OnEditorActionListener l);
//Set a special listener to be called when an action is performed on the text view.

void setPadding(int left, int top, int right, int bottom);
//Sets the padding.

void setPaddingRelative(int start, int top, int end, int bottom);
//Sets the relative padding.

void setPaintFlags(int flags);
//Sets flags on the Paint being used to display the text and reflows the text if they are different from the old flags.

void setPrivateImeOptions(String type);
//Set the private content type of the text, which is the EditorInfo.privateImeOptions field that will be filled in when creating an input connection.

void setRawInputType(int type);
//Directly change the content type integer of the text view, without modifying any other state.

void setScroller(Scroller s);

void setSelectAllOnFocus(boolean selectAllOnFocus);
//Set the TextView so that when it takes focus, all the text is selected.

void setSelected(@Sink(DISPLAY) boolean selected);
//Changes the selection state of this view.

void setShadowLayer(float radius, float dx, float dy, int color);
//Gives the text a shadow of the specified radius and color, the specified distance from its normal position.

void setSingleLine();
//Sets the properties of this field (lines, horizontally scrolling, transformation method); to be for a single-line input.

void setSingleLine(boolean singleLine);
//If true, sets the properties of this field (number of lines, horizontally scrolling, transformation method); to be for a single-line input; if false, restores these to the default conditions.

final void setSpannableFactory(Spannable.Factory factory);
//Sets the Factory used to create new Spannables.

final void setText(int resid);
//final void setText(char[] text, int start, int len);
//Sets the TextView to display the specified slice of the specified char array.

final void setText(int resid, TextView.BufferType type);
final void setText(@Sink(DISPLAY) CharSequence text);
//Sets the string value of the TextView.

void setText(@Sink(DISPLAY) CharSequence text, TextView.BufferType type);
//Sets the text that this TextView is to display (see setText(CharSequence);); and also sets whether it is stored in a styleable/spannable buffer and whether it is editable.

void setTextAppearance(Context context, int resid);
//Sets the text color, size, style, hint color, and highlight color from the specified TextAppearance resource.

void setTextColor(ColorStateList colors);
//Sets the text color.

void setTextColor(int color);
//Sets the text color for all the states (normal, selected, focused); to be this color.

void setTextIsSelectable(boolean selectable);
//Sets whether the content of this view is selectable by the user.

final void setTextKeepState(CharSequence text);
//Like setText(CharSequence);, except that the cursor position (if any); is retained in the new text.

final void setTextKeepState(CharSequence text, TextView.BufferType type);
//Like setText(CharSequence, android.widget.TextView.BufferType);, except that the cursor position (if any); is retained in the new text.

void setTextLocale(Locale locale);
//Set the default Locale of the text in this TextView to the given value.

void setTextScaleX(float size);
//Sets the extent by which text should be stretched horizontally.

void setTextSize(float size);
//Set the default text size to the given value, interpreted as "scaled pixel" units.

void setTextSize(int unit, float size);
//Set the default text size to a given unit and value.

final void setTransformationMethod(TransformationMethod method);
//Sets the transformation that is applied to the text that this TextView is displaying.

void setTypeface(Typeface tf, int style);
//Sets the typeface and style in which the text should be displayed, and turns on the fake bold and italic bits in the Paint if the Typeface that you provided does not have all the bits in the style that you specified.

void setTypeface(Typeface tf);
//Sets the typeface and style in which the text should be displayed.

void setWidth(int pixels);
//Makes the TextView exactly this many pixels wide.

//Protected Methods
int computeHorizontalScrollRange();
//Compute the horizontal range that the horizontal scrollbar represents.

int computeVerticalScrollExtent();
//Compute the vertical extent of the horizontal scrollbar's thumb within the vertical range.

int computeVerticalScrollRange();
//Compute the vertical range that the vertical scrollbar represents.

void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

int getBottomPaddingOffset();
//Amount by which to extend the bottom fading region.

boolean getDefaultEditable();
//Subclasses override this to specify that they have a KeyListener by default even if not specifically called for in the XML options.

MovementMethod getDefaultMovementMethod();
//Subclasses override this to specify a default movement method.

float getLeftFadingEdgeStrength();
//Returns the strength, or intensity, of the left faded edge.

int getLeftPaddingOffset();
//Amount by which to extend the left fading region.

float getRightFadingEdgeStrength();
//Returns the strength, or intensity, of the right faded edge.

int getRightPaddingOffset();
//Amount by which to extend the right fading region.

int getTopPaddingOffset();
//Amount by which to extend the top fading region.

boolean isPaddingOffsetRequired();
//If the View draws content inside its padding and enables fading edges, it needs to support padding offsets.

void onAttachedToWindow();
//This is called when the view is attached to a window.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect);
//Called by the view system when the focus state of this view changes.

void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onScrollChanged(int horiz, int vert, int oldHoriz, int oldVert);
//This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents);.

void onSelectionChanged(int selStart, int selEnd);
//This method is called when the selection has changed, in case any subclasses would like to know.

void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter);
//This method is called when the text is changed, in case any subclasses would like to know.

void onVisibilityChanged(View changedView, int visibility);
//Called when the visibility of the view or an ancestor of the view is changed.

boolean setFrame(int l, int t, int r, int b);
//Assign a size and position to this view.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.
}

class ScrollView{
void addView(View child);
ScrollView(Context context);
}


class SeekBar{
        void setOnSeekBarChangeListener(OnSeekBarChangeListener l);
}


class SeekBar$OnSeekBarChangeListener{
        void onStopTrackingTouch(SeekBar arg0);
        void onStartTrackingTouch(SeekBar arg0);
        void onProgressChanged(SeekBar arg0, int arg1, boolean arg2);
}

class Spinner {
    
    
int getBaseline();
//Return the offset of the widget's text baseline from the widget's top boundary.

 int getDropDownHorizontalOffset();
//Get the configured horizontal offset in pixels for the spinner's popup window of choices.

int getDropDownVerticalOffset();
//Get the configured vertical offset in pixels for the spinner's popup window of choices.

int getDropDownWidth();
//Get the configured width of the spinner's popup window of choices in pixels.

int getGravity();
//Describes how the selected item view is positioned.

Drawable getPopupBackground();
//Get the background drawable for the spinner's popup window of choices.

CharSequence getPrompt();

void onClick(DialogInterface dialog, int which);
//This method will be invoked when a button in the dialog is clicked.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean performClick();
//Call this view's OnClickListener, if it is defined.

void setAdapter(@Sink(DISPLAY) SpinnerAdapter adapter);
//The Adapter is used to provide the data which backs this Spinner.

void setDropDownHorizontalOffset(int pixels);
//Set a horizontal offset in pixels for the spinner's popup window of choices.

void setDropDownVerticalOffset(int pixels);
//Set a vertical offset in pixels for the spinner's popup window of choices.

void setDropDownWidth(int pixels);
//Set the width of the spinner's popup window of choices in pixels.

void setEnabled(boolean enabled);
//Set the enabled state of this view.

void setGravity(int gravity);
//Describes how the selected item view is positioned.

void setOnItemClickListener(AdapterView.OnItemClickListener l);
//A spinner does not support item click events.

void setPopupBackgroundDrawable(Drawable background);
//Set the background drawable for the spinner's popup window of choices.

void setPopupBackgroundResource(int resId);
//Set the background drawable for the spinner's popup window of choices.

void setPrompt(CharSequence prompt);
//Sets the prompt to display when the dialog is shown.

void setPromptId(int promptId);
//Sets the prompt to display when the dialog is shown.

//Protected Methods
void onDetachedFromWindow();
//This is called when the view is detached from a window.

void onLayout(boolean changed, int l, int t, int r, int b);
//Called from layout when this view should assign a size and position to each of its children.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.



}
class SimpleCursorAdapter{
            SimpleCursorAdapter(Context context, int layout, @Sink(CONDITIONAL) Cursor c, String[] from, int[] to);
            void bindView(View view, Context context, Cursor cursor);
}

class Switch {
    
int getCompoundPaddingLeft();
//Returns the left padding of the view, plus space for the left Drawable if any.

int getCompoundPaddingRight();
//Returns the right padding of the view, plus space for the right Drawable if any.

int getSwitchMinWidth();
//Get the minimum width of the switch in pixels.

int getSwitchPadding();
//Get the amount of horizontal padding between the switch and the associated text.

CharSequence getTextOff();
//Returns the text displayed when the button is not in the checked state.

CharSequence getTextOn();
//Returns the text displayed when the button is in the checked state.

Drawable getThumbDrawable();
//Get the drawable used for the switch "thumb" - the piece that the user can physically touch and drag along the track.

int getThumbTextPadding();
//Get the horizontal padding around the text drawn on the switch itself.

Drawable getTrackDrawable();
//Get the drawable used for the track that the switch slides within.

void jumpDrawablesToCurrentState();
//Call Drawable.jumpToCurrentState(); on all Drawable objects associated with this view.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.

void onPopulateAccessibilityEvent(AccessibilityEvent event);
//Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent); giving a chance to this View to populate the accessibility event with its text content.

boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

void setChecked(@Sink(DISPLAY) boolean checked);
//Changes the checked state of this button.

void setSwitchMinWidth(int pixels);
//Set the minimum width of the switch in pixels.

void setSwitchPadding(int pixels);
//Set the amount of horizontal padding between the switch and the associated text.

void setSwitchTextAppearance(Context context, int resid);
//Sets the switch text color, size, style, hint color, and highlight color from the specified TextAppearance resource.

void setSwitchTypeface(Typeface tf, int style);
//Sets the typeface and style in which the text should be displayed on the switch, and turns on the fake bold and italic bits in the Paint if the Typeface that you provided does not have all the bits in the style that you specified.

void setSwitchTypeface(Typeface tf);
//Sets the typeface in which the text should be displayed on the switch.

void setTextOff(@Sink(DISPLAY) CharSequence textOff);
//Sets the text displayed when the button is not in the checked state.

void setTextOn(@Sink(DISPLAY) CharSequence textOn);
//Sets the text displayed when the button is in the checked state.

void setThumbDrawable(@Sink(DISPLAY) Drawable thumb);
//Set the drawable used for the switch "thumb" - the piece that the user can physically touch and drag along the track.

void setThumbResource(int resId);
//Set the drawable used for the switch "thumb" - the piece that the user can physically touch and drag along the track.

void setThumbTextPadding(int pixels);
//Set the horizontal padding around the text drawn on the switch itself.

void setTrackDrawable(@Sink(DISPLAY) Drawable track);
//Set the drawable used for the track that the switch slides within.

void setTrackResource(int resId);
//Set the drawable used for the track that the switch slides within.

//Protected Methods
void drawableStateChanged();
//This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown.

int[] onCreateDrawableState(int extraSpace);
//Generate the new Drawable state for this view.

void onDraw(Canvas canvas);
//Implement this to do your drawing.

void onLayout(boolean changed, int left, int top, int right, int bottom);
//Called from layout when this view should assign a size and position to each of its children.

boolean verifyDrawable(Drawable who);
//If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying.




}

class TabHost {
void addTab(@Sink(DISPLAY) TabHost.TabSpec tabSpec);
//Add a tab.

void clearAllTabs();
//Removes all tabs from the tab widget associated with this tab host.

boolean dispatchKeyEvent(@Source(USER_INPUT) KeyEvent event);
//Dispatch a key event to the next view on the focus path.

void dispatchWindowFocusChanged(boolean hasFocus);
//Called when the window containing this view gains or loses window focus.

int getCurrentTab();

String getCurrentTabTag();

View getCurrentTabView();

View getCurrentView();

FrameLayout getTabContentView();
//Get the FrameLayout which holds tab content

TabWidget getTabWidget();

TabHost.TabSpec newTabSpec(String tag);
//Get a new TabHost.TabSpec associated with this tab host.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void onTouchModeChanged(boolean isInTouchMode);
//Callback method to be invoked when the touch mode changes.

void sendAccessibilityEvent(int eventType);
//Sends an accessibility event of the given type.

void setCurrentTab(int index);

void setCurrentTabByTag(String tag);

void setOnTabChangedListener(TabHost.OnTabChangeListener l);
//Register a callback to be invoked when the selected state of any of the items in this list changes

void setup();
//Call setup(); before adding tabs if loading TabHost using findViewById();.

void setup(LocalActivityManager activityGroup);
//If you are using setContent(android.content.Intent);, this must be called since the activityGroup is needed to launch the local activity.

//Protected Methods
void onAttachedToWindow();
//This is called when the view is attached to a window.

void onDetachedFromWindow();
//This is called when the view is detached from a window.
}

class TabHost$OnTabChangeListener {
    
abstract void onTabChanged(String tabId);    
    
}


class TabWidget {
    
    
void addView(@Sink(DISPLAY) View child);
//Adds a child view.

void childDrawableStateChanged(View child);
//If addStatesFromChildren(); is true, refreshes this group's drawable state (to include the states from its children);.

void dispatchDraw(Canvas canvas);
//Called by draw to draw the child views.

boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event);
//Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.

void focusCurrentTab(int index);
//Sets the current tab and focuses the UI on it.

View getChildTabViewAt(int index);
//Returns the tab indicator view at the given index.

int getTabCount();
//Returns the number of tab indicator views.

boolean isStripEnabled();
//Indicates whether the bottom strips on the tab indicators are drawn or not.

void onFocusChange(View v, boolean hasFocus);
//Called when the focus state of a view has changed.

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

void removeAllViews();
//Call this method to remove all child views from the ViewGroup.

void sendAccessibilityEventUnchecked(AccessibilityEvent event);
//This method behaves exactly as sendAccessibilityEvent(int); but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled.

void setCurrentTab(int index);
//Sets the current tab.

void setDividerDrawable(@Sink(DISPLAY) Drawable drawable);
//Sets the drawable to use as a divider between the tab indicators.

void setDividerDrawable(int resId);
//Sets the drawable to use as a divider between the tab indicators.

void setEnabled(@Sink(DISPLAY) boolean enabled);
//Set the enabled state of this view.

void setLeftStripDrawable(@Sink(DISPLAY) Drawable drawable);
//Sets the drawable to use as the left part of the strip below the tab indicators.

void setLeftStripDrawable(int resId);
//Sets the drawable to use as the left part of the strip below the tab indicators.

void setRightStripDrawable(@Sink(DISPLAY) Drawable drawable);
//Sets the drawable to use as the right part of the strip below the tab indicators.

void setRightStripDrawable(int resId);
//Sets the drawable to use as the right part of the strip below the tab indicators.

void setStripEnabled(@Sink(DISPLAY) boolean stripEnabled);
//Controls whether the bottom strips on the tab indicators are drawn or not.

//Protected Methods
int getChildDrawingOrder(int childCount, int i);
//Returns the index of the child to draw for this iteration.

void onSizeChanged(int w, int h, int oldw, int oldh);
//This is called during layout when the size of this view has changed.



}


class Toast {
    
void cancel();
//Close the view if it's showing, or don't show it if it isn't showing yet.

int getDuration();
//Return the duration.

int getGravity();
//Get the location at which the notification should appear on the screen.

float getHorizontalMargin();
//Return the horizontal margin.

float getVerticalMargin();
//Return the vertical margin.

View getView();
//Return the view.

int getXOffset();
//Return the X offset in pixels to apply to the gravity's location.

int getYOffset();
//Return the Y offset in pixels to apply to the gravity's location.

static Toast makeText(Context context, int resId, int duration);
//Make a standard toast that just contains a text view with the text from a resource.

static Toast makeText(Context context, @Sink(DISPLAY) CharSequence text, int duration);
//Make a standard toast that just contains a text view.

void setDuration(int duration);
//Set how long to show the view for.

void setGravity(int gravity, int xOffset, int yOffset);
//Set the location at which the notification should appear on the screen.

void setMargin(float horizontalMargin, float verticalMargin);
//Set the margins of the view.

void setText(int resId);
//Update the text in a Toast that was previously created using one of the makeText(); methods.

void setText(@Sink(DISPLAY) CharSequence s);
//Update the text in a Toast that was previously created using one of the makeText(); methods.

void setView(@Sink(DISPLAY) View view);
//Set the view to show.

void show()  @Sink(DISPLAY);
//Show the view for the specified duration.

}


class VideoView{
    
    
boolean canPause();

boolean canSeekBackward();

boolean canSeekForward();

int getBufferPercentage();

int getCurrentPosition();

int getDuration();

boolean isPlaying();

void onInitializeAccessibilityEvent(AccessibilityEvent event);
//Initializes an AccessibilityEvent with information about this View which is the event source.

void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info);
//Initializes an AccessibilityNodeInfo with information about this view.

boolean onKeyDown(@Source(USER_INPUT) int keyCode, @Source(USER_INPUT) KeyEvent event);
//Default implementation of KeyEvent.Callback.onKeyDown();: perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.

boolean onTouchEvent(MotionEvent ev);
//Implement this method to handle touch screen motion events.

boolean onTrackballEvent(MotionEvent ev);
//Implement this method to handle trackball motion events.

void pause();

int resolveAdjustedSize(int desiredSize, int measureSpec);

void resume();

void seekTo(int msec);

void setMediaController(MediaController controller);

void setOnCompletionListener(MediaPlayer.OnCompletionListener l);
//Register a callback to be invoked when the end of a media file has been reached during playback.

void setOnErrorListener(MediaPlayer.OnErrorListener l);
//Register a callback to be invoked when an error occurs during playback or setup.

void setOnInfoListener(MediaPlayer.OnInfoListener l);
//Register a callback to be invoked when an informational event occurs during playback or setup.

void setOnPreparedListener(MediaPlayer.OnPreparedListener l);
//Register a callback to be invoked when the media file is loaded and ready to go.

void setVideoPath(String path);

void setVideoURI(Uri uri);

void start();

void stopPlayback();

void suspend();

//Protected Methods
void onMeasure(int widthMeasureSpec, int heightMeasureSpec);
//Measure the view and its content to determine the measured width and the measured height.



}
class TabHost$TabSpec{
        String getTag();
        TabSpec setContent(TabContentFactory contentFactory);
}
class TabHost$TabContentFactory{
        View createTabContent(String arg0);
}
class SpinnerAdapter{
        @Sink(CONDITIONAL) View getDropDownView(int arg0, View arg1, ViewGroup arg2);
}
class TabWidget{
        TabWidget(Context context);
}

class EdgeEffect {
    
boolean draw(Canvas canvas);
//Draw into the provided canvas.

void finish();
//Immediately finish the current animation.

boolean isFinished();
//Reports if this EdgeEffect's animation is finished.

void onAbsorb(int velocity);
//Call when the effect absorbs an impact at the given velocity.

void onPull(float deltaDistance);
//A view should call this when content is pulled away from an edge by the user.

void onRelease();
//Call when the object is released after being pulled.

void setSize(int width, int height);
//Set the size of this edge effect in pixels.


    
}




package com.google.android.maps;

class GeoPoint {
  
    @Source({FlowPermission.ACCESS_COARSE_LOCATION, FlowPermission.ACCESS_FINE_LOCATION}) int getLatitudeE6();
    @Source({FlowPermission.ACCESS_COARSE_LOCATION, FlowPermission.ACCESS_FINE_LOCATION})  int getLongitudeE6();
    @Source({FlowPermission.ACCESS_COARSE_LOCATION, FlowPermission.ACCESS_FINE_LOCATION})  String toString();

}
package java.io;

@PolyFlowReceiver
class BufferedInputStream extends FilterInputStream {
//Added by pbsf
    protected byte[] buf;
    protected int count;
    protected int pos;
    protected int markpos;
    protected int marklimit;
    BufferedInputStream(InputStream arg0);
    BufferedInputStream(InputStream arg0, int arg1);
    int read() throws IOException;
    int read(byte[] arg0, int arg1, int arg2) throws IOException;
    long skip(long arg0) throws IOException;
    int available() throws IOException;
    void mark(int arg0);
    void reset() throws IOException;
    boolean markSupported();
    void close() throws IOException;
}

@PolyFlowReceiver
class BufferedOutputStream{
            void write(byte @PolySource @PolySink[] arg0, int arg1, int arg2) throws IOException;
            void flush() throws IOException;
            BufferedOutputStream(OutputStream arg0);
}

@PolyFlowReceiver
class BufferedReader extends Reader {
//Added by pbsf
    BufferedReader(Reader arg0, int arg1);
    BufferedReader(Reader arg0);
    int read() throws IOException;
    int read(char[] arg0, int arg1, int arg2) throws IOException;
    String readLine() throws IOException;
    long skip(long arg0) throws IOException;
    boolean ready() throws IOException;
    boolean markSupported();
    void mark(int arg0) throws IOException;
    void reset() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class BufferedWriter extends Writer {
    BufferedWriter(Writer arg0);
    BufferedWriter(Writer arg0, int arg1);
    void write(int arg0) throws IOException;
    void write(char[] arg0, int arg1, int arg2) throws IOException;
    void write(String arg0, int arg1, int arg2) throws IOException;
    void newLine() throws IOException;
    void flush() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class ByteArrayInputStream extends InputStream {
//Added by pbsf
    protected byte[] buf;
    protected int pos;
    protected int mark;
    protected int count;
    ByteArrayInputStream(byte[] arg0);
    ByteArrayInputStream(byte[] arg0, int arg1, int arg2);
    int read();
    int read(byte[] arg0, int arg1, int arg2);
    long skip(long arg0);
    int available();
    boolean markSupported();
    void mark(int arg0);
    void reset();
    void close() throws IOException;
}

@PolyFlowReceiver
class ByteArrayOutputStream extends OutputStream {
//Added by SOM
     ByteArrayOutputStream();
    @PolySource @PolySink byte @PolySource @PolySink [] toByteArray() @PolySource @PolySink;
    void close() @Source(FlowPermission.ANY) @Sink({});
    protected byte[] buf;
    protected int count;
    ByteArrayOutputStream(int arg0);
    void write(int arg0);
    void write(byte[] arg0, int arg1, int arg2);
    void writeTo(OutputStream arg0) throws IOException;
    void reset();
    int size();
    String toString();
    String toString(String arg0) throws UnsupportedEncodingException;
    String toString(int arg0);
}
class Closeable{
            void close() throws IOException;
}

@PolyFlowReceiver
interface DataInput {
//Added by pbsf
    void readFully(byte[] arg0) throws IOException;
    void readFully(byte[] arg0, int arg1, int arg2) throws IOException;
    int skipBytes(int arg0) throws IOException;
    boolean readBoolean() throws IOException;
    byte readByte() throws IOException;
    int readUnsignedByte() throws IOException;
    short readShort() throws IOException;
    int readUnsignedShort() throws IOException;
    char readChar() throws IOException;
    int readInt() throws IOException;
    long readLong() throws IOException;
    float readFloat() throws IOException;
    double readDouble() throws IOException;
    String readLine() throws IOException;
    String readUTF() throws IOException;
}

@PolyFlowReceiver
class DataInputStream extends FilterInputStream implements DataInput {
    DataInputStream(InputStream arg0);
    int read(byte[] arg0) throws IOException;
    int read(byte[] arg0, int arg1, int arg2) throws IOException;
    void readFully(byte[] arg0) throws IOException;
    void readFully(byte[] arg0, int arg1, int arg2) throws IOException;
    int skipBytes(int arg0) throws IOException;
    boolean readBoolean() throws IOException;
    byte readByte() throws IOException;
    int readUnsignedByte() throws IOException;
    short readShort() throws IOException;
    int readUnsignedShort() throws IOException;
    char readChar() throws IOException;
    int readInt() throws IOException;
    long readLong() throws IOException;
    float readFloat() throws IOException;
    double readDouble() throws IOException;
    String readLine() throws IOException;
    String readUTF() throws IOException;
    static String readUTF(DataInput arg0) throws IOException;
}

@PolyFlowReceiver
interface DataOutput {
//Added by pbsf
    void write(int arg0) throws IOException;
    void write(byte[] arg0) throws IOException;
    void write(byte[] arg0, int arg1, int arg2) throws IOException;
    void writeBoolean(boolean arg0) throws IOException;
    void writeByte(int arg0) throws IOException;
    void writeShort(int arg0) throws IOException;
    void writeChar(int arg0) throws IOException;
    void writeInt(int arg0) throws IOException;
    void writeLong(long arg0) throws IOException;
    void writeFloat(float arg0) throws IOException;
    void writeDouble(double arg0) throws IOException;
    void writeBytes(String arg0) throws IOException;
    void writeChars(String arg0) throws IOException;
    void writeUTF(String arg0) throws IOException;
}

@PolyFlowReceiver
class DataOutputStream extends FilterOutputStream implements DataOutput {
    protected int written;
    DataOutputStream(OutputStream arg0);
    void write(int arg0) throws IOException;
    void write(byte[] arg0, int arg1, int arg2) throws IOException;
    void flush() throws IOException;
    void writeBoolean(boolean arg0) throws IOException;
    void writeByte(int arg0) throws IOException;
    void writeShort(int arg0) throws IOException;
    void writeChar(int arg0) throws IOException;
    void writeInt(int arg0) throws IOException;
    void writeLong(long arg0) throws IOException;
    void writeFloat(float arg0) throws IOException;
    void writeDouble(double arg0) throws IOException;
    void writeBytes(String arg0) throws IOException;
    void writeChars(String arg0) throws IOException;
    void writeUTF(String arg0) throws IOException;
    int size();
}

@PolyFlowReceiver	
class File implements Serializable, Comparable<File> {
//Added by smillst
   @Source(FlowPermission.LITERAL) final char separatorChar;
   @Source(FlowPermission.LITERAL)  final String separator;
   @Source(FlowPermission.LITERAL) final char pathSeparatorChar;
   @Source(FlowPermission.LITERAL) final String pathSeparator;
    
    @Source(FlowPermission.FILESYSTEM) File( @Sink(FlowPermission.FILESYSTEM) String path);
    File(String arg0, String arg1);
    @Source(FlowPermission.FILESYSTEM) File( @Sink(FlowPermission.FILESYSTEM) File dir, @Sink(FlowPermission.FILESYSTEM) String path);

    File(URI arg0);
    String getName();
    String getParent();
    File getParentFile();
    String getPath();
    boolean isAbsolute();
    String getAbsolutePath();
    File getAbsoluteFile();
    String getCanonicalPath() throws IOException;
    File getCanonicalFile() throws IOException;
    URL toURL() throws MalformedURLException;
    URI toURI();
    boolean canRead();
    boolean canWrite();
    boolean exists();
    boolean isDirectory();
    boolean isFile();
    boolean isHidden();
    long lastModified();
    long length();
    boolean createNewFile() throws IOException;
    boolean delete();
    void deleteOnExit();
   @PolySource @PolySink   String[] list();
   @PolySource @PolySink   String[] list(FilenameFilter arg0);
    @PolySource @PolySink  File[] listFiles();
     @PolySource @PolySink File[] listFiles(FilenameFilter arg0);
    @PolySource @PolySink  File[] listFiles(FileFilter arg0);
    boolean mkdir();
    boolean mkdirs();
    boolean renameTo(File arg0);
    boolean setLastModified(long arg0);
    boolean setReadOnly();
    boolean setWritable(boolean arg0, boolean arg1);
    boolean setWritable(boolean arg0);
    boolean setReadable(boolean arg0, boolean arg1);
    boolean setReadable(boolean arg0);
    boolean setExecutable(boolean arg0, boolean arg1);
    boolean setExecutable(boolean arg0);
    boolean canExecute();
    static @Source(FlowPermission.FILESYSTEM) File @Source(FlowPermission.FILESYSTEM) [] listRoots();
    long getTotalSpace();
    long getFreeSpace();
    long getUsableSpace();
    static @Source(FlowPermission.FILESYSTEM) File createTempFile(@Sink(FlowPermission.FILESYSTEM) String arg0, @Sink(FlowPermission.FILESYSTEM) String arg1, @Sink(FlowPermission.FILESYSTEM) File arg2) throws IOException;
    static @Source(FlowPermission.FILESYSTEM) File createTempFile(@Sink(FlowPermission.FILESYSTEM) String arg0, @Sink(FlowPermission.FILESYSTEM) String arg1) throws IOException;
    int compareTo(File arg0);
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    Path toPath();
	
}
class FileDescriptor{
            void sync() throws SyncFailedException;
}

@PolyFlowReceiver
class FileInputStream extends InputStream {
    FileInputStream(@Source(FlowPermission.FILESYSTEM) String arg0) throws FileNotFoundException;
    FileInputStream(@Source(FlowPermission.FILESYSTEM) File arg0) throws FileNotFoundException;
    FileInputStream(@Source(FlowPermission.FILESYSTEM) FileDescriptor arg0);
    int read() throws IOException;
    int read(@Source(FlowPermission.FILESYSTEM) byte@Source(FlowPermission.FILESYSTEM)[] arg0) throws IOException;
    int read(@Source(FlowPermission.FILESYSTEM) byte@Source(FlowPermission.FILESYSTEM)[] arg0, int arg1, int arg2) throws IOException;
    long skip(long arg0) throws IOException;
    int available() throws IOException;
    void close() throws IOException;
    @Source(FlowPermission.FILESYSTEM) FileDescriptor getFD() @Source(FlowPermission.FILESYSTEM) throws IOException;
    @Source(FlowPermission.FILESYSTEM) FileChannel getChannel() @Source(FlowPermission.FILESYSTEM);
    protected void finalize() @Source(FlowPermission.FILESYSTEM) throws IOException;
}
@PolyFlowReceiver
class FilterInputStream{
            protected @PolySource FilterInputStream(InputStream arg0);
            long skip(long arg0) throws IOException;
            int read (byte @PolySouce @PolySink[] arg0, int arg1, int arg2) throws IOException;
            int read(byte @PolySource @PolySink[] arg0) throws IOException;

            void close() throws IOException;
            int available() throws IOException;
            int read() throws IOException;
}
class IOException{
            IOException(String arg0);
}
class FileReader{
            FileReader(@Source({FILESYSTEM, READ_EXTERNAL_STORAGE}) File arg0) throws FileNotFoundException;
}
@PolyFlowReceiver
class FilterOutputStream{
            @PolySink FilterOutputStream(OutputStream arg0);
            void close() throws IOException;
            void write(@PolySink byte[] arg0) throws IOException;
                        void write(int arg0) throws IOException;
            void write(byte[] arg0, int arg1, int arg2) throws IOException;

}

class FilenameFilter{
        boolean accept(@Source(FlowPermission.FILESYSTEM) File arg0, String arg1);
}

class FileOutputStream extends OutputStream {
//Added by SOM
    FileOutputStream(@Sink(FlowPermission.FILESYSTEM) String arg0) throws FileNotFoundException;
    FileOutputStream(@Sink(FlowPermission.FILESYSTEM) String arg0, boolean arg1) throws FileNotFoundException;
    FileOutputStream(@Sink(FlowPermission.FILESYSTEM) File arg0) throws FileNotFoundException;
    FileOutputStream(@Sink(FlowPermission.FILESYSTEM) File arg0, boolean arg1) throws FileNotFoundException;
    FileOutputStream(@Sink(FlowPermission.FILESYSTEM) FileDescriptor arg0);
    void write(@Sink(FlowPermission.FILESYSTEM) int arg0) @Sink(FlowPermission.FILESYSTEM);
    void write(@Sink(FlowPermission.FILESYSTEM) byte @Sink(FlowPermission.FILESYSTEM) [] arg0) @Sink(FlowPermission.FILESYSTEM);
    void write(@Sink(FlowPermission.FILESYSTEM) byte @Sink(FlowPermission.FILESYSTEM) [] arg0, int arg1, int arg2) @Sink(FlowPermission.FILESYSTEM);
    void close() @Sink(FlowPermission.FILESYSTEM);
    @Sink(FlowPermission.FILESYSTEM) FileDescriptor getFD() @Sink(FlowPermission.FILESYSTEM);
    @Sink(FlowPermission.FILESYSTEM) FileChannel getChannel() @Sink(FlowPermission.FILESYSTEM);
    protected void finalize() @Sink(FlowPermission.FILESYSTEM);
}

@PolyFlowReceiver
class FileWriter extends OutputStreamWriter {
    FileWriter(String arg0) throws IOException;
    FileWriter(String arg0, boolean arg1) throws IOException;
    FileWriter(File arg0) throws IOException;
    FileWriter(File arg0, boolean arg1) throws IOException;
    FileWriter(FileDescriptor arg0);
}

@PolyFlowReceiver
class InputStream implements Closeable {
//Added by pbsf
    InputStream();
    int read() throws IOException;
    int read(byte[] arg0) throws IOException;
    int read(byte[] arg0, int arg1, int arg2) throws IOException;
    long skip(long arg0) throws IOException;
    int available() throws IOException;
    void close() throws IOException;
    void mark(int arg0);
    void reset() throws IOException;
    boolean markSupported();
}

@PolyFlowReceiver
class InputStreamReader extends Reader {
    InputStreamReader(InputStream arg0);
    InputStreamReader(InputStream arg0, String arg1) throws UnsupportedEncodingException;
    InputStreamReader(InputStream arg0, Charset arg1);
    InputStreamReader(InputStream arg0, CharsetDecoder arg1);
    String getEncoding();
    int read() throws IOException;
    int read(char[] arg0, int arg1, int arg2) throws IOException;
    boolean ready() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants {
    ObjectInputStream(InputStream arg0) throws IOException;
    protected ObjectInputStream() throws IOException,SecurityException;
    Object readObject() throws IOException,ClassNotFoundException;
    protected Object readObjectOverride() throws IOException,ClassNotFoundException;
    Object readUnshared() throws IOException,ClassNotFoundException;
    void defaultReadObject() throws IOException,ClassNotFoundException;
    GetField readFields() throws IOException,ClassNotFoundException;
    void registerValidation(ObjectInputValidation arg0, int arg1) throws NotActiveException,InvalidObjectException;
    protected Class<?> resolveClass(ObjectStreamClass arg0) throws IOException,ClassNotFoundException;
    protected Class<?> resolveProxyClass(String[] arg0) throws IOException,ClassNotFoundException;
    protected Object resolveObject(Object arg0) throws IOException;
    protected boolean enableResolveObject(boolean arg0) throws SecurityException;
    protected void readStreamHeader() throws IOException,StreamCorruptedException;
    protected ObjectStreamClass readClassDescriptor() throws IOException,ClassNotFoundException;
    int read() throws IOException;
    int read(byte[] arg0, int arg1, int arg2) throws IOException;
    int available() throws IOException;
    void close() throws IOException;
    boolean readBoolean() throws IOException;
    byte readByte() throws IOException;
    int readUnsignedByte() throws IOException;
    char readChar() throws IOException;
    short readShort() throws IOException;
    int readUnsignedShort() throws IOException;
    int readInt() throws IOException;
    long readLong() throws IOException;
    float readFloat() throws IOException;
    double readDouble() throws IOException;
    void readFully(byte[] arg0) throws IOException;
    void readFully(byte[] arg0, int arg1, int arg2) throws IOException;
    int skipBytes(int arg0) throws IOException;
    String readLine() throws IOException;
    String readUTF() throws IOException;
}

@PolyFlowReceiver
class ObjectInputStream$GetField {
    GetField();
    ObjectStreamClass getObjectStreamClass();
    boolean defaulted(String arg0) throws IOException;
    boolean get(String arg0, boolean arg1) throws IOException;
    byte get(String arg0, byte arg1) throws IOException;
    char get(String arg0, char arg1) throws IOException;
    short get(String arg0, short arg1) throws IOException;
    int get(String arg0, int arg1) throws IOException;
    long get(String arg0, long arg1) throws IOException;
    float get(String arg0, float arg1) throws IOException;
    double get(String arg0, double arg1) throws IOException;
    Object get(String arg0, Object arg1) throws IOException;
}

@PolyFlowReceiver
class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
//Added by pbsf
    ObjectOutputStream(OutputStream arg0) throws IOException;
    protected ObjectOutputStream() throws IOException,SecurityException;
    void useProtocolVersion(int arg0) throws IOException;
    void writeObject(Object arg0) throws IOException;
    protected void writeObjectOverride(Object arg0) throws IOException;
    void writeUnshared(Object arg0) throws IOException;
    void defaultWriteObject() throws IOException;
    PutField putFields() throws IOException;
    void writeFields() throws IOException;
    void reset() throws IOException;
    protected void annotateClass(Class<?> arg0) throws IOException;
    protected void annotateProxyClass(Class<?> arg0) throws IOException;
    protected Object replaceObject(Object arg0) throws IOException;
    protected boolean enableReplaceObject(boolean arg0) throws SecurityException;
    protected void writeStreamHeader() throws IOException;
    protected void writeClassDescriptor(ObjectStreamClass arg0) throws IOException;
    void write(int arg0) throws IOException;
    void write(byte[] arg0) throws IOException;
    void write(byte[] arg0, int arg1, int arg2) throws IOException;
    void flush() throws IOException;
    protected void drain() throws IOException;
    void close() throws IOException;
    void writeBoolean(boolean arg0) throws IOException;
    void writeByte(int arg0) throws IOException;
    void writeShort(int arg0) throws IOException;
    void writeChar(int arg0) throws IOException;
    void writeInt(int arg0) throws IOException;
    void writeLong(long arg0) throws IOException;
    void writeFloat(float arg0) throws IOException;
    void writeDouble(double arg0) throws IOException;
    void writeBytes(String arg0) throws IOException;
    void writeChars(String arg0) throws IOException;
    void writeUTF(String arg0) throws IOException;
}

@PolyFlowReceiver
class ObjectOutputStream$PutField {
    PutField();
    void put(String arg0, boolean arg1);
    void put(String arg0, byte arg1);
    void put(String arg0, char arg1);
    void put(String arg0, short arg1);
    void put(String arg0, int arg1);
    void put(String arg0, long arg1);
    void put(String arg0, float arg1);
    void put(String arg0, double arg1);
    void put(String arg0, Object arg1);
    void write(ObjectOutput arg0) throws IOException;
}

@PolyFlowReceiver
class OutputStream implements Closeable, Flushable {
//Added by pbsf
    OutputStream();
    void write(int arg0) throws IOException;
    void write(byte[] arg0) throws IOException;
    void write(byte[] arg0, int arg1, int arg2) throws IOException;
    void flush() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class OutputStreamWriter extends Writer {
//Added by pbsf
    OutputStreamWriter(OutputStream arg0, String arg1) throws UnsupportedEncodingException;
    OutputStreamWriter(OutputStream arg0);
    OutputStreamWriter(OutputStream arg0, Charset arg1);
    OutputStreamWriter(OutputStream arg0, CharsetEncoder arg1);
    String getEncoding();
    void write(int arg0) throws IOException;
    void write(char[] arg0, int arg1, int arg2) throws IOException;
    void write(String arg0, int arg1, int arg2) throws IOException;
    void flush() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class PrintStream extends FilterOutputStream implements Appendable, Closeable {
//Added by pbsf
    PrintStream(OutputStream arg0);
    PrintStream(OutputStream arg0, boolean arg1);
    PrintStream(OutputStream arg0, boolean arg1, String arg2) throws UnsupportedEncodingException;
    PrintStream(String arg0) throws FileNotFoundException;
    PrintStream(String arg0, String arg1) throws FileNotFoundException,UnsupportedEncodingException;
    PrintStream(File arg0) throws FileNotFoundException;
    PrintStream(File arg0, String arg1) throws FileNotFoundException,UnsupportedEncodingException;
    void flush();
    void close();
    boolean checkError();
    protected void setError();
    protected void clearError();
    void write(int arg0);
    void write(byte[] arg0, int arg1, int arg2);
    void print(boolean arg0);
    void print(char arg0);
    void print(int arg0);
    void print(long arg0);
    void print(float arg0);
    void print(double arg0);
    void print(char[] arg0);
    void print(String arg0);
    void print(Object arg0);
    void println();
    void println(boolean arg0);
    void println(char arg0);
    void println(int arg0);
    void println(long arg0);
    void println(float arg0);
    void println(double arg0);
    void println(char[] arg0);
    void println(String arg0);
    void println(Object arg0);
    PrintStream printf(String arg0, Object[] arg1);
    PrintStream printf(Locale arg0, String arg1, Object[] arg2);
    PrintStream format(String arg0, Object[] arg1);
    PrintStream format(Locale arg0, String arg1, Object[] arg2);
    PrintStream append(CharSequence arg0);
    PrintStream append(CharSequence arg0, int arg1, int arg2);
    PrintStream append(char arg0);
}

@PolyFlowReceiver
class PrintWriter extends Writer {
//Added by smillst
    protected Writer out;
    PrintWriter(Writer arg0);
    PrintWriter(Writer arg0, boolean arg1);
    PrintWriter(OutputStream arg0);
    PrintWriter(OutputStream arg0, boolean arg1);
    PrintWriter(String arg0) throws FileNotFoundException;
    PrintWriter(String arg0, String arg1) throws FileNotFoundException,UnsupportedEncodingException;
    PrintWriter(File arg0) throws FileNotFoundException;
    PrintWriter(File arg0, String arg1) throws FileNotFoundException,UnsupportedEncodingException;
    void flush();
    void close();
    boolean checkError();
    protected void setError();
    protected void clearError();
    void write(int arg0);
    void write(char[] arg0, int arg1, int arg2);
    void write(char[] arg0);
    void write(String arg0, int arg1, int arg2);
    void write(String arg0);
    void print(boolean arg0);
    void print(char arg0);
    void print(int arg0);
    void print(long arg0);
    void print(float arg0);
    void print(double arg0);
    void print(char[] arg0);
    void print(String arg0);
    void print(Object arg0);
    void println();
    void println(boolean arg0);
    void println(char arg0);
    void println(int arg0);
    void println(long arg0);
    void println(float arg0);
    void println(double arg0);
    void println(char[] arg0);
    void println(String arg0);
    void println(Object arg0);
    PrintWriter printf(String arg0, Object[] arg1);
    PrintWriter printf(Locale arg0, String arg1, Object[] arg2);
    PrintWriter format(String arg0, Object[] arg1);
    PrintWriter format(Locale arg0, String arg1, Object[] arg2);
    PrintWriter append(CharSequence arg0);
    PrintWriter append(CharSequence arg0, int arg1, int arg2);
    PrintWriter append(char arg0);
}

@PolyFlowReceiver
class Reader implements Readable, Closeable {
    protected Object lock;
    protected Reader();
    protected Reader(Object arg0);
    int read(CharBuffer arg0) throws IOException;
    int read() throws IOException;
    int read(char[] arg0) throws IOException;
    int read(char[] arg0, int arg1, int arg2) throws IOException;
    long skip(long arg0) throws IOException;
    boolean ready() throws IOException;
    boolean markSupported();
    void mark(int arg0) throws IOException;
    void reset() throws IOException;
    void close() throws IOException;
}

@PolyFlowReceiver
class Writer implements Appendable, Closeable, Flushable {
    protected Object lock;
    protected Writer();
    protected Writer(Object arg0);
    void write(int arg0) throws IOException;
    void write(char[] arg0) throws IOException;
    void write(char[] arg0, int arg1, int arg2) throws IOException;
    void write(String arg0) throws IOException;
    void write(String arg0, int arg1, int arg2) throws IOException;
    Writer append(CharSequence arg0) throws IOException;
    Writer append(CharSequence arg0, int arg1, int arg2) throws IOException;
    Writer append(char arg0) throws IOException;
    void flush() throws IOException;
    void close() throws IOException;
}
@PolyFlowReceiver

class StringReader{
            StringReader(String arg0);
}






package java.lang;

class AutoCloseable{
            void close() throws Exception;
}

@PolyFlowReceiver
class AbstractStringBuilder{
        int length();
        setLength(int arg0);
}

@PolyFlowReceiver
interface Appendable {
//Added by pbsf
    Appendable append(CharSequence arg0) throws IOException;
    Appendable append(CharSequence arg0, int arg1, int arg2) throws IOException;
    Appendable append(char arg0) throws IOException;
}

@PolyFlowReceiver
class AssertionError extends Error {
//Added by pbsf
    AssertionError();
    AssertionError(Object arg0);
    AssertionError(boolean arg0);
    AssertionError(char arg0);
    AssertionError(int arg0);
    AssertionError(long arg0);
    AssertionError(float arg0);
    AssertionError(double arg0);
    AssertionError(String arg0, Throwable arg1);
}

@PolyFlowReceiver
class Boolean implements Serializable, Comparable<Boolean> {
    final Boolean TRUE;
    final Boolean FALSE;
    final Class<Boolean> TYPE;
    Boolean(boolean arg0);
    Boolean(String arg0);
    static boolean parseBoolean(String arg0);
    boolean booleanValue();
    static Boolean valueOf(boolean arg0);
    static Boolean valueOf(String arg0);
    static String toString(boolean arg0);
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    static boolean getBoolean(String arg0);
    int compareTo(Boolean arg0);
    static int compare(boolean arg0, boolean arg1);
}

@PolyFlowReceiver
class Byte extends Number implements Comparable<Byte> {
//Added by pbsf
    final byte MIN_VALUE;
    final byte MAX_VALUE;
    final Class<Byte> TYPE;
    final int SIZE;
    static String toString(byte arg0);
    static Byte valueOf(byte arg0);
    static byte parseByte(String arg0, int arg1) throws NumberFormatException;
    static byte parseByte(String arg0) throws NumberFormatException;
    static Byte valueOf(String arg0, int arg1) throws NumberFormatException;
    static Byte valueOf(String arg0) throws NumberFormatException;
    static Byte decode(String arg0) throws NumberFormatException;
    Byte(byte arg0);
    Byte(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(Byte arg0);
    static int compare(byte arg0, byte arg1);
}

@PolyFlowReceiver
class Character implements Serializable, Comparable<Character> {
    final @Source(FlowPermission.LITERAL) int MIN_RADIX;
    final @Source(FlowPermission.LITERAL) int MAX_RADIX;
    final @Source(FlowPermission.LITERAL) char MIN_VALUE;
    final @Source(FlowPermission.LITERAL) char MAX_VALUE;
    final Class<Character> TYPE;
    final @Source(FlowPermission.LITERAL) byte UNASSIGNED;
    final @Source(FlowPermission.LITERAL) byte UPPERCASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte LOWERCASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte TITLECASE_LETTER;
    final @Source(FlowPermission.LITERAL) byte MODIFIER_LETTER;
    final @Source(FlowPermission.LITERAL) byte OTHER_LETTER;
    final @Source(FlowPermission.LITERAL) byte NON_SPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte ENCLOSING_MARK;
    final @Source(FlowPermission.LITERAL) byte COMBINING_SPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte DECIMAL_DIGIT_NUMBER;
    final @Source(FlowPermission.LITERAL) byte LETTER_NUMBER;
    final @Source(FlowPermission.LITERAL) byte OTHER_NUMBER;
    final @Source(FlowPermission.LITERAL) byte SPACE_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte LINE_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte PARAGRAPH_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte CONTROL;
    final @Source(FlowPermission.LITERAL) byte FORMAT;
    final @Source(FlowPermission.LITERAL) byte PRIVATE_USE;
    final @Source(FlowPermission.LITERAL) byte SURROGATE;
    final @Source(FlowPermission.LITERAL) byte DASH_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte START_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte END_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte CONNECTOR_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte OTHER_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte MATH_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte CURRENCY_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte MODIFIER_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte OTHER_SYMBOL;
    final @Source(FlowPermission.LITERAL) byte INITIAL_QUOTE_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte FINAL_QUOTE_PUNCTUATION;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_UNDEFINED;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_ARABIC_NUMBER;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_NONSPACING_MARK;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_BOUNDARY_NEUTRAL;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_PARAGRAPH_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_SEGMENT_SEPARATOR;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_WHITESPACE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_OTHER_NEUTRALS;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE;
    final @Source(FlowPermission.LITERAL) byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT;
    final @Source(FlowPermission.LITERAL) char MIN_HIGH_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_HIGH_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MIN_LOW_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_LOW_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MIN_SURROGATE;
    final @Source(FlowPermission.LITERAL) char MAX_SURROGATE;
    final @Source(FlowPermission.LITERAL) int MIN_SUPPLEMENTARY_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int MIN_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int MAX_CODE_POINT;
    final @Source(FlowPermission.LITERAL) int SIZE;
    Character(char arg0);
    static Character valueOf(char arg0);
    char charValue();
    int hashCode();
    boolean equals(Object arg0);
    String toString();
    static String toString(char arg0);
    static boolean isValidCodePoint(int arg0);
    static boolean isBmpCodePoint(int arg0);
    static boolean isSupplementaryCodePoint(int arg0);
    static boolean isHighSurrogate(char arg0);
    static boolean isLowSurrogate(char arg0);
    static boolean isSurrogate(char arg0);
    static boolean isSurrogatePair(char arg0, char arg1);
    static int charCount(int arg0);
    static int toCodePoint(char arg0, char arg1);
    static int codePointAt(CharSequence arg0, int arg1);
    static int codePointAt(char[] arg0, int arg1);
    static int codePointAt(char[] arg0, int arg1, int arg2);
    static int codePointBefore(CharSequence arg0, int arg1);
    static int codePointBefore(char[] arg0, int arg1);
    static int codePointBefore(char[] arg0, int arg1, int arg2);
    static char highSurrogate(int arg0);
    static char lowSurrogate(int arg0);
    static int toChars(int arg0, char[] arg1, int arg2);
    static char[] toChars(int arg0);
    static int codePointCount(CharSequence arg0, int arg1, int arg2);
    static int codePointCount(char[] arg0, int arg1, int arg2);
    static int offsetByCodePoints(CharSequence arg0, int arg1, int arg2);
    static int offsetByCodePoints(char[] arg0, int arg1, int arg2, int arg3, int arg4);
    static boolean isLowerCase(char arg0);
    static boolean isLowerCase(int arg0);
    static boolean isUpperCase(char arg0);
    static boolean isUpperCase(int arg0);
    static boolean isTitleCase(char arg0);
    static boolean isTitleCase(int arg0);
    static boolean isDigit(char arg0);
    static boolean isDigit(int arg0);
    static boolean isDefined(char arg0);
    static boolean isDefined(int arg0);
    static boolean isLetter(char arg0);
    static boolean isLetter(int arg0);
    static boolean isLetterOrDigit(char arg0);
    static boolean isLetterOrDigit(int arg0);
    static boolean isJavaLetter(char arg0);
    static boolean isJavaLetterOrDigit(char arg0);
    static boolean isAlphabetic(int arg0);
    static boolean isIdeographic(int arg0);
    static boolean isJavaIdentifierStart(char arg0);
    static boolean isJavaIdentifierStart(int arg0);
    static boolean isJavaIdentifierPart(char arg0);
    static boolean isJavaIdentifierPart(int arg0);
    static boolean isUnicodeIdentifierStart(char arg0);
    static boolean isUnicodeIdentifierStart(int arg0);
    static boolean isUnicodeIdentifierPart(char arg0);
    static boolean isUnicodeIdentifierPart(int arg0);
    static boolean isIdentifierIgnorable(char arg0);
    static boolean isIdentifierIgnorable(int arg0);
    static char toLowerCase(char arg0);
    static int toLowerCase(int arg0);
    static char toUpperCase(char arg0);
    static int toUpperCase(int arg0);
    static char toTitleCase(char arg0);
    static int toTitleCase(int arg0);
    static int digit(char arg0, int arg1);
    static int digit(int arg0, int arg1);
    static int getNumericValue(char arg0);
    static int getNumericValue(int arg0);
    static boolean isSpace(char arg0);
    static boolean isSpaceChar(char arg0);
    static boolean isSpaceChar(int arg0);
    static boolean isWhitespace(char arg0);
    static boolean isWhitespace(int arg0);
    static boolean isISOControl(char arg0);
    static boolean isISOControl(int arg0);
    static int getType(char arg0);
    static int getType(int arg0);
    static char forDigit(int arg0, int arg1);
    static byte getDirectionality(char arg0);
    static byte getDirectionality(int arg0);
    static boolean isMirrored(char arg0);
    static boolean isMirrored(int arg0);
    int compareTo(Character arg0);
    static int compare(char arg0, char arg1);
    static char reverseBytes(char arg0);
    static String getName(int arg0);
}

@PolyFlowReceiver
class Character$UnicodeBlock extends Subset {
    final UnicodeBlock BASIC_LATIN;
    final UnicodeBlock LATIN_1_SUPPLEMENT;
    final UnicodeBlock LATIN_EXTENDED_A;
    final UnicodeBlock LATIN_EXTENDED_B;
    final UnicodeBlock IPA_EXTENSIONS;
    final UnicodeBlock SPACING_MODIFIER_LETTERS;
    final UnicodeBlock COMBINING_DIACRITICAL_MARKS;
    final UnicodeBlock GREEK;
    final UnicodeBlock CYRILLIC;
    final UnicodeBlock ARMENIAN;
    final UnicodeBlock HEBREW;
    final UnicodeBlock ARABIC;
    final UnicodeBlock DEVANAGARI;
    final UnicodeBlock BENGALI;
    final UnicodeBlock GURMUKHI;
    final UnicodeBlock GUJARATI;
    final UnicodeBlock ORIYA;
    final UnicodeBlock TAMIL;
    final UnicodeBlock TELUGU;
    final UnicodeBlock KANNADA;
    final UnicodeBlock MALAYALAM;
    final UnicodeBlock THAI;
    final UnicodeBlock LAO;
    final UnicodeBlock TIBETAN;
    final UnicodeBlock GEORGIAN;
    final UnicodeBlock HANGUL_JAMO;
    final UnicodeBlock LATIN_EXTENDED_ADDITIONAL;
    final UnicodeBlock GREEK_EXTENDED;
    final UnicodeBlock GENERAL_PUNCTUATION;
    final UnicodeBlock SUPERSCRIPTS_AND_SUBSCRIPTS;
    final UnicodeBlock CURRENCY_SYMBOLS;
    final UnicodeBlock COMBINING_MARKS_FOR_SYMBOLS;
    final UnicodeBlock LETTERLIKE_SYMBOLS;
    final UnicodeBlock NUMBER_FORMS;
    final UnicodeBlock ARROWS;
    final UnicodeBlock MATHEMATICAL_OPERATORS;
    final UnicodeBlock MISCELLANEOUS_TECHNICAL;
    final UnicodeBlock CONTROL_PICTURES;
    final UnicodeBlock OPTICAL_CHARACTER_RECOGNITION;
    final UnicodeBlock ENCLOSED_ALPHANUMERICS;
    final UnicodeBlock BOX_DRAWING;
    final UnicodeBlock BLOCK_ELEMENTS;
    final UnicodeBlock GEOMETRIC_SHAPES;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS;
    final UnicodeBlock DINGBATS;
    final UnicodeBlock CJK_SYMBOLS_AND_PUNCTUATION;
    final UnicodeBlock HIRAGANA;
    final UnicodeBlock KATAKANA;
    final UnicodeBlock BOPOMOFO;
    final UnicodeBlock HANGUL_COMPATIBILITY_JAMO;
    final UnicodeBlock KANBUN;
    final UnicodeBlock ENCLOSED_CJK_LETTERS_AND_MONTHS;
    final UnicodeBlock CJK_COMPATIBILITY;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS;
    final UnicodeBlock HANGUL_SYLLABLES;
    final UnicodeBlock PRIVATE_USE_AREA;
    final UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS;
    final UnicodeBlock ALPHABETIC_PRESENTATION_FORMS;
    final UnicodeBlock ARABIC_PRESENTATION_FORMS_A;
    final UnicodeBlock COMBINING_HALF_MARKS;
    final UnicodeBlock CJK_COMPATIBILITY_FORMS;
    final UnicodeBlock SMALL_FORM_VARIANTS;
    final UnicodeBlock ARABIC_PRESENTATION_FORMS_B;
    final UnicodeBlock HALFWIDTH_AND_FULLWIDTH_FORMS;
    final UnicodeBlock SPECIALS;
    final UnicodeBlock SURROGATES_AREA;
    final UnicodeBlock SYRIAC;
    final UnicodeBlock THAANA;
    final UnicodeBlock SINHALA;
    final UnicodeBlock MYANMAR;
    final UnicodeBlock ETHIOPIC;
    final UnicodeBlock CHEROKEE;
    final UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS;
    final UnicodeBlock OGHAM;
    final UnicodeBlock RUNIC;
    final UnicodeBlock KHMER;
    final UnicodeBlock MONGOLIAN;
    final UnicodeBlock BRAILLE_PATTERNS;
    final UnicodeBlock CJK_RADICALS_SUPPLEMENT;
    final UnicodeBlock KANGXI_RADICALS;
    final UnicodeBlock IDEOGRAPHIC_DESCRIPTION_CHARACTERS;
    final UnicodeBlock BOPOMOFO_EXTENDED;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A;
    final UnicodeBlock YI_SYLLABLES;
    final UnicodeBlock YI_RADICALS;
    final UnicodeBlock CYRILLIC_SUPPLEMENTARY;
    final UnicodeBlock TAGALOG;
    final UnicodeBlock HANUNOO;
    final UnicodeBlock BUHID;
    final UnicodeBlock TAGBANWA;
    final UnicodeBlock LIMBU;
    final UnicodeBlock TAI_LE;
    final UnicodeBlock KHMER_SYMBOLS;
    final UnicodeBlock PHONETIC_EXTENSIONS;
    final UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A;
    final UnicodeBlock SUPPLEMENTAL_ARROWS_A;
    final UnicodeBlock SUPPLEMENTAL_ARROWS_B;
    final UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B;
    final UnicodeBlock SUPPLEMENTAL_MATHEMATICAL_OPERATORS;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_ARROWS;
    final UnicodeBlock KATAKANA_PHONETIC_EXTENSIONS;
    final UnicodeBlock YIJING_HEXAGRAM_SYMBOLS;
    final UnicodeBlock VARIATION_SELECTORS;
    final UnicodeBlock LINEAR_B_SYLLABARY;
    final UnicodeBlock LINEAR_B_IDEOGRAMS;
    final UnicodeBlock AEGEAN_NUMBERS;
    final UnicodeBlock OLD_ITALIC;
    final UnicodeBlock GOTHIC;
    final UnicodeBlock UGARITIC;
    final UnicodeBlock DESERET;
    final UnicodeBlock SHAVIAN;
    final UnicodeBlock OSMANYA;
    final UnicodeBlock CYPRIOT_SYLLABARY;
    final UnicodeBlock BYZANTINE_MUSICAL_SYMBOLS;
    final UnicodeBlock MUSICAL_SYMBOLS;
    final UnicodeBlock TAI_XUAN_JING_SYMBOLS;
    final UnicodeBlock MATHEMATICAL_ALPHANUMERIC_SYMBOLS;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B;
    final UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT;
    final UnicodeBlock TAGS;
    final UnicodeBlock VARIATION_SELECTORS_SUPPLEMENT;
    final UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_A;
    final UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_B;
    final UnicodeBlock HIGH_SURROGATES;
    final UnicodeBlock HIGH_PRIVATE_USE_SURROGATES;
    final UnicodeBlock LOW_SURROGATES;
    final UnicodeBlock ARABIC_SUPPLEMENT;
    final UnicodeBlock NKO;
    final UnicodeBlock SAMARITAN;
    final UnicodeBlock MANDAIC;
    final UnicodeBlock ETHIOPIC_SUPPLEMENT;
    final UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED;
    final UnicodeBlock NEW_TAI_LUE;
    final UnicodeBlock BUGINESE;
    final UnicodeBlock TAI_THAM;
    final UnicodeBlock BALINESE;
    final UnicodeBlock SUNDANESE;
    final UnicodeBlock BATAK;
    final UnicodeBlock LEPCHA;
    final UnicodeBlock OL_CHIKI;
    final UnicodeBlock VEDIC_EXTENSIONS;
    final UnicodeBlock PHONETIC_EXTENSIONS_SUPPLEMENT;
    final UnicodeBlock COMBINING_DIACRITICAL_MARKS_SUPPLEMENT;
    final UnicodeBlock GLAGOLITIC;
    final UnicodeBlock LATIN_EXTENDED_C;
    final UnicodeBlock COPTIC;
    final UnicodeBlock GEORGIAN_SUPPLEMENT;
    final UnicodeBlock TIFINAGH;
    final UnicodeBlock ETHIOPIC_EXTENDED;
    final UnicodeBlock CYRILLIC_EXTENDED_A;
    final UnicodeBlock SUPPLEMENTAL_PUNCTUATION;
    final UnicodeBlock CJK_STROKES;
    final UnicodeBlock LISU;
    final UnicodeBlock VAI;
    final UnicodeBlock CYRILLIC_EXTENDED_B;
    final UnicodeBlock BAMUM;
    final UnicodeBlock MODIFIER_TONE_LETTERS;
    final UnicodeBlock LATIN_EXTENDED_D;
    final UnicodeBlock SYLOTI_NAGRI;
    final UnicodeBlock COMMON_INDIC_NUMBER_FORMS;
    final UnicodeBlock PHAGS_PA;
    final UnicodeBlock SAURASHTRA;
    final UnicodeBlock DEVANAGARI_EXTENDED;
    final UnicodeBlock KAYAH_LI;
    final UnicodeBlock REJANG;
    final UnicodeBlock HANGUL_JAMO_EXTENDED_A;
    final UnicodeBlock JAVANESE;
    final UnicodeBlock CHAM;
    final UnicodeBlock MYANMAR_EXTENDED_A;
    final UnicodeBlock TAI_VIET;
    final UnicodeBlock ETHIOPIC_EXTENDED_A;
    final UnicodeBlock MEETEI_MAYEK;
    final UnicodeBlock HANGUL_JAMO_EXTENDED_B;
    final UnicodeBlock VERTICAL_FORMS;
    final UnicodeBlock ANCIENT_GREEK_NUMBERS;
    final UnicodeBlock ANCIENT_SYMBOLS;
    final UnicodeBlock PHAISTOS_DISC;
    final UnicodeBlock LYCIAN;
    final UnicodeBlock CARIAN;
    final UnicodeBlock OLD_PERSIAN;
    final UnicodeBlock IMPERIAL_ARAMAIC;
    final UnicodeBlock PHOENICIAN;
    final UnicodeBlock LYDIAN;
    final UnicodeBlock KHAROSHTHI;
    final UnicodeBlock OLD_SOUTH_ARABIAN;
    final UnicodeBlock AVESTAN;
    final UnicodeBlock INSCRIPTIONAL_PARTHIAN;
    final UnicodeBlock INSCRIPTIONAL_PAHLAVI;
    final UnicodeBlock OLD_TURKIC;
    final UnicodeBlock RUMI_NUMERAL_SYMBOLS;
    final UnicodeBlock BRAHMI;
    final UnicodeBlock KAITHI;
    final UnicodeBlock CUNEIFORM;
    final UnicodeBlock CUNEIFORM_NUMBERS_AND_PUNCTUATION;
    final UnicodeBlock EGYPTIAN_HIEROGLYPHS;
    final UnicodeBlock BAMUM_SUPPLEMENT;
    final UnicodeBlock KANA_SUPPLEMENT;
    final UnicodeBlock ANCIENT_GREEK_MUSICAL_NOTATION;
    final UnicodeBlock COUNTING_ROD_NUMERALS;
    final UnicodeBlock MAHJONG_TILES;
    final UnicodeBlock DOMINO_TILES;
    final UnicodeBlock PLAYING_CARDS;
    final UnicodeBlock ENCLOSED_ALPHANUMERIC_SUPPLEMENT;
    final UnicodeBlock ENCLOSED_IDEOGRAPHIC_SUPPLEMENT;
    final UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS;
    final UnicodeBlock EMOTICONS;
    final UnicodeBlock TRANSPORT_AND_MAP_SYMBOLS;
    final UnicodeBlock ALCHEMICAL_SYMBOLS;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C;
    final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D;
    static UnicodeBlock of(char arg0);
    static UnicodeBlock of(int arg0);
    static UnicodeBlock forName(String arg0);
}

@PolyFlowReceiver
class Character$Subset {
    protected Subset(String arg0);
    boolean equals(Object arg0);
    int hashCode();
    String toString();
}


@PolyFlowReceiver
interface CharSequence {
    int length();
    char charAt(int arg0);
    CharSequence subSequence(int arg0, int arg1);
    String toString();
}

class Class{
        Constructor<T> getConstructor(Class<?>[] parameterTypes) throws NoSuchMethodException,SecurityException;
        Field getDeclaredField(String name) throws NoSuchFieldException,SecurityException;
        String getSimpleName();
        int getModifiers();
        boolean isMemberClass();
        ClassLoader getClassLoader();
        static Class<?> forName(String arg0) throws ClassNotFoundException;
        Method getDeclaredMethod(String arg0, Class<?>[] arg1) throws NoSuchMethodException,SecurityException;
        T newInstance() throws InstantiationException,IllegalAccessException;
         String getName();
            boolean isInstance(Object arg0);
}

@PolyFlowReceiver
class ClassLoader {
    protected ClassLoader(ClassLoader arg0);
    protected ClassLoader();
    Class<?> loadClass(String arg0) throws ClassNotFoundException;
    protected Class<?> loadClass(String arg0, boolean arg1) throws ClassNotFoundException;
    protected Object getClassLoadingLock(String arg0);
    protected Class<?> findClass(String arg0) throws ClassNotFoundException;
    protected Class<?> defineClass(byte[] arg0, int arg1, int arg2) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, byte[] arg1, int arg2, int arg3) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, byte[] arg1, int arg2, int arg3, ProtectionDomain arg4) throws ClassFormatError;
    protected Class<?> defineClass(String arg0, ByteBuffer arg1, ProtectionDomain arg2) throws ClassFormatError;
    protected void resolveClass(Class<?> arg0);
    protected Class<?> findSystemClass(String arg0) throws ClassNotFoundException;
    protected Class<?> findLoadedClass(String arg0);
    protected void setSigners(Class<?> arg0, Object[] arg1);
    URL getResource(String arg0);
    Enumeration<URL> getResources(String arg0) throws IOException;
    protected URL findResource(String arg0);
    protected Enumeration<URL> findResources(String arg0) throws IOException;
    protected static boolean registerAsParallelCapable();
    static URL getSystemResource(String arg0);
    static Enumeration<URL> getSystemResources(String arg0) throws IOException;
    InputStream getResourceAsStream(String arg0);
    static InputStream getSystemResourceAsStream(String arg0);
    ClassLoader getParent();
    static ClassLoader getSystemClassLoader();
    protected Package definePackage(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, URL arg7) throws IllegalArgumentException;
    protected Package getPackage(String arg0);
    protected Package[] getPackages();
    protected String findLibrary(String arg0);
    void setDefaultAssertionStatus(boolean arg0);
    void setPackageAssertionStatus(String arg0, boolean arg1);
    void setClassAssertionStatus(String arg0, boolean arg1);
    void clearAssertionStatus();
}

@PolyFlowReceiver
interface Comparable<T> {
    int compareTo(T arg0);
}

@PolyFlowReceiver
class Double extends Number implements Comparable<Double> {
//Added by pbsf
    final double POSITIVE_INFINITY;
    final double NEGATIVE_INFINITY;
    final double NaN;
    final double MAX_VALUE;
    final double MIN_NORMAL;
    final double MIN_VALUE;
    final int MAX_EXPONENT;
    final int MIN_EXPONENT;
    final int SIZE;
    final Class<Double> TYPE;
    static String toString(double arg0);
    static String toHexString(double arg0);
    static Double valueOf(String arg0) throws NumberFormatException;
    static Double valueOf(double arg0);
    static double parseDouble(String arg0) throws NumberFormatException;
    static boolean isNaN(double arg0);
    static boolean isInfinite(double arg0);
    Double(double arg0);
    Double(String arg0) throws NumberFormatException;
    boolean isNaN();
    boolean isInfinite();
    String toString();
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    int hashCode();
    boolean equals(Object arg0);
    static long doubleToLongBits(double arg0);
    static long doubleToRawLongBits(double arg0);
    static double longBitsToDouble(long arg0);
    int compareTo(Double arg0);
    static int compare(double arg0, double arg1);
}

@PolyFlowReceiver
class IllegalStateException extends RuntimeException {
//Added by pbsf
    IllegalStateException();
    IllegalStateException(String arg0);
    IllegalStateException(String arg0, Throwable arg1);
    IllegalStateException(Throwable arg0);
}

@PolyFlowReceiver
class Enum<E> implements Comparable<E>, Serializable {
    String name();
    int ordinal();
    protected Enum(String arg0, int arg1);
    String toString();
    boolean equals(Object arg0);
    int hashCode();
    protected Object clone() throws CloneNotSupportedException;
    int compareTo(E arg0);
    Class<E> getDeclaringClass();
    static <T> T valueOf(Class<T> arg0, String arg1);
    protected void finalize();
}
class Error{
            Error(String arg0);
}

class Exception{
        Exception(String message);
        Exception(Throwable arg0);
        Exception(String arg0, Throwable arg1);
        Exception();

}

@PolyFlowReceiver
class Float extends Number implements Comparable<Float> {
//Added by pbsf
    final float POSITIVE_INFINITY;
    final float NEGATIVE_INFINITY;
    final float NaN;
    final float MAX_VALUE;
    final float MIN_NORMAL;
    final float MIN_VALUE;
    final int MAX_EXPONENT;
    final int MIN_EXPONENT;
    final int SIZE;
    final Class<Float> TYPE;
    static String toString(float arg0);
    static String toHexString(float arg0);
    @PolyFlow
    static Float valueOf(String arg0) throws NumberFormatException;
    static Float valueOf(float arg0);
    static float parseFloat(String arg0) throws NumberFormatException;
    static boolean isNaN(float arg0);
    static boolean isInfinite(float arg0);
    Float(float arg0);
    Float(double arg0);
    Float(String arg0) throws NumberFormatException;
    boolean isNaN();
    boolean isInfinite();
    String toString();
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    int hashCode();
    boolean equals(Object arg0);
    static int floatToIntBits(float arg0);
    static int floatToRawIntBits(float arg0);
    static float intBitsToFloat(int arg0);
    int compareTo(Float arg0);
    static int compare(float arg0, float arg1);
}

class IllegalArgumentException{
        IllegalArgumentException();
        IllegalArgumentException(Throwable arg0);
        IllegalArgumentException(String arg0);
        IllegalArgumentException(String arg0, Throwable arg1);
}
class UnsupportedOperationException{
            UnsupportedOperationException(String arg0);
            UnsupportedOperationException();
}
class NumberFormatException{
            NumberFormatException(String arg0);
}

@PolyFlowReceiver
class Integer extends Number implements Comparable<Integer> {
//Added by smillst
    final @Source(FlowPermission.LITERAL) int MIN_VALUE;
    final @Source(FlowPermission.LITERAL) int MAX_VALUE;
    final @Source(FlowPermission.LITERAL) int SIZE;
    static @PolyFlow String toString(int arg0, int arg1);
    static @PolyFlow String toHexString(int arg0);
    static @PolyFlow String toOctalString(int arg0);
    static @PolyFlow String toBinaryString(int arg0);
    static @PolyFlow String toString(int arg0);
    static @PolyFlow int parseInt(String arg0, int arg1) throws NumberFormatException;
    static @PolyFlow int parseInt(String arg0) throws NumberFormatException;
    static @PolyFlow Integer valueOf(String arg0, int arg1) throws NumberFormatException;
    static @PolyFlow Integer valueOf(String arg0) throws NumberFormatException;
    @PolyFlow
    static Integer valueOf(int arg0);
    Integer(int arg0);
    @PolyFlow Integer(String arg0) throws NumberFormatException;
    @PolyFlow byte byteValue();
    @PolyFlow short shortValue();
    @PolyFlow int intValue();
    @PolyFlow long longValue();
    @PolyFlow float floatValue();
    @PolyFlow double doubleValue();
    @PolyFlow String toString();
    @PolyFlow int hashCode();
    @PolyFlow boolean equals(Object arg0);
    static @PolyFlow Integer getInteger(String arg0);
    static @PolyFlow Integer getInteger(String arg0, int arg1);
    static @PolyFlow Integer getInteger(String arg0, Integer arg1);
    static @PolyFlow Integer decode(String arg0) throws NumberFormatException;
    @PolyFlow int compareTo(Integer arg0);
    static @PolyFlow int compare(int arg0, int arg1);
    static @PolyFlow int highestOneBit(int arg0);
    static @PolyFlow int lowestOneBit(int arg0);
    static @PolyFlow int numberOfLeadingZeros(int arg0);
    static @PolyFlow int numberOfTrailingZeros(int arg0);
    static @PolyFlow int bitCount(int arg0);
    static @PolyFlow int rotateLeft(int arg0, int arg1);
    static @PolyFlow int rotateRight(int arg0, int arg1);    
    static @PolyFlow int reverse(int arg0);    
    static @PolyFlow int signum(int arg0);    
    static @PolyFlow int reverseBytes(int arg0);
}

@PolyFlowReceiver
interface Iterable<T> {
    Iterator<T> iterator();
}

@PolyFlowReceiver
class Long extends Number implements Comparable<Long> {
//Added by pbsf
    final long MIN_VALUE;
    final long MAX_VALUE;
    final Class<Long> TYPE;
    final int SIZE;
    static String toString(long arg0, int arg1);
    static String toHexString(long arg0);
    static String toOctalString(long arg0);
    static String toBinaryString(long arg0);
    static String toString(long arg0);
    static long parseLong(String arg0, int arg1) throws NumberFormatException;
    static long parseLong(String arg0) throws NumberFormatException;
    static Long valueOf(String arg0, int arg1) throws NumberFormatException;
    static Long valueOf(String arg0) throws NumberFormatException;
    static Long valueOf(long arg0);
    static Long decode(String arg0) throws NumberFormatException;
    Long(long arg0);
    Long(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    static Long getLong(String arg0);
    static Long getLong(String arg0, long arg1);
    static Long getLong(String arg0, Long arg1);
    int compareTo(Long arg0);
    static int compare(long arg0, long arg1);
    static long highestOneBit(long arg0);
    static long lowestOneBit(long arg0);
    static int numberOfLeadingZeros(long arg0);
    static int numberOfTrailingZeros(long arg0);
    static int bitCount(long arg0);
    static long rotateLeft(long arg0, int arg1);
    static long rotateRight(long arg0, int arg1);
    static long reverse(long arg0);
    static int signum(long arg0);
    static long reverseBytes(long arg0);
}

class Math {
//Added by smillst
    @PolyFlow
    static double abs(double a);
    @PolyFlow
    static float abs(float a);
    @PolyFlow
    static int abs(int a);
    @PolyFlow
    static long abs(long a);
    @PolyFlow
    static double acos(double a);
    @PolyFlow
    static double asin(double a);
    @PolyFlow
    static double atan(double a);
    @PolyFlow
    static double atan2(double y, double x);
    @PolyFlow
    static double cbrt(double a);
    @PolyFlow
    static double ceil(double a);
    @PolyFlow
    static double copySign(double magnitude, double sign);
    @PolyFlow
    static float copySign(float magnitude, float sign);
    @PolyFlow
    static double cos(double a);
    @PolyFlow
    static double cosh(double x);
    @PolyFlow
    static double exp(double a);
    @PolyFlow
    static double expm1(double x);
    @PolyFlow
    static double floor(double a);
    @PolyFlow
    static int getExponent(double d);
    @PolyFlow
    static int getExponent(float f);
    @PolyFlow
    static double hypot(double x, double y);
    @PolyFlow
    static double IEEEremainder(double f1, double f2);
    @PolyFlow
    static double log(double a);
    @PolyFlow
    static double log10(double a);
    @PolyFlow
    static double log1p(double x);
    @PolyFlow
    static double max(double a, double b);
    @PolyFlow
    static float max(float a, float b);
    @PolyFlow
    static int max(int a, int b);
    @PolyFlow
    static long max(long a, long b);
    @PolyFlow
    static double min(double a, double b);
    @PolyFlow
    static float min(float a, float b);
    @PolyFlow
    static int min(int a, int b);
    @PolyFlow
    static long min(long a, long b);
    @PolyFlow
    static double nextAfter(double start, double direction);
    @PolyFlow
    static float nextAfter(float start, double direction);
    @PolyFlow
    static double nextUp(double d);
    @PolyFlow
    static float nextUp(float f);
    @PolyFlow
    static double pow(double a, double b);
    @PolyFlow
    static double random();
    @PolyFlow
    static double rint(double a);
    @PolyFlow
    static long round(double a);
    @PolyFlow
    static int round(float a);
    @PolyFlow
    static double scalb(double d, int scaleFactor);
    @PolyFlow
    static float scalb(float f, int scaleFactor);
    @PolyFlow
    static double signum(double d);
    @PolyFlow
    static float signum(float f);
    @PolyFlow
    static double sin(double a);
    @PolyFlow
    static double sinh(double x);
    @PolyFlow
    static double sqrt(double a);
    @PolyFlow
    static double tan(double a);
    @PolyFlow
    static double tanh(double x);
    @PolyFlow
    static double toDegrees(double angrad);
    @PolyFlow
    static double toRadians(double angdeg);
    @PolyFlow
    static double ulp(double d);
    @PolyFlow
    static float ulp(float f);

}

@PolyFlowReceiver
class Number implements Serializable {
    Number();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    byte byteValue();
    short shortValue();
}

class Object {
//Added by smillst
    Object();
    Class<?> getClass();
    @PolyFlowReceiver
    int hashCode();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    protected Object clone() throws CloneNotSupportedException;
    @PolyFlowReceiver
    String toString();
    void notify();
    void notifyAll();
    void wait(long arg0) throws InterruptedException;
    void wait(long arg0, int arg1) throws InterruptedException;
    void wait() throws InterruptedException;
    protected void finalize() throws Throwable;
}

@PolyFlowReceiver
class Process {
    Process();
    OutputStream getOutputStream();
    InputStream getInputStream();
    InputStream getErrorStream();
    int waitFor() throws InterruptedException;
    int exitValue();
    void destroy();
}

class ProcessBuilder {
//Added by pbsf
    ProcessBuilder(@Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER)String> arg0);
    ProcessBuilder( @Sink(PROCESS_BUILDER) String @Sink(PROCESS_BUILDER) [] arg0);
    ProcessBuilder command(@Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER) String> arg0);
    ProcessBuilder command(@Sink(PROCESS_BUILDER) String @Sink(PROCESS_BUILDER) [] arg0);
    @Sink(PROCESS_BUILDER) List< @Sink(PROCESS_BUILDER) String> command();
    @Sink(PROCESS_BUILDER) Map<@Sink(PROCESS_BUILDER) String,@Sink(PROCESS_BUILDER) String> environment();
    @Sink(PROCESS_BUILDER) File directory();
    ProcessBuilder directory(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectInput(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectOutput(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectError(@Sink(PROCESS_BUILDER) Redirect arg0);
    ProcessBuilder redirectInput(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectOutput(@Sink(PROCESS_BUILDER) File arg0);
    ProcessBuilder redirectError(@Sink(PROCESS_BUILDER) File arg0);
    @Sink(PROCESS_BUILDER) Redirect redirectInput();
    @Sink(PROCESS_BUILDER) Redirect redirectOutput();
    @Sink(PROCESS_BUILDER) Redirect redirectError();
    ProcessBuilder inheritIO();
    boolean redirectErrorStream();
    ProcessBuilder redirectErrorStream(boolean arg0);
    @Source(PROCESS_BUILDER) Process start() throws IOException;
}

@PolyFlowReceiver
class ProcessBuilder$Redirect {
//Added by pbsf
    final Redirect PIPE;
    final Redirect INHERIT;
    Type type();
    File file();
    static Redirect from(File arg0);
    static Redirect to(File arg0);
    static Redirect appendTo(File arg0);
    boolean equals(Object arg0);
    int hashCode();
}


@PolyFlowReceiver
class Runtime {
    static Runtime getRuntime();
    void exit(int arg0);
    void addShutdownHook(Thread arg0);
    boolean removeShutdownHook(Thread arg0);
    void halt(int arg0);
    static void runFinalizersOnExit(boolean arg0);
    Process exec(String arg0) throws IOException;
    Process exec(String arg0, String[] arg1) throws IOException;
    Process exec(String arg0, String[] arg1, File arg2) throws IOException;
    Process exec(String[] arg0) throws IOException;
    Process exec(String[] arg0, String[] arg1) throws IOException;
    Process exec(String[] arg0, String[] arg1, File arg2) throws IOException;
    int availableProcessors();
    long freeMemory();
    long totalMemory();
    long maxMemory();
    void gc();
    void runFinalization();
    void traceInstructions(boolean arg0);
    void traceMethodCalls(boolean arg0);
    void load(String arg0);
    void loadLibrary(String arg0);
    InputStream getLocalizedInputStream(InputStream arg0);
    OutputStream getLocalizedOutputStream(OutputStream arg0);
}

class RuntimeException{
            RuntimeException(String arg0);
            RuntimeException(String arg0, Throwable arg1);
            RuntimeException(Throwable arg0);

}
class IndexOutOfBoundsException{
        IndexOutOfBoundsException();               
        IndexOutOfBoundsException(String arg0);

}
class NullPointerException{
            NullPointerException();
            NullPointerException(String arg0);

}

@PolyFlowReceiver
class Readable{
            int read(CharBuffer arg0) throws IOException;
}

@PolyFlowReceiver
class Short extends Number implements Comparable<Short> {
//Added by pbsf
    final short MIN_VALUE;
    final short MAX_VALUE;
    final Class<Short> TYPE;
    final int SIZE;
    static String toString(short arg0);
    static short parseShort(String arg0, int arg1) throws NumberFormatException;
    static short parseShort(String arg0) throws NumberFormatException;
    static Short valueOf(String arg0, int arg1) throws NumberFormatException;
    static Short valueOf(String arg0) throws NumberFormatException;
    static Short valueOf(short arg0);
    static Short decode(String arg0) throws NumberFormatException;
    Short(short arg0);
    Short(String arg0) throws NumberFormatException;
    byte byteValue();
    short shortValue();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(Short arg0);
    static int compare(short arg0, short arg1);
    static short reverseBytes(short arg0);
}

@PolyFlowReceiver
class StringBuilder extends AbstractStringBuilder implements Serializable, CharSequence {
//Added by smillst
    @PolyFlow
    StringBuilder();
    @PolyFlow
    StringBuilder(int arg0);
    @PolyFlow
    StringBuilder(String arg0);
    @PolyFlow
    StringBuilder(CharSequence arg0);
    
    StringBuilder append(Object arg0);
    StringBuilder append(String arg0);
    StringBuilder append(StringBuffer arg0);
    StringBuilder append(CharSequence arg0);
    StringBuilder append(CharSequence arg0, int arg1, int arg2);
    StringBuilder append(char[] arg0);
    StringBuilder append(char[] arg0, int arg1, int arg2);
    StringBuilder append(boolean arg0);
    StringBuilder append(char arg0);
    StringBuilder append(int arg0);
    StringBuilder append(long arg0);
    StringBuilder append(float arg0);
    StringBuilder append(double arg0);
    StringBuilder appendCodePoint(int arg0);
    StringBuilder delete(int arg0, int arg1);
    StringBuilder deleteCharAt(int arg0);
    StringBuilder replace(int arg0, int arg1, String arg2);
    StringBuilder insert(int arg0, char[] arg1, int arg2, int arg3);
    StringBuilder insert(int arg0, Object arg1);
    StringBuilder insert(int arg0, String arg1);
    StringBuilder insert(int arg0, char[] arg1);
    StringBuilder insert(int arg0, CharSequence arg1);
    StringBuilder insert(int arg0, CharSequence arg1, int arg2, int arg3);
    StringBuilder insert(int arg0, boolean arg1);
    StringBuilder insert(int arg0, char arg1);
    StringBuilder insert(int arg0, int arg1);
    StringBuilder insert(int arg0, long arg1);
    StringBuilder insert(int arg0, float arg1);
    StringBuilder insert(int arg0, double arg1);
    int indexOf(String arg0);
    int indexOf(String arg0, int arg1);
    int lastIndexOf(String arg0);
    int lastIndexOf(String arg0, int arg1);
    StringBuilder reverse();
    String toString();
}


/*[equals, length, valueOf, trim, substring, charAt, indexOf, contains, replace, startsWith, format, split, 
   toUpperCase, <init>, hashCode, toCharArray, getChars, replaceAll, getBytes, endsWith, equalsIgnoreCase, 
   lastIndexOf, toLowerCase, compareTo, toString, intern, isEmpty, contentEquals, replaceFirst, concat, compareToIgnoreCase, 
   matches, copyValueOf]*/
   
   class String implements Serializable, Comparable<String>, CharSequence {
   //Added by SOM
   //TODO: Should indexs into the char[] be PolyFlow or just LITERAL?
    final Comparator<String> CASE_INSENSITIVE_ORDER;
    @PolyFlow
    String();
    @PolyFlow
    String(String arg0);
    @PolyFlow
    String(char[] arg0);
    @PolyFlow
    String(char[] arg0, int arg1, int arg2);
    @PolyFlow
    String(int[] arg0, int arg1, int arg2);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, int arg3);
    @PolyFlow
    String(byte[] arg0, int arg1);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, String arg3) throws UnsupportedEncodingException;
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2, Charset arg3);
    @PolyFlow
    String(byte[] arg0, String arg1) throws UnsupportedEncodingException;
    @PolyFlow
    String(byte[] arg0, Charset arg1);
    @PolyFlow
    String(byte[] arg0, int arg1, int arg2);
    @PolyFlow
    String(byte[] arg0);
    @PolyFlow
    String(StringBuffer arg0);
    @PolyFlow
    String(StringBuilder arg0);
    
    int length();
    boolean isEmpty();
    @PolyFlowReceiver
    char charAt(int arg0);
    @PolyFlowReceiver
    int codePointAt(int arg0);
    @PolyFlowReceiver
    int codePointBefore(int arg0);
    @PolyFlowReceiver
    int codePointCount(int arg0, int arg1);
    @PolyFlowReceiver
    int offsetByCodePoints(int arg0, int arg1);
    @PolyFlowReceiver
    void getChars(int arg0, int arg1, char[] arg2, int arg3);
    @PolyFlowReceiver
    void getBytes(int arg0, int arg1, byte[] arg2, int arg3);
    @PolyFlowReceiver
    byte[] getBytes(String arg0) throws UnsupportedEncodingException;
    @PolyFlowReceiver
    byte[] getBytes(Charset arg0);
    @PolyFlowReceiver
    byte[] getBytes();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    boolean contentEquals(StringBuffer arg0);
    @PolyFlowReceiver
    boolean contentEquals(CharSequence arg0);
    @PolyFlowReceiver
    boolean equalsIgnoreCase(String arg0);
    @PolyFlowReceiver
    int compareTo(String arg0);
    @PolyFlowReceiver
    int compareToIgnoreCase(String arg0);
    @PolyFlowReceiver
    boolean regionMatches(int arg0, String arg1, int arg2, int arg3);
    @PolyFlowReceiver
    boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4);
    @PolyFlowReceiver
    boolean startsWith(String arg0, int arg1);
    @PolyFlowReceiver
    boolean startsWith(String arg0);
    @PolyFlowReceiver
    boolean endsWith(String arg0);
    @PolyFlowReceiver
    int hashCode();
    @PolyFlowReceiver
    int indexOf(int arg0);
    @PolyFlowReceiver
    int indexOf(int arg0, int arg1);
    @PolyFlowReceiver
    int lastIndexOf(int arg0);
    @PolyFlowReceiver
    int lastIndexOf(int arg0, int arg1);
    @PolyFlowReceiver
    int indexOf(String arg0);
    @PolyFlowReceiver
    int indexOf(String arg0, int arg1);
    @PolyFlowReceiver
    int lastIndexOf(String arg0);
    @PolyFlowReceiver
    int lastIndexOf(String arg0, int arg1);
    @PolyFlowReceiver
    String substring(int arg0);
    @PolyFlowReceiver
    String substring(int arg0, int arg1);
    @PolyFlowReceiver
    CharSequence subSequence(int arg0, int arg1);
    @PolyFlowReceiver
    String concat(String arg0);
    @PolyFlowReceiver
    String replace(char arg0, char arg1);
    @PolyFlowReceiver
    boolean matches(String arg0);
    @PolyFlowReceiver
    boolean contains(CharSequence arg0);
    @PolyFlowReceiver
    String replaceFirst(String arg0, String arg1);
    @PolyFlowReceiver
    String replaceAll(String arg0, String arg1);
    @PolyFlowReceiver
    String replace(CharSequence arg0, CharSequence arg1);
    @PolyFlowReceiver
    String[] split(String arg0, int arg1);
    @PolyFlowReceiver
    String[] split(String arg0);
    String toLowerCase(Locale arg0);
    String toLowerCase();
    String toUpperCase(Locale arg0);
    String toUpperCase();
    String trim();
    @PolyFlowReceiver
    String toString();
    @PolyFlowReceiver
    char[] toCharArray();
    @PolyFlow
    static String format(String arg0, Object[] arg1);
    @PolyFlow
    static String format(Locale arg0, String arg1, Object[] arg2);
    @PolyFlow
    static String valueOf(Object arg0);
    @PolyFlow
    static String valueOf(char[] arg0);
    @PolyFlow
    static String valueOf(char[] arg0, int arg1, int arg2);
    @PolyFlow
    static String copyValueOf(char[] arg0, int arg1, int arg2);
    @PolyFlow
    static String copyValueOf(char[] arg0);
    @PolyFlow
    static String valueOf(boolean arg0);
    @PolyFlow
    static String valueOf(char arg0);
    @PolyFlow
    static String valueOf(int arg0);
    @PolyFlow
    static String valueOf(long arg0);
    @PolyFlow
    static String valueOf(float arg0);
    @PolyFlow
    static String valueOf(double arg0);
    @PolyFlowReceiver
    String intern();
}

// [append, toString, <init>, length, insert, indexOf, substring, setCharAt, setLength]
class StringBuffer implements Serializable, CharSequence {
    // DAM
   
    StringBuffer();

    @PolyFlow
    StringBuffer(CharSequence seq);

    @PolyFlow
    StringBuffer(int capacity);

    @PolyFlow
    StringBuffer(String str);

    @PolyFlowReceiver
    StringBuffer    append(boolean b);
    @PolyFlowReceiver
    StringBuffer    append(char c);
    @PolyFlowReceiver
    StringBuffer    append(char[] str);
    @PolyFlowReceiver
    StringBuffer    append(char[] str, int offset, int len);
    @PolyFlowReceiver
    StringBuffer    append(CharSequence s);
    @PolyFlowReceiver
    StringBuffer    append(CharSequence s, int start, int end);
    @PolyFlowReceiver
    StringBuffer    append(double d);
    @PolyFlowReceiver
    StringBuffer    append(float f);
    @PolyFlowReceiver
    StringBuffer    append(int i);
    @PolyFlowReceiver
    StringBuffer    append(long lng);
    @PolyFlowReceiver
    StringBuffer    append(Object obj);
    @PolyFlowReceiver
    StringBuffer    append(String str);
    @PolyFlowReceiver
    StringBuffer    append(StringBuffer sb);
    @PolyFlowReceiver
    StringBuffer    appendCodePoint(int codePoint);
    @PolyFlowReceiver
    int capacity();
    @PolyFlowReceiver
    char    charAt(int index);
    @PolyFlowReceiver
    int codePointAt(int index);
    @PolyFlowReceiver
    int codePointBefore(int index);
    @PolyFlowReceiver
    int codePointCount(int beginIndex, int endIndex);
    @PolyFlowReceiver
    StringBuffer    delete(int start, int end);
    @PolyFlowReceiver
    StringBuffer    deleteCharAt(int index);
    // TODO: Need polyflow on receiver and params with no return type.
    void    ensureCapacity(int minimumCapacity);
    // TODO: Need polyflow on receiver and params with no return type.
    // Especially here since the data is being set in an out param.
    void    getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin);
    @PolyFlowReceiver
    int indexOf(String str);
    @PolyFlowReceiver
    int indexOf(String str, int fromIndex);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, boolean b);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, char c);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, char[] str);
    @PolyFlowReceiver
    StringBuffer    insert(int index, char[] str, int offset, int len);
    @PolyFlowReceiver
    StringBuffer    insert(int dstOffset, CharSequence s);
    @PolyFlowReceiver
    StringBuffer    insert(int dstOffset, CharSequence s, int start, int end);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, double d);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, float f);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, int i);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, long l);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, Object obj);
    @PolyFlowReceiver
    StringBuffer    insert(int offset, String str);
    @PolyFlowReceiver
    int lastIndexOf(String str);
    @PolyFlowReceiver
    int lastIndexOf(String str, int fromIndex);
    @PolyFlowReceiver
    int length();
    @PolyFlowReceiver
    int offsetByCodePoints(int index, int codePointOffset);
    @PolyFlowReceiver
    StringBuffer    replace(int start, int end, String str);
    @PolyFlowReceiver
    StringBuffer    reverse();
    // TODO: Need polyflow on receiver and params with no return type.
    void    setCharAt(int index, char ch);
    // TODO: Need polyflow on receiver and params with no return type.
    void    setLength(int newLength);
    @PolyFlowReceiver
    CharSequence    subSequence(int start, int end);
    @PolyFlowReceiver
    String  substring(int start);
    @PolyFlowReceiver
    String  substring(int start, int end);
    @PolyFlowReceiver
    String  toString();
    void    trimToSize();
}


class System {
//SOM: Android it writes in, out, err, either to /dev/null or the log 
    final @Source(READ_LOGS) InputStream in;
    final @Sink(WRITE_LOGS) PrintStream out;
    final @Sink(WRITE_LOGS) PrintStream err;
    static void setIn(@Source(WRITE_LOGS) InputStream arg0);
    static void setOut(@Sink(WRITE_LOGS) PrintStream arg0);
    static void setErr(@Sink(WRITE_LOGS) PrintStream arg0);
    
    static SecurityManager getSecurityManager();
    static @Source(READ_TIME) long currentTimeMillis();
    static @Source(READ_TIME) long nanoTime();
    
    static void arraycopy(@PolySource @PolySink Object src, int srcPos, @PolySource @PolySink Object dest, int destPos, int length) ;
    @PolyFlow
    static int identityHashCode(Object arg0);
    static @Source(SYSTEM_PROPERTIES) Properties getProperties();
    static String lineSeparator();
    static void setProperties(@Sink(SYSTEM_PROPERTIES) Properties arg0);
    static @Source(SYSTEM_PROPERTIES) String getProperty(@Sink(SYSTEM_PROPERTIES) String arg0);
    static @Source(SYSTEM_PROPERTIES) String getProperty(@Sink(SYSTEM_PROPERTIES) String arg0, String arg1);
    static @Source(SYSTEM_PROPERTIES) String setProperty(@Sink(SYSTEM_PROPERTIES) String arg0, String arg1);
    static @Source(SYSTEM_PROPERTIES) String clearProperty(@Sink(SYSTEM_PROPERTIES) String arg0);

    static void exit(int arg0);

    static @Source(SYSTEM_PROPERTIES) String mapLibraryName(String arg0);
    
    //[ getSecurityManager, loadLibrary]
}

@PolyFlowReceiver
class Thread implements Runnable {
    final @Source(FlowPermission.LITERAL) int MIN_PRIORITY;
    final @Source(FlowPermission.LITERAL) int NORM_PRIORITY;
    final @Source(FlowPermission.LITERAL) int MAX_PRIORITY;
    static Thread currentThread();
    static void yield();
    static void sleep(long arg0) throws InterruptedException;
    static void sleep(long arg0, int arg1) throws InterruptedException;
    protected Object clone() throws CloneNotSupportedException;
    Thread();
    Thread(Runnable arg0);
    Thread(ThreadGroup arg0, Runnable arg1);
    Thread(String arg0);
    Thread(ThreadGroup arg0, String arg1);
    Thread(Runnable arg0, String arg1);
    Thread(ThreadGroup arg0, Runnable arg1, String arg2);
    Thread(ThreadGroup arg0, Runnable arg1, String arg2, long arg3);
    void start();
    void run();
    void stop();
    void stop(Throwable arg0);
    void interrupt();
    static boolean interrupted();
    boolean isInterrupted();
    void destroy();
    boolean isAlive();
    void suspend();
    void resume();
    void setPriority(int arg0);
    int getPriority();
    void setName(String arg0);
    String getName();
    ThreadGroup getThreadGroup();
    static int activeCount();
    static int enumerate(Thread[] arg0);
    int countStackFrames();
    void join(long arg0) throws InterruptedException;
    void join(long arg0, int arg1) throws InterruptedException;
    void join() throws InterruptedException;
    static void dumpStack();
    void setDaemon(boolean arg0);
    boolean isDaemon();
    void checkAccess();
    String toString();
    ClassLoader getContextClassLoader();
    void setContextClassLoader(ClassLoader arg0);
    static boolean holdsLock(Object arg0);
    StackTraceElement[] getStackTrace();
    static Map<Thread,StackTraceElement[]> getAllStackTraces();
    long getId();
    State getState();
    static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler arg0);
    static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler();
    UncaughtExceptionHandler getUncaughtExceptionHandler();
    void setUncaughtExceptionHandler(UncaughtExceptionHandler arg0);
}

@PolyFlowReceiver
interface Thread$UncaughtExceptionHandler {
    void uncaughtException(Thread arg0, Throwable arg1);
}

@PolyFlowReceiver
class ThreadLocal<T> {
//Added by pbsf
    protected T initialValue();
    ThreadLocal();
    T get();
    void set(T arg0);
    void remove();
}


class Throwable implements Serializable {
//SOM
    Throwable();
    Throwable(String arg0);
    Throwable(String arg0, Throwable arg1);
    Throwable(Throwable arg0);
    protected Throwable(String arg0, Throwable arg1, boolean arg2, boolean arg3);
    String getMessage();
    String getLocalizedMessage();
    Throwable getCause();
    Throwable initCause(Throwable arg0);
    String toString();
    void printStackTrace();
    void printStackTrace(PrintStream arg0);
    void printStackTrace(PrintWriter arg0);
    Throwable fillInStackTrace();
    StackTraceElement[] getStackTrace();
    void setStackTrace(StackTraceElement[] arg0);
    void addSuppressed(Throwable arg0);
    Throwable[] getSuppressed();
}

package java.lang.ref;

@PolyFlowReceiver
class ReferenceQueue<T> {
//Added by pbsf
    ReferenceQueue();
    Reference<? extends T> poll();
    Reference<? extends T> remove(long arg0) throws IllegalArgumentException,InterruptedException;
    Reference<? extends T> remove() throws InterruptedException;
}

@PolyFlowReceiver
class SoftReference<T> extends Reference<T> {
//Added by pbsf
    SoftReference(T arg0);
    SoftReference(T arg0, ReferenceQueue<? super T> arg1);
    T get();
}


@PolyFlowReceiver
class WeakReference<T> extends Reference<T> {
//Added by pbsf
    WeakReference(T arg0);
    WeakReference(T arg0, ReferenceQueue<? super T> arg1);
}


package java.lang.reflect;
class AccessibleObject{
        void setAccessible(boolean arg0) throws SecurityException;
}
@PolyFlowReceiver
class Array {
//Added by pbsf
    static Object newInstance(Class<?> arg0, int arg1) throws NegativeArraySizeException;
    static Object newInstance(Class<?> arg0, int[] arg1) throws IllegalArgumentException,NegativeArraySizeException;
    static int getLength(Object arg0) throws IllegalArgumentException;
    static Object get(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static boolean getBoolean(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static byte getByte(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static char getChar(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static short getShort(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static int getInt(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static long getLong(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static float getFloat(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static double getDouble(Object arg0, int arg1) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void set(Object arg0, int arg1, Object arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setBoolean(Object arg0, int arg1, boolean arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setByte(Object arg0, int arg1, byte arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setChar(Object arg0, int arg1, char arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setShort(Object arg0, int arg1, short arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setInt(Object arg0, int arg1, int arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setLong(Object arg0, int arg1, long arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setFloat(Object arg0, int arg1, float arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
    static void setDouble(Object arg0, int arg1, double arg2) throws IllegalArgumentException,ArrayIndexOutOfBoundsException;
}

@PolyFlowReceiver
class Constructor<T> {
//Added by pbsf
    Class<T> getDeclaringClass();
    String getName();
    int getModifiers();
    TypeVariable<Constructor<T>>[] getTypeParameters();
    Class<?>[] getParameterTypes();
    Type[] getGenericParameterTypes();
    Class<?>[] getExceptionTypes();
    Type[] getGenericExceptionTypes();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    T newInstance(Object[] arg0) throws InstantiationException,IllegalAccessException,IllegalArgumentException,InvocationTargetException;
    boolean isVarArgs();
    boolean isSynthetic();
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
    Annotation[][] getParameterAnnotations();
}

@PolyFlowReceiver
class Field extends AccessibleObject implements Member {
//Added by pbsf
    Class<?> getDeclaringClass();
    String getName();
    int getModifiers();
    boolean isEnumConstant();
    boolean isSynthetic();
    Class<?> getType();
    Type getGenericType();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    Object get(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    boolean getBoolean(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    byte getByte(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    char getChar(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    short getShort(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    int getInt(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    long getLong(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    float getFloat(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    double getDouble(Object arg0) throws IllegalArgumentException,IllegalAccessException;
    void set(Object arg0, Object arg1) throws IllegalArgumentException,IllegalAccessException;
    void setBoolean(Object arg0, boolean arg1) throws IllegalArgumentException,IllegalAccessException;
    void setByte(Object arg0, byte arg1) throws IllegalArgumentException,IllegalAccessException;
    void setChar(Object arg0, char arg1) throws IllegalArgumentException,IllegalAccessException;
    void setShort(Object arg0, short arg1) throws IllegalArgumentException,IllegalAccessException;
    void setInt(Object arg0, int arg1) throws IllegalArgumentException,IllegalAccessException;
    void setLong(Object arg0, long arg1) throws IllegalArgumentException,IllegalAccessException;
    void setFloat(Object arg0, float arg1) throws IllegalArgumentException,IllegalAccessException;
    void setDouble(Object arg0, double arg1) throws IllegalArgumentException,IllegalAccessException;
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
}

@PolyFlowReceiver
interface GenericArrayType extends Type {
    Type getGenericComponentType();
}
class InvocationTargetException{
            Throwable getCause();
}

@PolyFlowReceiver
class Method {
//Added by pbsf
    Class<?> getDeclaringClass();
    String getName();
    int getModifiers();
    TypeVariable<Method>[] getTypeParameters();
    Class<?> getReturnType();
    Type getGenericReturnType();
    Class<?>[] getParameterTypes();
    Type[] getGenericParameterTypes();
    Class<?>[] getExceptionTypes();
    Type[] getGenericExceptionTypes();
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    String toGenericString();
    @Source(FlowPermission.REFLECTION) Object invoke(@Sink(REFLECTION) Object arg0, @Sink(REFLECTION) Object @Sink(REFLECTION) [] arg1) throws IllegalAccessException,IllegalArgumentException,InvocationTargetException;
    boolean isBridge();
    boolean isVarArgs();
    boolean isSynthetic();
    Object getDefaultValue();
    <T> T getAnnotation(Class<T> arg0);
    Annotation[] getDeclaredAnnotations();
    Annotation[][] getParameterAnnotations();
}

@PolyFlowReceiver
class Modifier {
    final @Source(FlowPermission.LITERAL) int PUBLIC;
    final @Source(FlowPermission.LITERAL) int PRIVATE;
    final @Source(FlowPermission.LITERAL) int PROTECTED;
    final @Source(FlowPermission.LITERAL) int STATIC;
    final @Source(FlowPermission.LITERAL) int FINAL;
    final @Source(FlowPermission.LITERAL) int SYNCHRONIZED;
    final @Source(FlowPermission.LITERAL) int VOLATILE;
    final @Source(FlowPermission.LITERAL) int TRANSIENT;
    final @Source(FlowPermission.LITERAL) int NATIVE;
    final @Source(FlowPermission.LITERAL) int INTERFACE;
    final @Source(FlowPermission.LITERAL) int ABSTRACT;
    final @Source(FlowPermission.LITERAL) int STRICT;
    Modifier();
    static boolean isPublic(int arg0);
    static boolean isPrivate(int arg0);
    static boolean isProtected(int arg0);
    static boolean isStatic(int arg0);
    static boolean isFinal(int arg0);
    static boolean isSynchronized(int arg0);
    static boolean isVolatile(int arg0);
    static boolean isTransient(int arg0);
    static boolean isNative(int arg0);
    static boolean isInterface(int arg0);
    static boolean isAbstract(int arg0);
    static boolean isStrict(int arg0);
    static String toString(int arg0);
    static int classModifiers();
    static int interfaceModifiers();
    static int constructorModifiers();
    static int methodModifiers();
    static int fieldModifiers();
}

package java.math;

@PolyFlowReceiver
class BigDecimal extends Number implements Comparable<BigDecimal> {
    final BigDecimal ZERO;
    final BigDecimal ONE;
    final BigDecimal TEN;
    final int ROUND_UP;
    final int ROUND_DOWN;
    final int ROUND_CEILING;
    final int ROUND_FLOOR;
    final int ROUND_HALF_UP;
    final int ROUND_HALF_DOWN;
    final int ROUND_HALF_EVEN;
    final int ROUND_UNNECESSARY;
    BigDecimal(char[] arg0, int arg1, int arg2);
    BigDecimal(char[] arg0, int arg1, int arg2, MathContext arg3);
    BigDecimal(char[] arg0);
    BigDecimal(char[] arg0, MathContext arg1);
    BigDecimal(String arg0);
    BigDecimal(String arg0, MathContext arg1);
    BigDecimal(double arg0);
    BigDecimal(double arg0, MathContext arg1);
    BigDecimal(BigInteger arg0);
    BigDecimal(BigInteger arg0, MathContext arg1);
    BigDecimal(BigInteger arg0, int arg1);
    BigDecimal(BigInteger arg0, int arg1, MathContext arg2);
    BigDecimal(int arg0);
    BigDecimal(int arg0, MathContext arg1);
    BigDecimal(long arg0);
    BigDecimal(long arg0, MathContext arg1);
    static BigDecimal valueOf(long arg0, int arg1);
    static BigDecimal valueOf(long arg0);
    static BigDecimal valueOf(double arg0);
    BigDecimal add(BigDecimal arg0);
    BigDecimal add(BigDecimal arg0, MathContext arg1);
    BigDecimal subtract(BigDecimal arg0);
    BigDecimal subtract(BigDecimal arg0, MathContext arg1);
    BigDecimal multiply(BigDecimal arg0);
    BigDecimal multiply(BigDecimal arg0, MathContext arg1);
    BigDecimal divide(BigDecimal arg0, int arg1, int arg2);
    BigDecimal divide(BigDecimal arg0, int arg1, RoundingMode arg2);
    BigDecimal divide(BigDecimal arg0, int arg1);
    BigDecimal divide(BigDecimal arg0, RoundingMode arg1);
    BigDecimal divide(BigDecimal arg0);
    BigDecimal divide(BigDecimal arg0, MathContext arg1);
    BigDecimal divideToIntegralValue(BigDecimal arg0);
    BigDecimal divideToIntegralValue(BigDecimal arg0, MathContext arg1);
    BigDecimal remainder(BigDecimal arg0);
    BigDecimal remainder(BigDecimal arg0, MathContext arg1);
    BigDecimal[] divideAndRemainder(BigDecimal arg0);
    BigDecimal[] divideAndRemainder(BigDecimal arg0, MathContext arg1);
    BigDecimal pow(int arg0);
    BigDecimal pow(int arg0, MathContext arg1);
    BigDecimal abs();
    BigDecimal abs(MathContext arg0);
    BigDecimal negate();
    BigDecimal negate(MathContext arg0);
    BigDecimal plus();
    BigDecimal plus(MathContext arg0);
    int signum();
    int scale();
    int precision();
    BigInteger unscaledValue();
    BigDecimal round(MathContext arg0);
    BigDecimal setScale(int arg0, RoundingMode arg1);
    BigDecimal setScale(int arg0, int arg1);
    BigDecimal setScale(int arg0);
    BigDecimal movePointLeft(int arg0);
    BigDecimal movePointRight(int arg0);
    BigDecimal scaleByPowerOfTen(int arg0);
    BigDecimal stripTrailingZeros();
    int compareTo(BigDecimal arg0);
    boolean equals(Object arg0);
    BigDecimal min(BigDecimal arg0);
    BigDecimal max(BigDecimal arg0);
    int hashCode();
    String toString();
    String toEngineeringString();
    String toPlainString();
    BigInteger toBigInteger();
    BigInteger toBigIntegerExact();
    long longValue();
    long longValueExact();
    int intValue();
    int intValueExact();
    short shortValueExact();
    byte byteValueExact();
    float floatValue();
    double doubleValue();
    BigDecimal ulp();
}

@PolyFlowReceiver
class BigInteger extends Number implements Comparable<BigInteger> {
    final BigInteger ZERO;
    final BigInteger ONE;
    final BigInteger TEN;
    BigInteger(byte[] arg0);
    BigInteger(int arg0, byte[] arg1);
    BigInteger(String arg0, int arg1);
    BigInteger(String arg0);
    BigInteger(int arg0, Random arg1);
    BigInteger(int arg0, int arg1, Random arg2);
    static BigInteger probablePrime(int arg0, Random arg1);
    BigInteger nextProbablePrime();
    static BigInteger valueOf(long arg0);
    BigInteger add(BigInteger arg0);
    BigInteger subtract(BigInteger arg0);
    BigInteger multiply(BigInteger arg0);
    BigInteger divide(BigInteger arg0);
    BigInteger[] divideAndRemainder(BigInteger arg0);
    BigInteger remainder(BigInteger arg0);
    BigInteger pow(int arg0);
    BigInteger gcd(BigInteger arg0);
    BigInteger abs();
    BigInteger negate();
    int signum();
    BigInteger mod(BigInteger arg0);
    BigInteger modPow(BigInteger arg0, BigInteger arg1);
    BigInteger modInverse(BigInteger arg0);
    BigInteger shiftLeft(int arg0);
    BigInteger shiftRight(int arg0);
    BigInteger and(BigInteger arg0);
    BigInteger or(BigInteger arg0);
    BigInteger xor(BigInteger arg0);
    BigInteger not();
    BigInteger andNot(BigInteger arg0);
    boolean testBit(int arg0);
    BigInteger setBit(int arg0);
    BigInteger clearBit(int arg0);
    BigInteger flipBit(int arg0);
    int getLowestSetBit();
    int bitLength();
    int bitCount();
    boolean isProbablePrime(int arg0);
    int compareTo(BigInteger arg0);
    boolean equals(Object arg0);
    BigInteger min(BigInteger arg0);
    BigInteger max(BigInteger arg0);
    int hashCode();
    String toString(int arg0);
    String toString();
    byte[] toByteArray();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
}
package java.net;

@PolyFlowReceiver
class InetAddress implements Serializable {
//Added by pbsf
    boolean isMulticastAddress();
    boolean isAnyLocalAddress();
    boolean isLoopbackAddress();
    boolean isLinkLocalAddress();
    boolean isSiteLocalAddress();
    boolean isMCGlobal();
    boolean isMCNodeLocal();
    boolean isMCLinkLocal();
    boolean isMCSiteLocal();
    boolean isMCOrgLocal();
    boolean isReachable(int arg0) throws IOException;
    boolean isReachable(NetworkInterface arg0, int arg1, int arg2) throws IOException;
    String getHostName();
    String getCanonicalHostName();
    byte[] getAddress();
    String getHostAddress();
    int hashCode();
    boolean equals(Object arg0);
    String toString();
    static InetAddress getByAddress(String arg0, byte[] arg1) throws UnknownHostException;
    static InetAddress getByName(String arg0) throws UnknownHostException;
    static InetAddress[] getAllByName(String arg0) throws UnknownHostException;
    static InetAddress getLoopbackAddress();
    static InetAddress getByAddress(byte[] arg0) throws UnknownHostException;
    static InetAddress getLocalHost() throws UnknownHostException;
}

@PolyFlowReceiver
class URL implements Serializable {
//Added by pbsf
    URL(String arg0, String arg1, int arg2, String arg3) throws MalformedURLException;
    URL(String arg0, String arg1, String arg2) throws MalformedURLException;
    URL(String arg0, String arg1, int arg2, String arg3, URLStreamHandler arg4) throws MalformedURLException;
    URL(String arg0) throws MalformedURLException;
    URL(URL arg0, String arg1) throws MalformedURLException;
    URL(URL arg0, String arg1, URLStreamHandler arg2) throws MalformedURLException;
    protected void set(String arg0, String arg1, int arg2, String arg3, String arg4);
    protected void set(String arg0, String arg1, int arg2, String arg3, String arg4, String arg5, String arg6, String arg7);
    String getQuery();
    String getPath();
    String getUserInfo();
    String getAuthority();
    int getPort();
    int getDefaultPort();
    String getProtocol();
    String getHost();
    String getFile();
    String getRef();
    boolean equals(Object arg0);
    int hashCode();
    boolean sameFile(URL arg0);
    String toString();
    String toExternalForm();
    URI toURI() throws URISyntaxException;
    URLConnection openConnection() throws IOException;
    URLConnection openConnection(Proxy arg0) throws IOException;
    InputStream openStream() throws IOException;
    Object getContent() throws IOException;
    Object getContent(Class[] arg0) throws IOException;
    static void setURLStreamHandlerFactory(URLStreamHandlerFactory arg0);
}

class Socket{
//Added by SOM
       @Sink(INTERNET) Socket(@Sink(INTERNET) String host, @Sink(INTERNET) int port)  throws UnknownHostException,IOException;
        void close() throws IOException;
        @Sink(INTERNET) OutputStream getOutputStream() throws IOException;
        @Source(INTERNET) InputStream getInputStream() throws IOException;
         boolean isConnected();
}

@PolyFlowReceiver
class URLConnection {
    protected URL url;
    protected boolean doInput;
    protected boolean doOutput;
    protected boolean allowUserInteraction;
    protected boolean useCaches;
    protected long ifModifiedSince;
    protected boolean connected;
    static FileNameMap getFileNameMap();
    static void setFileNameMap(FileNameMap arg0);
    void connect() throws IOException;
    void setConnectTimeout(int arg0);
    int getConnectTimeout();
    void setReadTimeout(int arg0);
    int getReadTimeout();
    protected URLConnection(URL arg0);
    URL getURL();
    int getContentLength();
    long getContentLengthLong();
    String getContentType();
    String getContentEncoding();
    long getExpiration();
    long getDate();
    long getLastModified();
    String getHeaderField(String arg0);
    Map<String,List<String>> getHeaderFields();
    int getHeaderFieldInt(String arg0, int arg1);
    long getHeaderFieldLong(String arg0, long arg1);
    long getHeaderFieldDate(String arg0, long arg1);
    String getHeaderFieldKey(int arg0);
    String getHeaderField(int arg0);
    Object getContent() throws IOException;
    Object getContent(Class[] arg0) throws IOException;
    Permission getPermission() throws IOException;
    InputStream getInputStream() throws IOException;
    OutputStream getOutputStream() throws IOException;
    String toString();
    void setDoInput(boolean arg0);
    boolean getDoInput();
    void setDoOutput(boolean arg0);
    boolean getDoOutput();
    void setAllowUserInteraction(boolean arg0);
    boolean getAllowUserInteraction();
    static void setDefaultAllowUserInteraction(boolean arg0);
    static boolean getDefaultAllowUserInteraction();
    void setUseCaches(boolean arg0);
    boolean getUseCaches();
    void setIfModifiedSince(long arg0);
    long getIfModifiedSince();
    boolean getDefaultUseCaches();
    void setDefaultUseCaches(boolean arg0);
    void setRequestProperty(String arg0, String arg1);
    void addRequestProperty(String arg0, String arg1);
    String getRequestProperty(String arg0);
    Map<String,List<String>> getRequestProperties();
    static void setDefaultRequestProperty(String arg0, String arg1);
    static String getDefaultRequestProperty(String arg0);
    static void setContentHandlerFactory(ContentHandlerFactory arg0);
    static String guessContentTypeFromName(String arg0);
    static String guessContentTypeFromStream(InputStream arg0) throws IOException;
}

class URLEncoder{
@PolyFlow
            static String encode(String arg0, String arg1) throws UnsupportedEncodingException;
}
class HttpURLConnection {
    @Source(FlowPermission.INTERNET) int getResponseCode() throws IOException;
    void setRequestMethod(@Sink(FlowPermission.INTERNET) String arg0) throws ProtocolException;

}


package java.nio;

class Buffer{
   int remaining();
   @PolyFlowReceiver
   Buffer flip();
}

@PolyFlowReceiver
class ByteBuffer extends Buffer implements Comparable<ByteBuffer> {
    static ByteBuffer allocateDirect(int arg0);
    static ByteBuffer allocate(int arg0);
    static ByteBuffer wrap(byte[] arg0, int arg1, int arg2);
    static ByteBuffer wrap(byte[] arg0);
    ByteBuffer slice();
    ByteBuffer duplicate();
    ByteBuffer asReadOnlyBuffer();
    byte get();
    ByteBuffer put(byte arg0);
    byte get(int arg0);
    ByteBuffer put(int arg0, byte arg1);
    ByteBuffer get(byte[] arg0, int arg1, int arg2);
    ByteBuffer get(byte[] arg0);
    ByteBuffer put(ByteBuffer arg0);
    ByteBuffer put(byte[] arg0, int arg1, int arg2);
    ByteBuffer put(byte[] arg0);
    boolean hasArray();
    byte[] array();
    int arrayOffset();
    ByteBuffer compact();
    boolean isDirect();
    String toString();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(ByteBuffer arg0);
    ByteOrder order();
    ByteBuffer order(ByteOrder arg0);
    char getChar();
    ByteBuffer putChar(char arg0);
    char getChar(int arg0);
    ByteBuffer putChar(int arg0, char arg1);
    CharBuffer asCharBuffer();
    short getShort();
    ByteBuffer putShort(short arg0);
    short getShort(int arg0);
    ByteBuffer putShort(int arg0, short arg1);
    ShortBuffer asShortBuffer();
    int getInt();
    ByteBuffer putInt(int arg0);
    int getInt(int arg0);
    ByteBuffer putInt(int arg0, int arg1);
    IntBuffer asIntBuffer();
    long getLong();
    ByteBuffer putLong(long arg0);
    long getLong(int arg0);
    ByteBuffer putLong(int arg0, long arg1);
    LongBuffer asLongBuffer();
    float getFloat();
    ByteBuffer putFloat(float arg0);
    float getFloat(int arg0);
    ByteBuffer putFloat(int arg0, float arg1);
    FloatBuffer asFloatBuffer();
    double getDouble();
    ByteBuffer putDouble(double arg0);
    double getDouble(int arg0);
    ByteBuffer putDouble(int arg0, double arg1);
    DoubleBuffer asDoubleBuffer();
}

@PolyFlowReceiver
class CharBuffer extends Buffer implements Comparable<CharBuffer>, Appendable, CharSequence, Readable {
    static CharBuffer allocate(int arg0);
    static CharBuffer wrap(char[] arg0, int arg1, int arg2);
    static CharBuffer wrap(char[] arg0);
    int read(CharBuffer arg0) throws IOException;
    static CharBuffer wrap(CharSequence arg0, int arg1, int arg2);
    static CharBuffer wrap(CharSequence arg0);
    CharBuffer slice();
    CharBuffer duplicate();
    CharBuffer asReadOnlyBuffer();
    char get();
    CharBuffer put(char arg0);
    char get(int arg0);
    CharBuffer put(int arg0, char arg1);
    CharBuffer get(char[] arg0, int arg1, int arg2);
    CharBuffer get(char[] arg0);
    CharBuffer put(CharBuffer arg0);
    CharBuffer put(char[] arg0, int arg1, int arg2);
    CharBuffer put(char[] arg0);
    CharBuffer put(String arg0, int arg1, int arg2);
    CharBuffer put(String arg0);
    boolean hasArray();
    char[] array();
    int arrayOffset();
    CharBuffer compact();
    boolean isDirect();
    int hashCode();
    boolean equals(Object arg0);
    int compareTo(CharBuffer arg0);
    String toString();
    int length();
    char charAt(int arg0);
    CharBuffer subSequence(int arg0, int arg1);
    CharBuffer append(CharSequence arg0);
    CharBuffer append(CharSequence arg0, int arg1, int arg2);
    CharBuffer append(char arg0);
    ByteOrder order();
}

package java.nio.charset;

@PolyFlowReceiver
class Charset implements Comparable<Charset> {
    static boolean isSupported(String arg0);
    static Charset forName(String arg0);
    static SortedMap<String,Charset> availableCharsets();
    static Charset defaultCharset();
    protected Charset(String arg0, String[] arg1);
    String name();
    Set<String> aliases();
    String displayName();
    boolean isRegistered();
    String displayName(Locale arg0);
    boolean contains(Charset arg0);
    CharsetDecoder newDecoder();
    CharsetEncoder newEncoder();
    boolean canEncode();
    CharBuffer decode(ByteBuffer arg0);
    ByteBuffer encode(CharBuffer arg0);
    ByteBuffer encode(String arg0);
    int compareTo(Charset arg0);
    int hashCode();
    boolean equals(Object arg0);
    String toString();
}

package java.security;
class MessageDigest{
            static MessageDigest getInstance(String arg0) throws NoSuchAlgorithmException;

           @Source(SECURE_HASH) byte @Source(SECURE_HASH) [] digest(@Sink(SECURE_HASH) byte @Sink(SECURE_HASH) [] arg0);
            void update(@Sink(SECURE_HASH) byte @Sink(SECURE_HASH) [] arg0, int arg1, int arg2);
           @Source(SECURE_HASH) byte @Source(SECURE_HASH) [] digest();
}
class SecureRandom{
            SecureRandom();
            void nextBytes(@Source(RANDOM) byte @Source(RANDOM)[] arg0);
}
class Timestamp{
        Timestamp(long arg0);
}package java.text;

@PolyFlowReceiver
class DateFormat extends Format {
    protected Calendar calendar;
    protected NumberFormat numberFormat;
    final int ERA_FIELD;
    final int YEAR_FIELD;
    final int MONTH_FIELD;
    final int DATE_FIELD;
    final int HOUR_OF_DAY1_FIELD;
    final int HOUR_OF_DAY0_FIELD;
    final int MINUTE_FIELD;
    final int SECOND_FIELD;
    final int MILLISECOND_FIELD;
    final int DAY_OF_WEEK_FIELD;
    final int DAY_OF_YEAR_FIELD;
    final int DAY_OF_WEEK_IN_MONTH_FIELD;
    final int WEEK_OF_YEAR_FIELD;
    final int WEEK_OF_MONTH_FIELD;
    final int AM_PM_FIELD;
    final int HOUR1_FIELD;
    final int HOUR0_FIELD;
    final int TIMEZONE_FIELD;
    final int FULL;
    final int LONG;
    final int MEDIUM;
    final int SHORT;
    final int DEFAULT;
    StringBuffer format(Object arg0, StringBuffer arg1, FieldPosition arg2);
    StringBuffer format(Date arg0, StringBuffer arg1, FieldPosition arg2);
    String format(Date arg0);
    Date parse(String arg0) throws ParseException;
    Date parse(String arg0, ParsePosition arg1);
    Object parseObject(String arg0, ParsePosition arg1);
    static DateFormat getTimeInstance();
    static DateFormat getTimeInstance(int arg0);
    static DateFormat getTimeInstance(int arg0, Locale arg1);
    static DateFormat getDateInstance();
    static DateFormat getDateInstance(int arg0);
    static DateFormat getDateInstance(int arg0, Locale arg1);
    static DateFormat getDateTimeInstance();
    static DateFormat getDateTimeInstance(int arg0, int arg1);
    static DateFormat getDateTimeInstance(int arg0, int arg1, Locale arg2);
    static DateFormat getInstance();
    static Locale[] getAvailableLocales();
    void setCalendar(Calendar arg0);
    Calendar getCalendar();
    void setNumberFormat(NumberFormat arg0);
    NumberFormat getNumberFormat();
    void setTimeZone(TimeZone arg0);
    TimeZone getTimeZone();
    void setLenient(boolean arg0);
    boolean isLenient();
    int hashCode();
    boolean equals(Object arg0);
    Object clone();
    protected DateFormat();
}

@PolyFlowReceiver
class DateFormat$Field extends Field {
    final Field ERA;
    final Field YEAR;
    final Field MONTH;
    final Field DAY_OF_MONTH;
    final Field HOUR_OF_DAY1;
    final Field HOUR_OF_DAY0;
    final Field MINUTE;
    final Field SECOND;
    final Field MILLISECOND;
    final Field DAY_OF_WEEK;
    final Field DAY_OF_YEAR;
    final Field DAY_OF_WEEK_IN_MONTH;
    final Field WEEK_OF_YEAR;
    final Field WEEK_OF_MONTH;
    final Field AM_PM;
    final Field HOUR1;
    final Field HOUR0;
    final Field TIME_ZONE;
    static Field ofCalendarField(int arg0);
    protected Field(String arg0, int arg1);
    int getCalendarField();
    protected Object readResolve() throws InvalidObjectException;
}


@PolyFlowReceiver
class DecimalFormat extends NumberFormat {
//Added by pbsf
    DecimalFormat();
    DecimalFormat(String arg0);
    DecimalFormat(String arg0, DecimalFormatSymbols arg1);
    StringBuffer format(Object arg0, StringBuffer arg1, FieldPosition arg2);
    StringBuffer format(double arg0, StringBuffer arg1, FieldPosition arg2);
    StringBuffer format(long arg0, StringBuffer arg1, FieldPosition arg2);
    AttributedCharacterIterator formatToCharacterIterator(Object arg0);
    Number parse(String arg0, ParsePosition arg1);
    DecimalFormatSymbols getDecimalFormatSymbols();
    void setDecimalFormatSymbols(DecimalFormatSymbols arg0);
    String getPositivePrefix();
    void setPositivePrefix(String arg0);
    String getNegativePrefix();
    void setNegativePrefix(String arg0);
    String getPositiveSuffix();
    void setPositiveSuffix(String arg0);
    String getNegativeSuffix();
    void setNegativeSuffix(String arg0);
    int getMultiplier();
    void setMultiplier(int arg0);
    int getGroupingSize();
    void setGroupingSize(int arg0);
    boolean isDecimalSeparatorAlwaysShown();
    void setDecimalSeparatorAlwaysShown(boolean arg0);
    boolean isParseBigDecimal();
    void setParseBigDecimal(boolean arg0);
    Object clone();
    boolean equals(Object arg0);
    int hashCode();
    String toPattern();
    String toLocalizedPattern();
    void applyPattern(String arg0);
    void applyLocalizedPattern(String arg0);
    void setMaximumIntegerDigits(int arg0);
    void setMinimumIntegerDigits(int arg0);
    void setMaximumFractionDigits(int arg0);
    void setMinimumFractionDigits(int arg0);
    int getMaximumIntegerDigits();
    int getMinimumIntegerDigits();
    int getMaximumFractionDigits();
    int getMinimumFractionDigits();
    Currency getCurrency();
    void setCurrency(Currency arg0);
    RoundingMode getRoundingMode();
    void setRoundingMode(RoundingMode arg0);
}

@PolyFlowReceiver
class SimpleDateFormat extends DateFormat {
    SimpleDateFormat();
    SimpleDateFormat(String arg0);
    SimpleDateFormat(String arg0, Locale arg1);
    SimpleDateFormat(String arg0, DateFormatSymbols arg1);
    void set2DigitYearStart(Date arg0);
    Date get2DigitYearStart();
    StringBuffer format(Date arg0, StringBuffer arg1, FieldPosition arg2);
    AttributedCharacterIterator formatToCharacterIterator(Object arg0);
    Date parse(String arg0, ParsePosition arg1);
    String toPattern();
    String toLocalizedPattern();
    void applyPattern(String arg0);
    void applyLocalizedPattern(String arg0);
    DateFormatSymbols getDateFormatSymbols();
    void setDateFormatSymbols(DateFormatSymbols arg0);
    Object clone();
    int hashCode();
    boolean equals(Object arg0);
}

@PolyFlowReceiver
class Format {
    String format(Object arg0);
}

package java.util;

@PolyFlowReceiver
class AbstractCollection<E> implements Collection<E> {
    protected AbstractCollection();
    Iterator<E> iterator();
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    void clear();
    String toString();
}

@PolyFlowReceiver
class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    protected int modCount;
    protected AbstractList();
    boolean add(E arg0);
    E get(int arg0);
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    E remove(int arg0);
    int indexOf(Object arg0);
    int lastIndexOf(Object arg0);
    void clear();
    boolean addAll(int arg0, Collection<? extends E> arg1);
    Iterator<E> iterator();
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int arg0);
    List<E> subList(int arg0, int arg1);
    boolean equals(Object arg0);
    int hashCode();
    protected void removeRange(int arg0, int arg1);
}
@PolyFlowReceiver
class AbstractMap{
            V remove(Object arg0);
            V put(K arg0, V arg1);
            protected AbstractMap();
            Set<Entry<K,V>> entrySet();
            V get(Object arg0);
            void clear();
            boolean containsKey(Object arg0);
            int size();
             String toString();
}

class AbstractSet{
            protected AbstractSet();
}
 
@PolyFlowReceiver
class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable {
//Added by pbsf
    ArrayDeque();
    ArrayDeque(int arg0);
    ArrayDeque(Collection<? extends E> arg0);
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E getFirst();
    E getLast();
    E peekFirst();
    E peekLast();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
    void push(E arg0);
    E pop();
    int size();
    boolean isEmpty();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    void clear();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    ArrayDeque<E> clone();
} 
 
class ArrayList<E> { 
//Added by smillst
    ArrayList(int arg0);
    ArrayList();
    @PolyFlow
    ArrayList(Collection<? extends E> arg0);
 
    void trimToSize();
    void ensureCapacity(int arg0);
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean contains(Object arg0);
    @PolyFlowReceiver
    int indexOf(Object arg0);
    @PolyFlowReceiver
    int lastIndexOf(Object arg0);
    @PolyFlowReceiver
    Object clone();
    @PolyFlowReceiver
    Object[] toArray();
    @PolyFlowReceiver
    <T> T[] toArray(T[] arg0);
    E get(int arg0) ;
    @PolyFlowReceiver
    E set(int arg0, E arg1);
    @PolyFlowReceiver
    boolean add(E arg0);
    @PolyFlowReceiver
    void add(int arg0, E arg1);
    @PolyFlowReceiver
    E remove(int arg0);
    @PolyFlowReceiver
    boolean remove(Object arg0);
    void clear();
    @PolyFlowReceiver
    boolean addAll(Collection<? extends E> arg0);
    @PolyFlowReceiver
    boolean addAll(int arg0, Collection<? extends E> arg1);
    @PolyFlowReceiver
    protected void removeRange(int arg0, int arg1);
    @PolyFlowReceiver
    boolean removeAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean retainAll(Collection<?> arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator(int arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator();
    @PolyFlowReceiver
    Iterator<E> iterator();
    @PolyFlowReceiver
    List<E> subList(int arg0, int arg1);
}

@PolyFlow
class Arrays {
    static void sort(int[] arg0);
    static void sort(int[] arg0, int arg1, int arg2);
    static void sort(long[] arg0);
    static void sort(long[] arg0, int arg1, int arg2);
    static void sort(short[] arg0);
    static void sort(short[] arg0, int arg1, int arg2);
    static void sort(char[] arg0);
    static void sort(char[] arg0, int arg1, int arg2);
    static void sort(byte[] arg0);
    static void sort(byte[] arg0, int arg1, int arg2);
    static void sort(float[] arg0);
    static void sort(float[] arg0, int arg1, int arg2);
    static void sort(double[] arg0);
    static void sort(double[] arg0, int arg1, int arg2);
    static void sort(Object[] arg0);
    static void sort(Object[] arg0, int arg1, int arg2);
    static <T> void sort(T[] arg0, Comparator<? super T> arg1);
    static <T> void sort(T[] arg0, int arg1, int arg2, Comparator<? super T> arg3);
    static int binarySearch(long[] arg0, long arg1);
    static int binarySearch(long[] arg0, int arg1, int arg2, long arg3);
    static int binarySearch(int[] arg0, int arg1);
    static int binarySearch(int[] arg0, int arg1, int arg2, int arg3);
    static int binarySearch(short[] arg0, short arg1);
    static int binarySearch(short[] arg0, int arg1, int arg2, short arg3);
    static int binarySearch(char[] arg0, char arg1);
    static int binarySearch(char[] arg0, int arg1, int arg2, char arg3);
    static int binarySearch(byte[] arg0, byte arg1);
    static int binarySearch(byte[] arg0, int arg1, int arg2, byte arg3);
    static int binarySearch(double[] arg0, double arg1);
    static int binarySearch(double[] arg0, int arg1, int arg2, double arg3);
    static int binarySearch(float[] arg0, float arg1);
    static int binarySearch(float[] arg0, int arg1, int arg2, float arg3);
    static int binarySearch(Object[] arg0, Object arg1);
    static int binarySearch(Object[] arg0, int arg1, int arg2, Object arg3);
    static <T> int binarySearch(T[] arg0, T arg1, Comparator<? super T> arg2);
    static <T> int binarySearch(T[] arg0, int arg1, int arg2, T arg3, Comparator<? super T> arg4);
    static boolean equals(long[] arg0, long[] arg1);
    static boolean equals(int[] arg0, int[] arg1);
    static boolean equals(short[] arg0, short[] arg1);
    static boolean equals(char[] arg0, char[] arg1);
    static boolean equals(byte[] arg0, byte[] arg1);
    static boolean equals(boolean[] arg0, boolean[] arg1);
    static boolean equals(double[] arg0, double[] arg1);
    static boolean equals(float[] arg0, float[] arg1);
    static boolean equals(Object[] arg0, Object[] arg1);
    static void fill(long[] arg0, long arg1);
    static void fill(long[] arg0, int arg1, int arg2, long arg3);
    static void fill(int[] arg0, int arg1);
    static void fill(int[] arg0, int arg1, int arg2, int arg3);
    static void fill(short[] arg0, short arg1);
    static void fill(short[] arg0, int arg1, int arg2, short arg3);
    static void fill(char[] arg0, char arg1);
    static void fill(char[] arg0, int arg1, int arg2, char arg3);
    static void fill(byte[] arg0, byte arg1);
    static void fill(byte[] arg0, int arg1, int arg2, byte arg3);
    static void fill(boolean[] arg0, boolean arg1);
    static void fill(boolean[] arg0, int arg1, int arg2, boolean arg3);
    static void fill(double[] arg0, double arg1);
    static void fill(double[] arg0, int arg1, int arg2, double arg3);
    static void fill(float[] arg0, float arg1);
    static void fill(float[] arg0, int arg1, int arg2, float arg3);
    static void fill(Object[] arg0, Object arg1);
    static void fill(Object[] arg0, int arg1, int arg2, Object arg3);
    static <T> T[] copyOf(T[] arg0, int arg1);
    static <T, U> T[] copyOf(U[] arg0, int arg1, Class<? extends T[]> arg2);
    static byte[] copyOf(byte[] arg0, int arg1);
    static short[] copyOf(short[] arg0, int arg1);
    static int[] copyOf(int[] arg0, int arg1);
    static long[] copyOf(long[] arg0, int arg1);
    static char[] copyOf(char[] arg0, int arg1);
    static float[] copyOf(float[] arg0, int arg1);
    static double[] copyOf(double[] arg0, int arg1);
    static boolean[] copyOf(boolean[] arg0, int arg1);
    static <T> T[] copyOfRange(T[] arg0, int arg1, int arg2);
    static <T, U> T[] copyOfRange(U[] arg0, int arg1, int arg2, Class<? extends T[]> arg3);
    static byte[] copyOfRange(byte[] arg0, int arg1, int arg2);
    static short[] copyOfRange(short[] arg0, int arg1, int arg2);
    static int[] copyOfRange(int[] arg0, int arg1, int arg2);
    static long[] copyOfRange(long[] arg0, int arg1, int arg2);
    static char[] copyOfRange(char[] arg0, int arg1, int arg2);
    static float[] copyOfRange(float[] arg0, int arg1, int arg2);
    static double[] copyOfRange(double[] arg0, int arg1, int arg2);
    static boolean[] copyOfRange(boolean[] arg0, int arg1, int arg2);
    static <T> List<T> asList(T[] arg0);
    static int hashCode(long[] arg0);
    static int hashCode(int[] arg0);
    static int hashCode(short[] arg0);
    static int hashCode(char[] arg0);
    static int hashCode(byte[] arg0);
    static int hashCode(boolean[] arg0);
    static int hashCode(float[] arg0);
    static int hashCode(double[] arg0);
    static int hashCode(Object[] arg0);
    static int deepHashCode(Object[] arg0);
    static boolean deepEquals(Object[] arg0, Object[] arg1);
    static String toString(long[] arg0);
    static String toString(int[] arg0);
    static String toString(short[] arg0);
    static String toString(char[] arg0);
    static String toString(byte[] arg0);
    static String toString(boolean[] arg0);
    static String toString(float[] arg0);
    static String toString(double[] arg0);
    static String toString(Object[] arg0);
    static String deepToString(Object[] arg0);
}

@PolyFlowReceiver
class BitSet implements Cloneable, Serializable {
    BitSet();
    BitSet(int arg0);
    static BitSet valueOf(long[] arg0);
    static BitSet valueOf(LongBuffer arg0);
    static BitSet valueOf(byte[] arg0);
    static BitSet valueOf(ByteBuffer arg0);
    byte[] toByteArray();
    long[] toLongArray();
    void flip(int arg0);
    void flip(int arg0, int arg1);
    void set(int arg0);
    void set(int arg0, boolean arg1);
    void set(int arg0, int arg1);
    void set(int arg0, int arg1, boolean arg2);
    void clear(int arg0);
    void clear(int arg0, int arg1);
    void clear();
    boolean get(int arg0);
    BitSet get(int arg0, int arg1);
    int nextSetBit(int arg0);
    int nextClearBit(int arg0);
    int previousSetBit(int arg0);
    int previousClearBit(int arg0);
    int length();
    boolean isEmpty();
    boolean intersects(BitSet arg0);
    int cardinality();
    void and(BitSet arg0);
    void or(BitSet arg0);
    void xor(BitSet arg0);
    void andNot(BitSet arg0);
    int hashCode();
    int size();
    boolean equals(Object arg0);
    Object clone();
    String toString();
}

@PolyFlowReceiver
class Calendar implements Serializable, Cloneable, Comparable<Calendar> {
//Added by pbsf
    final @Source(FlowPermission.LITERAL) int ERA;
    final @Source(FlowPermission.LITERAL) int YEAR;
    final @Source(FlowPermission.LITERAL) int MONTH;
    final @Source(FlowPermission.LITERAL) int WEEK_OF_YEAR;
    final @Source(FlowPermission.LITERAL) int WEEK_OF_MONTH;
    final @Source(FlowPermission.LITERAL) int DATE;
    final @Source(FlowPermission.LITERAL) int DAY_OF_MONTH;
    final @Source(FlowPermission.LITERAL) int DAY_OF_YEAR;
    final @Source(FlowPermission.LITERAL) int DAY_OF_WEEK;
    final @Source(FlowPermission.LITERAL) int DAY_OF_WEEK_IN_MONTH;
    final @Source(FlowPermission.LITERAL) int AM_PM;
    final @Source(FlowPermission.LITERAL) int HOUR;
    final @Source(FlowPermission.LITERAL) int HOUR_OF_DAY;
    final @Source(FlowPermission.LITERAL) int MINUTE;
    final @Source(FlowPermission.LITERAL) int SECOND;
    final @Source(FlowPermission.LITERAL) int MILLISECOND;
    final @Source(FlowPermission.LITERAL) int ZONE_OFFSET;
    final @Source(FlowPermission.LITERAL) int DST_OFFSET;
    final @Source(FlowPermission.LITERAL) int FIELD_COUNT;
    final @Source(FlowPermission.LITERAL) int SUNDAY;
    final @Source(FlowPermission.LITERAL) int MONDAY;
    final @Source(FlowPermission.LITERAL) int TUESDAY;
    final @Source(FlowPermission.LITERAL) int WEDNESDAY;
    final @Source(FlowPermission.LITERAL) int THURSDAY;
    final @Source(FlowPermission.LITERAL) int FRIDAY;
    final @Source(FlowPermission.LITERAL) int SATURDAY;
    final @Source(FlowPermission.LITERAL) int JANUARY;
    final @Source(FlowPermission.LITERAL) int FEBRUARY;
    final @Source(FlowPermission.LITERAL) int MARCH;
    final @Source(FlowPermission.LITERAL) int APRIL;
    final @Source(FlowPermission.LITERAL) int MAY;
    final @Source(FlowPermission.LITERAL) int JUNE;
    final @Source(FlowPermission.LITERAL) int JULY;
    final @Source(FlowPermission.LITERAL) int AUGUST;
    final @Source(FlowPermission.LITERAL) int SEPTEMBER;
    final @Source(FlowPermission.LITERAL) int OCTOBER;
    final @Source(FlowPermission.LITERAL) int NOVEMBER;
    final @Source(FlowPermission.LITERAL) int DECEMBER;
    final @Source(FlowPermission.LITERAL) int UNDECIMBER;
    final @Source(FlowPermission.LITERAL) int AM;
    final @Source(FlowPermission.LITERAL) int PM;
    final @Source(FlowPermission.LITERAL) int ALL_STYLES;
    final @Source(FlowPermission.LITERAL) int SHORT;
    final @Source(FlowPermission.LITERAL) int LONG;
    protected int[] fields;
    protected boolean[] isSet;
    protected long time;
    protected boolean isTimeSet;
    protected boolean areFieldsSet;
    protected Calendar();
    protected Calendar(TimeZone arg0, Locale arg1);
    static Calendar getInstance();
    static Calendar getInstance(TimeZone arg0);
    static Calendar getInstance(Locale arg0);
    static Calendar getInstance(TimeZone arg0, Locale arg1);
    static Locale[] getAvailableLocales();
    protected void computeTime();
    protected void computeFields();
    Date getTime();
    void setTime(Date arg0);
    long getTimeInMillis();
    void setTimeInMillis(long arg0);
    int get(int arg0);
    protected int internalGet(int arg0);
    void set(int arg0, int arg1);
    void set(int arg0, int arg1, int arg2);
    void set(int arg0, int arg1, int arg2, int arg3, int arg4);
    void set(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    void clear();
    void clear(int arg0);
    boolean isSet(int arg0);
    String getDisplayName(int arg0, int arg1, Locale arg2);
    Map<String,Integer> getDisplayNames(int arg0, int arg1, Locale arg2);
    protected void complete();
    boolean equals(Object arg0);
    int hashCode();
    boolean before(Object arg0);
    boolean after(Object arg0);
    int compareTo(Calendar arg0);
    void add(int arg0, int arg1);
    void roll(int arg0, boolean arg1);
    void roll(int arg0, int arg1);
    void setTimeZone(TimeZone arg0);
    TimeZone getTimeZone();
    void setLenient(boolean arg0);
    boolean isLenient();
    void setFirstDayOfWeek(int arg0);
    int getFirstDayOfWeek();
    void setMinimalDaysInFirstWeek(int arg0);
    int getMinimalDaysInFirstWeek();
    boolean isWeekDateSupported();
    int getWeekYear();
    void setWeekDate(int arg0, int arg1, int arg2);
    int getWeeksInWeekYear();
    int getMinimum(int arg0);
    int getMaximum(int arg0);
    int getGreatestMinimum(int arg0);
    int getLeastMaximum(int arg0);
    int getActualMinimum(int arg0);
    int getActualMaximum(int arg0);
    Object clone();
    String toString();
}
       
@PolyFlowReceiver
interface Collection<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    void clear();
    boolean equals(Object arg0);
    int hashCode();
}

@PolyFlowReceiver
class Collections {
//Added by pbsf
    final Set EMPTY_SET;
    final List EMPTY_LIST;
    final Map EMPTY_MAP;
    static <T> void sort(List<T> arg0);
    static <T> void sort(List<T> arg0, Comparator<? super T> arg1);
    static <T> int binarySearch(List<? extends Comparable<? super T>> arg0, T arg1);
    static <T> int binarySearch(List<? extends T> arg0, T arg1, Comparator<? super T> arg2);
    static void reverse(List<?> arg0);
    static void shuffle(List<?> arg0);
    static void shuffle(List<?> arg0, Random arg1);
    static void swap(List<?> arg0, int arg1, int arg2);
    static <T> void fill(List<? super T> arg0, T arg1);
    static <T> void copy(List<? super T> arg0, List<? extends T> arg1);
    static <T> T min(Collection<? extends T> arg0);
    static <T> T min(Collection<? extends T> arg0, Comparator<? super T> arg1);
    static <T> T max(Collection<? extends T> arg0);
    static <T> T max(Collection<? extends T> arg0, Comparator<? super T> arg1);
    static void rotate(List<?> arg0, int arg1);
    static <T> boolean replaceAll(List<T> arg0, T arg1, T arg2);
    static int indexOfSubList(List<?> arg0, List<?> arg1);
    static int lastIndexOfSubList(List<?> arg0, List<?> arg1);
    static <T> Collection<T> unmodifiableCollection(Collection<? extends T> arg0);
    static <T> Set<T> unmodifiableSet(Set<? extends T> arg0);
    static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> arg0);
    static <T> List<T> unmodifiableList(List<? extends T> arg0);
    static <K, V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> arg0);
    static <K, V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K,? extends V> arg0);
    static <T> Collection<T> synchronizedCollection(Collection<T> arg0);
    static <T> Set<T> synchronizedSet(Set<T> arg0);
    static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> arg0);
    static <T> List<T> synchronizedList(List<T> arg0);
    static <K, V> Map<K,V> synchronizedMap(Map<K,V> arg0);
    static <K, V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> arg0);
    static <E> Collection<E> checkedCollection(Collection<E> arg0, Class<E> arg1);
    static <E> Set<E> checkedSet(Set<E> arg0, Class<E> arg1);
    static <E> SortedSet<E> checkedSortedSet(SortedSet<E> arg0, Class<E> arg1);
    static <E> List<E> checkedList(List<E> arg0, Class<E> arg1);
    static <K, V> Map<K,V> checkedMap(Map<K,V> arg0, Class<K> arg1, Class<V> arg2);
    static <K, V> SortedMap<K,V> checkedSortedMap(SortedMap<K,V> arg0, Class<K> arg1, Class<V> arg2);
    static <T> Iterator<T> emptyIterator();
    static <T> ListIterator<T> emptyListIterator();
    static <T> Enumeration<T> emptyEnumeration();
    static <T> Set<T> emptySet();
    static <T> List<T> emptyList();
    static <K, V> Map<K,V> emptyMap();
    static <T> Set<T> singleton(T arg0);
    static <T> List<T> singletonList(T arg0);
    static <K, V> Map<K,V> singletonMap(K arg0, V arg1);
    static <T> List<T> nCopies(int arg0, T arg1);
    static <T> Comparator<T> reverseOrder();
    static <T> Comparator<T> reverseOrder(Comparator<T> arg0);
    static <T> Enumeration<T> enumeration(Collection<T> arg0);
    static <T> ArrayList<T> list(Enumeration<T> arg0);
    static int frequency(Collection<?> arg0, Object arg1);
    static boolean disjoint(Collection<?> arg0, Collection<?> arg1);
    static <T> boolean addAll(Collection<? super T> arg0, T[] arg1);
    static <E> Set<E> newSetFromMap(Map<E,Boolean> arg0);
    static <T> Queue<T> asLifoQueue(Deque<T> arg0);
}

@PolyFlowReceiver
interface Comparator<T> {
    int compare(T arg0, T arg1);
    boolean equals(Object arg0);
}

@PolyFlowReceiver       
class Date implements Serializable, Cloneable, Comparable<Date> {
    Date();
    Date(long arg0);
    Date(int arg0, int arg1, int arg2);
    Date(int arg0, int arg1, int arg2, int arg3, int arg4);
    Date(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    Date(String arg0);
    Object clone();
    static long UTC(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    static long parse(String arg0);
    int getYear();
    void setYear(int arg0);
    int getMonth();
    void setMonth(int arg0);
    int getDate();
    void setDate(int arg0);
    int getDay();
    int getHours();
    void setHours(int arg0);
    int getMinutes();
    void setMinutes(int arg0);
    int getSeconds();
    void setSeconds(int arg0);
    long getTime();
    void setTime(long arg0);
    boolean before(Date arg0);
    boolean after(Date arg0);
    boolean equals(Object arg0);
    int compareTo(Date arg0);
    int hashCode();
    String toString();
    String toLocaleString();
    String toGMTString();
    int getTimezoneOffset();
}

@PolyFlowReceiver
interface Deque<E> extends Queue<E> {
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E getFirst();
    E getLast();
    E peekFirst();
    E peekLast();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
    void push(E arg0);
    E pop();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int size();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
}

@PolyFlowReceiver
interface Enumeration<E> {
    boolean hasMoreElements();
    E nextElement();
}


@PolyFlowReceiver
class EnumMap<K, V> extends AbstractMap<K,V> implements Serializable, Cloneable {
    EnumMap(Class<K> arg0);
    EnumMap(EnumMap<K,? extends V> arg0);
    EnumMap(Map<K,? extends V> arg0);
    int size();
    boolean containsValue(Object arg0);
    boolean containsKey(Object arg0);
    V get(Object arg0);
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    boolean equals(Object arg0);
    int hashCode();
    EnumMap<K,V> clone();
}

@PolyFlowReceiver
class EnumSet<E> extends AbstractSet<E> implements Cloneable, Serializable {
    static <E> EnumSet<E> noneOf(Class<E> arg0);
    static <E> EnumSet<E> allOf(Class<E> arg0);
    static <E> EnumSet<E> copyOf(EnumSet<E> arg0);
    static <E> EnumSet<E> copyOf(Collection<E> arg0);
    static <E> EnumSet<E> complementOf(EnumSet<E> arg0);
    static <E> EnumSet<E> of(E arg0);
    static <E> EnumSet<E> of(E arg0, E arg1);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2, E arg3);
    static <E> EnumSet<E> of(E arg0, E arg1, E arg2, E arg3, E arg4);
    static <E> EnumSet<E> of(E arg0, E[] arg1);
    static <E> EnumSet<E> range(E arg0, E arg1);
    EnumSet<E> clone();
}

@PolyFlowReceiver
class GregorianCalendar extends Calendar {
    final int BC;
    final int AD;
    GregorianCalendar();
    GregorianCalendar(TimeZone arg0);
    GregorianCalendar(Locale arg0);
    GregorianCalendar(TimeZone arg0, Locale arg1);
    GregorianCalendar(int arg0, int arg1, int arg2);
    GregorianCalendar(int arg0, int arg1, int arg2, int arg3, int arg4);
    GregorianCalendar(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    void setGregorianChange(Date arg0);
    Date getGregorianChange();
    boolean isLeapYear(int arg0);
    boolean equals(Object arg0);
    int hashCode();
    void add(int arg0, int arg1);
    void roll(int arg0, boolean arg1);
    void roll(int arg0, int arg1);
    int getMinimum(int arg0);
    int getMaximum(int arg0);
    int getGreatestMinimum(int arg0);
    int getLeastMaximum(int arg0);
    int getActualMinimum(int arg0);
    int getActualMaximum(int arg0);
    Object clone();
    TimeZone getTimeZone();
    void setTimeZone(TimeZone arg0);
    boolean isWeekDateSupported();
    int getWeekYear();
    void setWeekDate(int arg0, int arg1, int arg2);
    int getWeeksInWeekYear();
    protected void computeFields();
    protected void computeTime();
}
       
@PolyFlowReceiver  
class HashMap<K, V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
    HashMap(int arg0, float arg1);
    HashMap(int arg0);
    HashMap();
    HashMap(Map<? extends K,? extends V> arg0);
    int size() ;
    boolean isEmpty();
    V get(Object arg0);
    boolean containsKey(Object arg0);
    V put(K arg0, V arg1);
    void putAll(Map<? extends K,? extends V> arg0);
    V remove(Object arg0);
    void clear();
    boolean containsValue(Object arg0);
    Object clone();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
}

@PolyFlowReceiver
class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable {
    HashSet();
    HashSet(Collection<? extends E> arg0);
    HashSet(int arg0, float arg1);
    HashSet(int arg0);
    Iterator<E> iterator();
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    void clear();
    Object clone();
}

@PolyFlowReceiver
class Hashtable<K, V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, Serializable {
    Hashtable(int arg0, float arg1);
    Hashtable(int arg0);
    Hashtable();
    Hashtable(Map<? extends K,? extends V> arg0);
    int size();
    boolean isEmpty();
    Enumeration<K> keys();
    Enumeration<V> elements();
    boolean contains(Object arg0);
    boolean containsValue(Object arg0);
    boolean containsKey(Object arg0);
    V get(Object arg0);
    protected void rehash();
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    Object clone();
    String toString();
    Set<K> keySet();
    Set<Entry<K,V>> entrySet();
    Collection<V> values();
    boolean equals(Object arg0);
    int hashCode();
}


interface Iterator<E> {
//Added by smillst
    boolean hasNext();
    @PolyFlowReceiver
    E next();
    void remove();
}

@PolyFlowReceiver  
class LinkedHashMap<K, V> extends HashMap<K,V> implements Map<K,V> {
//Added by pbsf
    LinkedHashMap(int arg0, float arg1);
    LinkedHashMap(int arg0);
    LinkedHashMap();
    LinkedHashMap(Map<? extends K,? extends V> arg0);
    LinkedHashMap(int arg0, float arg1, boolean arg2);
    boolean containsValue(Object arg0);
    V get(Object arg0);
    void clear();
    protected boolean removeEldestEntry(Entry<K,V> arg0);
}

@PolyFlowReceiver
class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, Serializable {
    LinkedHashSet(int arg0, float arg1);
    LinkedHashSet(int arg0);
    LinkedHashSet();
    LinkedHashSet(Collection<? extends E> arg0);
}

@PolyFlowReceiver
class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable {
    LinkedList();
    LinkedList(Collection<? extends E> arg0);
    E getFirst();
    E getLast();
    E removeFirst();
    E removeLast();
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean contains(Object arg0);
    int size();
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean addAll(int arg0, Collection<? extends E> arg1);
    void clear();
    E get(int arg0);
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    E remove(int arg0);
    int indexOf(Object arg0);
    int lastIndexOf(Object arg0);
    E peek();
    E element();
    E poll();
    E remove();
    boolean offer(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E peekFirst();
    E peekLast();
    E pollFirst();
    E pollLast();
    void push(E arg0);
    E pop();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    ListIterator<E> listIterator(int arg0);
    Iterator<E> descendingIterator();
    Object clone();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
}

interface List<E extends @Sink({}) @Source(FlowPermission.ANY) Object> {
    @PolyFlowReceiver
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean contains(Object arg0);
    @PolyFlowReceiver
    Iterator<E> iterator();
    @PolyFlowReceiver
    Object[] toArray();
    @PolyFlowReceiver
    <T> T[] toArray(T[] arg0);
    @PolyFlowReceiver
    boolean add(E arg0);
    @PolyFlowReceiver
    boolean remove(Object arg0);
    @PolyFlowReceiver
    boolean containsAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean addAll(Collection<? extends E> arg0);
    @PolyFlowReceiver
    boolean addAll(int arg0, Collection<? extends E> arg1);
    @PolyFlowReceiver    
    boolean removeAll(Collection<?> arg0);
    @PolyFlowReceiver
    boolean retainAll(Collection<?> arg0);
    void clear();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
    @PolyFlowReceiver
    E get(int arg0);
    @PolyFlowReceiver
    E set(int arg0, E arg1);
    void add(int arg0, E arg1);
    @PolyFlowReceiver
    E remove(int arg0);
    @PolyFlowReceiver
    int indexOf(Object arg0);
    @PolyFlowReceiver
    int lastIndexOf(Object arg0);
    @PolyFlowReceiver
    ListIterator<E> listIterator();
    @PolyFlowReceiver
    ListIterator<E> listIterator(int arg0);
    @PolyFlowReceiver
    List<E> subList(int arg0, int arg1);
}

@PolyFlowReceiver
interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E arg0);
    void add(E arg0);
}

@PolyFlowReceiver
class Locale implements Cloneable, Serializable {
//Added by pbsf
    final Locale ENGLISH;
    final Locale FRENCH;
    final Locale GERMAN;
    final Locale ITALIAN;
    final Locale JAPANESE;
    final Locale KOREAN;
    final Locale CHINESE;
    final Locale SIMPLIFIED_CHINESE;
    final Locale TRADITIONAL_CHINESE;
    final Locale FRANCE;
    final Locale GERMANY;
    final Locale ITALY;
    final Locale JAPAN;
    final Locale KOREA;
    final Locale CHINA;
    final Locale PRC;
    final Locale TAIWAN;
    final Locale UK;
    final Locale US;
    final Locale CANADA;
    final Locale CANADA_FRENCH;
    final Locale ROOT;
    final char PRIVATE_USE_EXTENSION;
    final char UNICODE_LOCALE_EXTENSION;
    Locale(String arg0, String arg1, String arg2);
    Locale(String arg0, String arg1);
    Locale(String arg0);
    static Locale getDefault();
    static Locale getDefault(Category arg0);
    static void setDefault(Locale arg0);
    static void setDefault(Category arg0, Locale arg1);
    static Locale[] getAvailableLocales();
    static String[] getISOCountries();
    static String[] getISOLanguages();
    String getLanguage();
    String getScript();
    String getCountry();
    String getVariant();
    String getExtension(char arg0);
    Set<Character> getExtensionKeys();
    Set<String> getUnicodeLocaleAttributes();
    String getUnicodeLocaleType(String arg0);
    Set<String> getUnicodeLocaleKeys();
    String toString();
    String toLanguageTag();
    static Locale forLanguageTag(String arg0);
    String getISO3Language() throws MissingResourceException;
    String getISO3Country() throws MissingResourceException;
    String getDisplayLanguage();
    String getDisplayLanguage(Locale arg0);
    String getDisplayScript();
    String getDisplayScript(Locale arg0);
    String getDisplayCountry();
    String getDisplayCountry(Locale arg0);
    String getDisplayVariant();
    String getDisplayVariant(Locale arg0);
    String getDisplayName();
    String getDisplayName(Locale arg0);
    Object clone();
    int hashCode();
    boolean equals(Object arg0);
}

@PolyFlowReceiver
class Locale$Builder {
//Added by pbsf
    Builder();
    Builder setLocale(Locale arg0);
    Builder setLanguageTag(String arg0);
    Builder setLanguage(String arg0);
    Builder setScript(String arg0);
    Builder setRegion(String arg0);
    Builder setVariant(String arg0);
    Builder setExtension(char arg0, String arg1);
    Builder setUnicodeLocaleKeyword(String arg0, String arg1);
    Builder addUnicodeLocaleAttribute(String arg0);
    Builder removeUnicodeLocaleAttribute(String arg0);
    Builder clear();
    Builder clearExtensions();
    Locale build();
}

interface Map<K, V> {
//Added by smillst
    int size();
    boolean isEmpty();
    @PolyFlowReceiver
    boolean containsKey(Object arg0);
    @PolyFlowReceiver
    boolean containsValue(Object arg0);
    @PolyFlowReceiver
    V get(Object arg0);
    @PolyFlowReceiver
    V put(K arg0, V arg1);
    @PolyFlowReceiver
    V remove(Object arg0);
    @PolyFlowReceiver
    void putAll(Map<? extends K,? extends V> arg0);
    void clear();
    @PolyFlowReceiver
    Set<K> keySet();
    @PolyFlowReceiver
    Collection<V> values();
    @PolyFlowReceiver
    Set<Entry<K,V>> entrySet();
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
}
interface Map$Entry<K, V> {
//Added by smillst
@PolyFlowReceiver
    K getKey();
    @PolyFlowReceiver
    V getValue();
    @PolyFlowReceiver
    V setValue(V arg0);
    @PolyFlowReceiver
    boolean equals(Object arg0);
    @PolyFlowReceiver
    int hashCode();
}


interface NavigableMap<K, V> extends SortedMap<K,V> {
//Added by pbsf
@PolyFlowReceiver
    Entry<K,V> lowerEntry(K arg0);
    @PolyFlowReceiver
    K lowerKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> floorEntry(K arg0);
    @PolyFlowReceiver
    K floorKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> ceilingEntry(K arg0);
    @PolyFlowReceiver
    K ceilingKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> higherEntry(K arg0);
    @PolyFlowReceiver
    K higherKey(K arg0);
    @PolyFlowReceiver
    Entry<K,V> firstEntry();
    @PolyFlowReceiver
    Entry<K,V> lastEntry();
    @PolyFlowReceiver
    Entry<K,V> pollFirstEntry();
    @PolyFlowReceiver
    Entry<K,V> pollLastEntry();
    @PolyFlowReceiver
    NavigableMap<K,V> descendingMap();
    @PolyFlowReceiver
    NavigableSet<K> navigableKeySet();
    @PolyFlowReceiver
    NavigableSet<K> descendingKeySet();
    @PolyFlowReceiver
    NavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    @PolyFlowReceiver
    NavigableMap<K,V> headMap(K arg0, boolean arg1);
    @PolyFlowReceiver
    NavigableMap<K,V> tailMap(K arg0, boolean arg1);
    @PolyFlowReceiver
    SortedMap<K,V> subMap(K arg0, K arg1);
    @PolyFlowReceiver
    SortedMap<K,V> headMap(K arg0);
    @PolyFlowReceiver
    SortedMap<K,V> tailMap(K arg0);
}

@PolyFlowReceiver
interface NavigableSet<E> extends SortedSet<E> {
    E lower(E arg0);
    E floor(E arg0);
    E ceiling(E arg0);
    E higher(E arg0);
    E pollFirst();
    E pollLast();
    Iterator<E> iterator();
    NavigableSet<E> descendingSet();
    Iterator<E> descendingIterator();
    NavigableSet<E> subSet(E arg0, boolean arg1, E arg2, boolean arg3);
    NavigableSet<E> headSet(E arg0, boolean arg1);
    NavigableSet<E> tailSet(E arg0, boolean arg1);
    SortedSet<E> subSet(E arg0, E arg1);
    SortedSet<E> headSet(E arg0);
    SortedSet<E> tailSet(E arg0);
}

class NoSuchElementException{
            NoSuchElementException();
}

@PolyFlowReceiver
interface Queue<E> extends Collection<E> {
    boolean add(E arg0);
    boolean offer(E arg0);
    E remove();
    E poll();
    E element();
    E peek();
}

class Random implements Serializable {
    Random();
    Random(long arg0);
    void setSeed(long arg0);
    protected int next(int arg0);
    void nextBytes(byte[] arg0);
    int nextInt() @Source(FlowPermission.RANDOM);
    int nextInt(int arg0) @Source(FlowPermission.RANDOM);
    long nextLong() @Source(FlowPermission.RANDOM);
    boolean nextBoolean() @Source(FlowPermission.RANDOM);
    float nextFloat() @Source(FlowPermission.RANDOM);
    double nextDouble() @Source(FlowPermission.RANDOM);
    double nextGaussian() @Source(FlowPermission.RANDOM);
}

@PolyFlowReceiver
class ResourceBundle {
    protected ResourceBundle parent;
    ResourceBundle();
    String getString(String arg0);
    String[] getStringArray(String arg0);
    Object getObject(String arg0);
    Locale getLocale();
    protected void setParent(ResourceBundle arg0);
    static ResourceBundle getBundle(String arg0);
    static ResourceBundle getBundle(String arg0, Control arg1);
    static ResourceBundle getBundle(String arg0, Locale arg1);
    static ResourceBundle getBundle(String arg0, Locale arg1, Control arg2);
    static ResourceBundle getBundle(String arg0, Locale arg1, ClassLoader arg2);
    static ResourceBundle getBundle(String arg0, Locale arg1, ClassLoader arg2, Control arg3);
    static void clearCache();
    static void clearCache(ClassLoader arg0);
    protected Object handleGetObject(String arg0);
    Enumeration<String> getKeys();
    boolean containsKey(String arg0);
    Set<String> keySet();
    protected Set<String> handleKeySet();
}

@PolyFlowReceiver
class ResourceBundle$Control {
    final List<String> FORMAT_DEFAULT;
    final List<String> FORMAT_CLASS;
    final List<String> FORMAT_PROPERTIES;
    final long TTL_DONT_CACHE;
    final long TTL_NO_EXPIRATION_CONTROL;
    protected Control();
    static Control getControl(List<String> arg0);
    static Control getNoFallbackControl(List<String> arg0);
    List<String> getFormats(String arg0);
    List<Locale> getCandidateLocales(String arg0, Locale arg1);
    Locale getFallbackLocale(String arg0, Locale arg1);
    ResourceBundle newBundle(String arg0, Locale arg1, String arg2, ClassLoader arg3, boolean arg4) throws IllegalAccessException,InstantiationException,IOException;
    long getTimeToLive(String arg0, Locale arg1);
    boolean needsReload(String arg0, Locale arg1, String arg2, ClassLoader arg3, ResourceBundle arg4, long arg5);
    String toBundleName(String arg0, Locale arg1);
    String toResourceName(String arg0, String arg1);
}

@PolyFlowReceiver
class Scanner implements Iterator<String>, Closeable {
    Scanner(Readable arg0);
    Scanner(InputStream arg0);
    Scanner(InputStream arg0, String arg1);
    Scanner(File arg0) throws FileNotFoundException;
    Scanner(File arg0, String arg1) throws FileNotFoundException;
    Scanner(Path arg0) throws IOException;
    Scanner(Path arg0, String arg1) throws IOException;
    Scanner(String arg0);
    Scanner(ReadableByteChannel arg0);
    Scanner(ReadableByteChannel arg0, String arg1);
    void close();
    IOException ioException();
    Pattern delimiter();
    Scanner useDelimiter(Pattern arg0);
    Scanner useDelimiter(String arg0);
    Locale locale();
    Scanner useLocale(Locale arg0);
    int radix();
    Scanner useRadix(int arg0);
    MatchResult match();
    String toString();
    boolean hasNext();
    String next();
    void remove();
    boolean hasNext(String arg0);
    String next(String arg0);
    boolean hasNext(Pattern arg0);
    String next(Pattern arg0);
    boolean hasNextLine();
    String nextLine();
    String findInLine(String arg0);
    String findInLine(Pattern arg0);
    String findWithinHorizon(String arg0, int arg1);
    String findWithinHorizon(Pattern arg0, int arg1);
    Scanner skip(Pattern arg0);
    Scanner skip(String arg0);
    boolean hasNextBoolean();
    boolean nextBoolean();
    boolean hasNextByte();
    boolean hasNextByte(int arg0);
    byte nextByte();
    byte nextByte(int arg0);
    boolean hasNextShort();
    boolean hasNextShort(int arg0);
    short nextShort();
    short nextShort(int arg0);
    boolean hasNextInt();
    boolean hasNextInt(int arg0);
    int nextInt();
    int nextInt(int arg0);
    boolean hasNextLong();
    boolean hasNextLong(int arg0);
    long nextLong();
    long nextLong(int arg0);
    boolean hasNextFloat();
    float nextFloat();
    boolean hasNextDouble();
    double nextDouble();
    boolean hasNextBigInteger();
    boolean hasNextBigInteger(int arg0);
    BigInteger nextBigInteger();
    BigInteger nextBigInteger(int arg0);
    boolean hasNextBigDecimal();
    BigDecimal nextBigDecimal();
    Scanner reset();
}

@PolyFlowReceiver
interface Set<E> extends Collection<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean retainAll(Collection<?> arg0);
    boolean removeAll(Collection<?> arg0);
    void clear();
    boolean equals(Object arg0);
    int hashCode();
}

@PolyFlowReceiver
interface SortedMap<K, V> extends Map<K,V> {
    Comparator<? super K> comparator();
    SortedMap<K,V> subMap(K arg0, K arg1);
    SortedMap<K,V> headMap(K arg0);
    SortedMap<K,V> tailMap(K arg0);
    K firstKey();
    K lastKey();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
}

@PolyFlowReceiver
interface SortedSet<E> extends Set<E> {
    Comparator<? super E> comparator();
    SortedSet<E> subSet(E arg0, E arg1);
    SortedSet<E> headSet(E arg0);
    SortedSet<E> tailSet(E arg0);
    E first();
    E last();
}

@PolyFlowReceiver
class Stack<E> extends Vector<E> {
    Stack();
    E push(E arg0);
    E pop();
    E peek();
    boolean empty();
    int search(Object arg0);
}

@PolyFlowReceiver
class StringTokenizer implements Enumeration<Object> {
//Added by pbsf
    StringTokenizer(String arg0, String arg1, boolean arg2);
    StringTokenizer(String arg0, String arg1);
    StringTokenizer(String arg0);
    boolean hasMoreTokens();
    String nextToken();
    String nextToken(String arg0);
    boolean hasMoreElements();
    Object nextElement();
    int countTokens();
}

@PolyFlowReceiver
class TimeZone implements Serializable, Cloneable {
    final int SHORT;
    final int LONG;
    TimeZone();
    int getOffset(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5);
    int getOffset(long arg0);
    void setRawOffset(int arg0);
    int getRawOffset();
    String getID();
    void setID(String arg0);
    String getDisplayName();
    String getDisplayName(Locale arg0);
    String getDisplayName(boolean arg0, int arg1);
    String getDisplayName(boolean arg0, int arg1, Locale arg2);
    int getDSTSavings();
    boolean useDaylightTime();
    boolean observesDaylightTime();
    boolean inDaylightTime(Date arg0);
    static TimeZone getTimeZone(String arg0);
    static String[] getAvailableIDs(int arg0);
    static String[] getAvailableIDs();
    static TimeZone getDefault();
    static void setDefault(TimeZone arg0);
    boolean hasSameRules(TimeZone arg0);
    Object clone();
}

@PolyFlowReceiver
class TreeMap<K, V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable {
    TreeMap();
    TreeMap(Comparator<? super K> arg0);
    TreeMap(Map<? extends K,? extends V> arg0);
    TreeMap(SortedMap<K,? extends V> arg0);
    int size();
    boolean containsKey(Object arg0);
    boolean containsValue(Object arg0);
    V get(Object arg0);
    Comparator<? super K> comparator();
    K firstKey();
    K lastKey();
    void putAll(Map<? extends K,? extends V> arg0);
    V put(K arg0, V arg1);
    V remove(Object arg0);
    void clear();
    Object clone();
    Entry<K,V> firstEntry();
    Entry<K,V> lastEntry();
    Entry<K,V> pollFirstEntry();
    Entry<K,V> pollLastEntry();
    Entry<K,V> lowerEntry(K arg0);
    K lowerKey(K arg0);
    Entry<K,V> floorEntry(K arg0);
    K floorKey(K arg0);
    Entry<K,V> ceilingEntry(K arg0);
    K ceilingKey(K arg0);
    Entry<K,V> higherEntry(K arg0);
    K higherKey(K arg0);
    Set<K> keySet();
    NavigableSet<K> navigableKeySet();
    NavigableSet<K> descendingKeySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    NavigableMap<K,V> descendingMap();
    NavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    NavigableMap<K,V> headMap(K arg0, boolean arg1);
    NavigableMap<K,V> tailMap(K arg0, boolean arg1);
    SortedMap<K,V> subMap(K arg0, K arg1);
    SortedMap<K,V> headMap(K arg0);
    SortedMap<K,V> tailMap(K arg0);
}


@PolyFlowReceiver
class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    protected Object[] elementData;
    protected int elementCount;
    protected int capacityIncrement;
    Vector(int arg0, int arg1);
    Vector(int arg0);
    Vector();
    Vector(Collection<? extends E> arg0);
    void copyInto(Object[] arg0);
    void trimToSize();
    void ensureCapacity(int arg0);
    void setSize(int arg0);
    int capacity();
    int size();
    boolean isEmpty();
    Enumeration<E> elements();
    boolean contains(Object arg0);
    int indexOf(Object arg0);
    int indexOf(Object arg0, int arg1);
    int lastIndexOf(Object arg0);
    int lastIndexOf(Object arg0, int arg1);
    E elementAt(int arg0);
    E firstElement();
    E lastElement();
    void setElementAt(E arg0, int arg1);
    void removeElementAt(int arg0);
    void insertElementAt(E arg0, int arg1);
    void addElement(E arg0);
    boolean removeElement(Object arg0);
    void removeAllElements();
    Object clone();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    E get(int arg0);
    E set(int arg0, E arg1);
    boolean add(E arg0);
    boolean remove(Object arg0);
    void add(int arg0, E arg1);
    E remove(int arg0);
    void clear();
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    boolean addAll(int arg0, Collection<? extends E> arg1);
    boolean equals(Object arg0);
    int hashCode();
    String toString();
    List<E> subList(int arg0, int arg1);
    protected void removeRange(int arg0, int arg1);
    ListIterator<E> listIterator(int arg0);
    ListIterator<E> listIterator();
    Iterator<E> iterator();
}

package java.util.concurrent;

class ThreadPoolExecutor{
        ThreadPoolExecutor(int arg0, int arg1, long arg2, TimeUnit arg3, BlockingQueue<Runnable> arg4, ThreadFactory arg5);
}
class FutureTask{
        protected void done();
        boolean isCancelled();
        V get() throws InterruptedException,ExecutionException;
        V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
        FutureTask(Callable<V> arg0);
        boolean cancel(boolean arg0);
}
class Callable{
        V call() throws Exception;
}
class ThreadFactory{
        Thread newThread(Runnable arg0);
}

@PolyFlowReceiver
interface BlockingDeque<E> extends BlockingQueue<E>, Deque<E> {
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    void putFirst(E arg0) throws InterruptedException;
    void putLast(E arg0) throws InterruptedException;
    boolean offerFirst(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offerLast(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E takeFirst() throws InterruptedException;
    E takeLast() throws InterruptedException;
    E pollFirst(long arg0, TimeUnit arg1) throws InterruptedException;
    E pollLast(long arg0, TimeUnit arg1) throws InterruptedException;
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E remove();
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E element();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int size();
    Iterator<E> iterator();
    void push(E arg0);
}

@PolyFlowReceiver
interface BlockingQueue<E> extends Queue<E> {
//Added by pbsf
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    int remainingCapacity();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
}

@PolyFlowReceiver
class ConcurrentHashMap<K, V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {
//Added by pbsf
    ConcurrentHashMap(int arg0, float arg1, int arg2);
    ConcurrentHashMap(int arg0, float arg1);
    ConcurrentHashMap(int arg0);
    ConcurrentHashMap();
    ConcurrentHashMap(Map<? extends K,? extends V> arg0);
    boolean isEmpty();
    int size();
    V get(Object arg0);
    boolean containsKey(Object arg0);
    boolean containsValue(Object arg0);
    boolean contains(Object arg0);
    V put(K arg0, V arg1);
    V putIfAbsent(K arg0, V arg1);
    void putAll(Map<? extends K,? extends V> arg0);
    V remove(Object arg0);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
    void clear();
    Set<K> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    Enumeration<K> keys();
    Enumeration<V> elements();
}

@PolyFlowReceiver
class ConcurrentLinkedQueue<E> extends AbstractQueue<E> implements Queue<E>, Serializable {
//Added by pbsf
    ConcurrentLinkedQueue();
    ConcurrentLinkedQueue(Collection<? extends E> arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E poll();
    E peek();
    boolean isEmpty();
    int size();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    Iterator<E> iterator();
}

@PolyFlowReceiver
interface ConcurrentMap<K, V> extends Map<K,V> {
//Added by pbsf
    V putIfAbsent(K arg0, V arg1);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
}

@PolyFlowReceiver
class CountDownLatch {
//Added by pbsf
    CountDownLatch(int arg0);
    void await() throws InterruptedException;
    boolean await(long arg0, TimeUnit arg1) throws InterruptedException;
    void countDown();
    long getCount();
    String toString();
}

@PolyFlowReceiver
interface Future<V> {
//Added by pbsf
    boolean cancel(boolean arg0);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException,ExecutionException;
    V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
}
class Executor{
            void execute(Runnable arg0);
}


@PolyFlowReceiver
interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long arg0, TimeUnit arg1) throws InterruptedException;
    <T> Future<T> submit(Callable<T> arg0);
    <T> Future<T> submit(Runnable arg0, T arg1);
    Future<?> submit(Runnable arg0);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0) throws InterruptedException,ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException,ExecutionException,TimeoutException;
}

@PolyFlowReceiver
class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
//Added by pbsf
    LinkedBlockingQueue();
    LinkedBlockingQueue(int arg0);
    LinkedBlockingQueue(Collection<? extends E> arg0);
    int size();
    int remainingCapacity();
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offer(E arg0);
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E poll();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    String toString();
    void clear();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    Iterator<E> iterator();
}

@PolyFlowReceiver
interface ScheduledExecutorService extends ExecutorService {
    ScheduledFuture<?> schedule(Runnable arg0, long arg1, TimeUnit arg2);
    <V> ScheduledFuture<V> schedule(Callable<V> arg0, long arg1, TimeUnit arg2);
    ScheduledFuture<?> scheduleAtFixedRate(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
}

class TimeUnit{
        long toMillis(long arg0);
}

package java.util.concurrent.atomic;

class AtomicBoolean{
        AtomicBoolean();
        boolean get();
        void set(boolean arg0);
}

@PolyFlowReceiver
class AtomicInteger extends Number implements Serializable {
//Added by pbsf
    AtomicInteger(int arg0);
    AtomicInteger();
    int get();
    void set(int arg0);
    void lazySet(int arg0);
    int getAndSet(int arg0);
    boolean compareAndSet(int arg0, int arg1);
    boolean weakCompareAndSet(int arg0, int arg1);
    int getAndIncrement();
    int getAndDecrement();
    int getAndAdd(int arg0);
    int incrementAndGet();
    int decrementAndGet();
    int addAndGet(int arg0);
    String toString();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
}

@PolyFlowReceiver
class AtomicLong extends Number implements Serializable {
//Added by pbsf
    AtomicLong(long arg0);
    AtomicLong();
    long get();
    void set(long arg0);
    void lazySet(long arg0);
    long getAndSet(long arg0);
    boolean compareAndSet(long arg0, long arg1);
    boolean weakCompareAndSet(long arg0, long arg1);
    long getAndIncrement();
    long getAndDecrement();
    long getAndAdd(long arg0);
    long incrementAndGet();
    long decrementAndGet();
    long addAndGet(long arg0);
    String toString();
    int intValue();
    long longValue();
    float floatValue();
    double doubleValue();
}

@PolyFlowReceiver
class AtomicLongArray implements Serializable {
//Added by pbsf
    AtomicLongArray(int arg0);
    AtomicLongArray(long[] arg0);
    int length();
    long get(int arg0);
    void set(int arg0, long arg1);
    void lazySet(int arg0, long arg1);
    long getAndSet(int arg0, long arg1);
    boolean compareAndSet(int arg0, long arg1, long arg2);
    boolean weakCompareAndSet(int arg0, long arg1, long arg2);
    long getAndIncrement(int arg0);
    long getAndDecrement(int arg0);
    long getAndAdd(int arg0, long arg1);
    long incrementAndGet(int arg0);
    long decrementAndGet(int arg0);
    long addAndGet(int arg0, long arg1);
    String toString();
}

@PolyFlowReceiver
class AtomicReference<V> implements Serializable {
//Added by pbsf
    AtomicReference(V arg0);
    AtomicReference();
    V get();
    void set(V arg0);
    void lazySet(V arg0);
    boolean compareAndSet(V arg0, V arg1);
    boolean weakCompareAndSet(V arg0, V arg1);
    V getAndSet(V arg0);
    String toString();
}

@PolyFlowReceiver
class AtomicReferenceArray<E> implements Serializable {
//Added by pbsf
    AtomicReferenceArray(int arg0);
    AtomicReferenceArray(E[] arg0);
    int length();
    E get(int arg0);
    void set(int arg0, E arg1);
    void lazySet(int arg0, E arg1);
    E getAndSet(int arg0, E arg1);
    boolean compareAndSet(int arg0, E arg1, E arg2);
    boolean weakCompareAndSet(int arg0, E arg1, E arg2);
    String toString();
}

package java.util.concurrent.locks;

@PolyFlowReceiver
interface Lock {
//Added by pbsf
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long arg0, TimeUnit arg1) throws InterruptedException;
    void unlock();
    Condition newCondition();
}

package java.util.logging;

@PolyFlowReceiver
class Logger {
//Added by pbsf
    final String GLOBAL_LOGGER_NAME;
    final Logger global;
    static Logger getGlobal();
    protected Logger(String arg0, String arg1);
    static Logger getLogger(String arg0);
    static Logger getLogger(String arg0, String arg1);
    static Logger getAnonymousLogger();
    static Logger getAnonymousLogger(String arg0);
    ResourceBundle getResourceBundle();
    String getResourceBundleName();
    void setFilter(Filter arg0) throws SecurityException;
    Filter getFilter();
    void log(LogRecord arg0);
    void log(Level arg0, String arg1);
    void log(Level arg0, String arg1, Object arg2);
    void log(Level arg0, String arg1, Object[] arg2);
    void log(Level arg0, String arg1, Throwable arg2);
    void logp(Level arg0, String arg1, String arg2, String arg3);
    void logp(Level arg0, String arg1, String arg2, String arg3, Object arg4);
    void logp(Level arg0, String arg1, String arg2, String arg3, Object[] arg4);
    void logp(Level arg0, String arg1, String arg2, String arg3, Throwable arg4);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Object arg5);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Object[] arg5);
    void logrb(Level arg0, String arg1, String arg2, String arg3, String arg4, Throwable arg5);
    void entering(String arg0, String arg1);
    void entering(String arg0, String arg1, Object arg2);
    void entering(String arg0, String arg1, Object[] arg2);
    void exiting(String arg0, String arg1);
    void exiting(String arg0, String arg1, Object arg2);
    void throwing(String arg0, String arg1, Throwable arg2);
    void severe(String arg0);
    void warning(String arg0);
    void info(String arg0);
    void config(String arg0);
    void fine(String arg0);
    void finer(String arg0);
    void finest(String arg0);
    void setLevel(Level arg0) throws SecurityException;
    Level getLevel();
    boolean isLoggable(Level arg0);
    String getName();
    void addHandler(Handler arg0) throws SecurityException;
    void removeHandler(Handler arg0) throws SecurityException;
    Handler[] getHandlers();
    void setUseParentHandlers(boolean arg0);
    boolean getUseParentHandlers();
    Logger getParent();
    void setParent(Logger arg0);
}

package java.util.regex;
class Matcher{
            Matcher usePattern(Pattern arg0);
            boolean lookingAt();
            int regionStart();
            Matcher region(int arg0, int arg1);
            int regionEnd();
}

package java.util.zip;
@PolyFlowReceiver
class GZIPInputStream{
            GZIPInputStream(InputStream arg0) throws IOException;
}

@PolyFlowReceiver
class ZipOutputStream{
            void putNextEntry(ZipEntry arg0) throws IOException;
            void close() throws IOException;
            ZipOutputStream(OutputStream arg0);
            void closeEntry() throws IOException;
}
class ZipEntry{
            ZipEntry(String arg0);
}


package java.util.regex;


class Pattern { 
    // DAM

    @PolyFlowReceiver
    Matcher matcher(CharSequence input) ;

    @PolyFlow
    static Pattern compile(String regex);

    @PolyFlow
    static Pattern compile(String regex, int flags);

    // Flags have same permission as Pattern instance
    @PolyFlowReceiver
    int flags();

    @PolyFlowReceiver
    Pattern pattern();

    @PolySource @PolySink String [] split(@PolySource @PolySink CharSequence input, @Sink(FlowPermission.CONDITIONAL) int limit);

    @PolyFlow
    static String quote(String s);

    @PolyFlow
    static boolean matches(String regex, CharSequence input);

}

class Matcher {
    // DAM


    @PolyFlowReceiver
    String group();
    
    @PolySource @PolySink String group(@Sink(FlowPermission.CONDITIONAL) int group) @PolySource @PolySink;
    
    @PolySource @PolySink String group(@Sink(FlowPermission.CONDITIONAL) String name) @PolySource @PolySink;

    @PolyFlowReceiver
    boolean find();

    @PolySource @PolySink boolean find(@Sink(FlowPermission.CONDITIONAL) int start) @PolySource @PolySink;

    @PolyFlowReceiver
    boolean matches();
 
    @PolyFlowReceiver
    int start();

    @PolySource @PolySink int start(@Sink(FlowPermission.CONDITIONAL) int group) @PolySource @PolySink;

    @PolyFlowReceiver
    int end();

    @PolySource @PolySink int end(@Sink(FlowPermission.CONDITIONAL) int group) @PolySource @PolySink;

    // Don't think this needs one.
    int groupCount();

    @PolyFlowReceiver
    Matcher reset();

    @PolyFlowReceiver
    Matcher reset(CharSequence input);

    @PolyFlowReceiver
    String replaceAll (String replacement);

    @PolyFlowReceiver
    String replaceFirst (String replacement);
}

package javax.crypto;
@PolyFlowReceiver
class CipherOutputStream{
        void write(byte[] arg0, int arg1, int arg2) throws IOException;
        void flush() throws IOException;
        CipherOutputStream(OutputStream arg0, Cipher arg1);
        void close() throws IOException;
}
class Cipher{
        static Cipher getInstance(String arg0) throws NoSuchAlgorithmException,NoSuchPaddingException;
        void init(int arg0, Key arg1) throws InvalidKeyException;
}
@PolyFlowReceiver
class CipherInputStream{
        int read(byte[] arg0) throws IOException;
        CipherInputStream(InputStream arg0, Cipher arg1);
        void close() throws IOException;
}
package android.net;
class NetworkInfo{
        int getType();
}
class ConnectivityManager{
        @Source(ACCESS_NETWORK_STATE) NetworkInfo getActiveNetworkInfo();
}
class TrafficStats{
        static void tagSocket(Socket socket) throws SocketException;
        static void incrementOperationCount(int operationCount);
        static void incrementOperationCount(int tag, int operationCount);
        static void setThreadStatsTag(int tag);
        static int getThreadStatsTag();
        static void untagSocket(Socket socket) throws SocketException;
        static void clearThreadStatsTag();
}

package javax.crypto.spec;
class SecretKeySpec{
        SecretKeySpec(byte[] arg0, String arg1);
}
package javax.xml.parsers;

class DocumentBuilder{
    Document newDocument();
    @PolyFlowReceiver
    Document parse(File arg0);
}
class DocumentBuilderFactory{
    DocumentBuilder newDocumentBuilder();
    static DocumentBuilderFactory newInstance();
}

package javax.xml.transform;
class TransformerFactory {
    @PolyFlowReceiver
    Transformer newTransformer() throws TransformerConfigurationException;
    static TransformerFactory newInstance() throws TransformerFactoryConfigurationError;
}

package org.apache.http;
class ConnectionReuseStrategy{
            boolean keepAlive(HttpResponse arg0, HttpContext arg1);
}
class Header{
            String getValue();
            HeaderElement[] getElements() throws ParseException;
}
class HeaderElement{
            String getName();
            String getValue();
}
class HeaderElementIterator{
            boolean hasNext();
            HeaderElement nextElement();
}
class HeaderIterator{
            boolean hasNext();
}

class HttpEntity{
            Header getContentEncoding();
            boolean isRepeatable();
            InputStream getContent() throws IOException,IllegalStateException;
            void writeTo(@PolySink OutputStream arg0) throws IOException;
            long getContentLength();
}
class HttpEntityEnclosingRequest{
            HttpEntity getEntity();
}
class HttpHost{
            HttpHost(String hostname, int port);
            HttpHost(String hostname);
}
class HttpMessage{
            HttpParams getParams();
            HeaderIterator headerIterator(String arg0);
            Header getFirstHeader(String arg0);
            boolean containsHeader(String arg0);
            void addHeader(String arg0, String arg1);
            Header[] getHeaders(String arg0);
}
class HttpRequestInterceptor{
            void process(HttpRequest arg0, HttpContext arg1) throws HttpException,IOException;
}
class HttpResponse{
            void setEntity(HttpEntity arg0);
            StatusLine getStatusLine();
            @Source(FlowPermission.INTERNET) HttpEntity getEntity();
}
class HttpResponseInterceptor{
            void process(HttpResponse arg0, HttpContext arg1) throws HttpException,IOException;
}
class ProtocolVersion{
            boolean lessEquals(ProtocolVersion version);
}
class StatusLine{
            String getReasonPhrase();
            int getStatusCode();
            ProtocolVersion getProtocolVersion();
}
class TokenIterator{
            boolean hasNext();
            String nextToken();
}


package org.apache.http.conn;
class ClientConnectionManager{
            ClientConnectionRequest requestConnection(HttpRoute arg0, Object arg1);
}
class ConnectionKeepAliveStrategy{
            long getKeepAliveDuration(HttpResponse arg0, HttpContext arg1);
}

package org.apache.http.message;
class BasicHeaderElementIterator{
            BasicHeaderElementIterator(HeaderIterator headerIterator);
}

package org.apache.http.conn.params;
class ConnPerRoute{
            int getMaxForRoute(HttpRoute arg0);
}
class ConnManagerParams{
            static void setMaxConnectionsPerRoute(HttpParams params, ConnPerRoute connPerRoute);
            static void setMaxTotalConnections(HttpParams params, int maxTotalConnections);
}

package org.apache.http.conn.ssl;
class SSLSocketFactory{
            static SSLSocketFactory getSocketFactory();
}

package org.apache.http.conn.scheme;
class SchemeRegistry{
            SchemeRegistry();
            Scheme register(Scheme sch);
}
class Scheme{
            Scheme(String name, SocketFactory factory, int port);
}
class PlainSocketFactory{
            static PlainSocketFactory getSocketFactory();
}

package org.apache.http.entity;
@PolyFlowReceiver
class InputStreamEntity{
            InputStreamEntity(InputStream instream, long length);
}
class HttpEntityWrapper{
            long getContentLength();
            HttpEntityWrapper(HttpEntity wrapped);
            @PolyFlowReceiver
            InputStream getContent() throws IOException;
            @PolyFlowReceiver
            void writeTo(OutputStream outstream) throws IOException;
}
@PolyFlowReceiver
class AbstractHttpEntity{
            void setChunked(boolean b);
            void setContentEncoding(String ceString);
}

package org.apache.http.client.entity;

@PolyFlowReceiver
class UrlEncodedFormEntity {

    // Added by mcarthur
    // Constructor returns do not work yet.
    // And I have my doubts about Poly for Generic types.
    @PolySource @PolySink UrlEncodedFormEntity(@Sink(FlowPermission.CONDITIONAL) List<? extends @PolySource @PolySink NameValuePair> parameters) @PolySource @PolySink ; 
        UrlEncodedFormEntity(List<? extends NameValuePair> parameters, String encoding) throws UnsupportedEncodingException;
}



package org.apache.http.client.methods;

class HttpPost {

    HttpPost(@Sink(FlowPermission.INTERNET) String postUrl);

    // Added by mcarthur
    // I would like for this to actually work, but it does not.
//    void setEntity(@PolySource @PolySink HttpEntity entity) @PolySource @PolySink;
    void setEntity(@Sink(FlowPermission.INTERNET) HttpEntity entity) @Sink(FlowPermission.INTERNET);

}

class HttpUriRequest{
            void abort() throws UnsupportedOperationException;
            boolean isAborted();
}
class HttpPut{
            HttpPut(String uri);
}
class HttpGet{
            HttpGet(String uri);
}


package org.apache.http.client;

class HttpClient {

    // Added by mcarthur
    @Source(FlowPermission.INTERNET)
    HttpResponse execute(@Sink(FlowPermission.INTERNET) HttpUriRequest request);
                @Source(FlowPermission.INTERNET) HttpParams getParams();

}

package org.apache.http.impl;
class DefaultConnectionReuseStrategy{
            boolean keepAlive(HttpResponse response, HttpContext context);
            protected TokenIterator createTokenIterator(HeaderIterator hit);
            DefaultConnectionReuseStrategy();
}

package org.apache.http.impl.conn.tsccm;
class ThreadSafeClientConnManager{
            ThreadSafeClientConnManager(HttpParams params, SchemeRegistry schreg);
            ClientConnectionRequest requestConnection(HttpRoute route, Object state);
            void closeExpiredConnections();
            int getConnectionsInPool();
            void closeIdleConnections(long idleTimeout, TimeUnit tunit);
}

package org.apache.http.impl.client;
class AbstractHttpClient{
            protected ConnectionKeepAliveStrategy createConnectionKeepAliveStrategy();
            void addRequestInterceptor(HttpRequestInterceptor itcp);
            protected ConnectionReuseStrategy createConnectionReuseStrategy();
            void addResponseInterceptor(HttpResponseInterceptor itcp);
}

class DefaultHttpClient extends AbstractHttpClient {
    DefaultHttpClient(ClientConnectionManager arg0, HttpParams arg1);
    DefaultHttpClient(HttpParams arg0);
    DefaultHttpClient();
    
    protected HttpParams createHttpParams();
    protected HttpRequestExecutor createRequestExecutor();
    protected ClientConnectionManager createClientConnectionManager();
    protected HttpContext createHttpContext();
    protected ConnectionReuseStrategy createConnectionReuseStrategy();
    protected ConnectionKeepAliveStrategy createConnectionKeepAliveStrategy();
    protected AuthSchemeRegistry createAuthSchemeRegistry();
    protected CookieSpecRegistry createCookieSpecRegistry();
    protected BasicHttpProcessor createHttpProcessor();
    protected HttpRequestRetryHandler createHttpRequestRetryHandler();
    protected RedirectHandler createRedirectHandler();
    protected AuthenticationHandler createTargetAuthenticationHandler();
    protected AuthenticationHandler createProxyAuthenticationHandler();
    protected CookieStore createCookieStore();
    protected CredentialsProvider createCredentialsProvider();
    protected HttpRoutePlanner createHttpRoutePlanner();
    protected UserTokenHandler createUserTokenHandler();
}

package org.apache.http.message;
class BasicNameValuePair{
        BasicNameValuePair(String name, @PolySource @PolySink String value);
}


package org.apache.http.params;
class BasicHttpParams{
            BasicHttpParams();
}
class HttpConnectionParams{
            static void setSoTimeout(HttpParams params, int timeout);
            static void setSocketBufferSize(HttpParams params, int size);
            static void setConnectionTimeout(HttpParams params, int timeout);
}
class HttpParams{
            boolean removeParameter(String arg0);
            HttpParams setParameter(String arg0, Object arg1);
}
class HttpProtocolParams{
            static void setUserAgent(HttpParams params, String useragent);
}

package org.w3c.dom;

class NodeList {
    @PolySource @PolySink Node item(@Sink(FlowPermission.CONDITIONAL) int index) @PolySource @PolySink;
    @PolyFlowReceiver
    int getLength();

}

class Node {

    @PolyFlowReceiver
    String getTextContent() throws DOMException;

    @PolyFlowReceiver
    Node getPreviousSibling();

    @PolyFlowReceiver
    short getNodeType();

    @PolyFlowReceiver
    Node appendChild(Node arg0) throws DOMException;

    void normalize();
}

class Document{
    @PolyFlowReceiver
    NodeList getElementsByTagName(String arg0);
    @PolyFlowReceiver
    Text createTextNode(String arg0);
    @PolyFlowReceiver
    Element getDocumentElement();
    @PolyFlowReceiver
    Element createElement(String arg0) throws DOMException;
}

class Element{
    @PolyFlowReceiver
    NodeList getElementsByTagName(String arg0);
    @PolyFlowReceiver
    String getTagName();
}
package org.xml.sax;
class ContentHandler{
        void characters(char[] arg0, int arg1, int arg2) throws SAXException;
        void startElement(String arg0, String arg1, String arg2, Attributes arg3) throws SAXException;
        void startDocument() throws SAXException;
        void endDocument() throws SAXException;
        void endElement(String arg0, String arg1, String arg2) throws SAXException;
}
class Attributes{
        String getValue(String arg0, String arg1);
        String getValue(String arg0);
}

package org.xml.sax.helpers;
class DefaultHandler{
        void endDocument() throws SAXException;
        void startElement(String arg0, String arg1, String arg2, Attributes arg3) throws SAXException;
        void characters(char[] arg0, int arg1, int arg2) throws SAXException;
        void startDocument() throws SAXException;
        DefaultHandler();
        void endElement(String arg0, String arg1, String arg2) throws SAXException;
}package org.xmlpull.v1;

class XmlPullParser {
    @PolyFlowReceiver
    String getText();
    @PolyFlowReceiver
    boolean isEmptyElementTag();
    @PolyFlowReceiver
    int next();
    @PolyFlowReceiver
    String getName();
}
